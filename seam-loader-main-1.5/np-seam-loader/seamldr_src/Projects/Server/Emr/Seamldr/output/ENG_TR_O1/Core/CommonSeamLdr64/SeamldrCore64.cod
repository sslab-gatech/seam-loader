; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24210.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	MemZeroWithMovdir64B
PUBLIC	LoadModuleCode
PUBLIC	MapModulePages
PUBLIC	SetupStacks
PUBLIC	SetupKeyholeMapping
PUBLIC	SetupDataRegion
PUBLIC	MapSysInfoTables
PUBLIC	MapModuleRegion
PUBLIC	SetupSysInfoTable
PUBLIC	ReadSeamExtendMsr
PUBLIC	RecordSeamIdentity
PUBLIC	SeamldrAcm
PUBLIC	??_C@_0BO@JDKLNIGF@Failed?5to?5map?5sysinfo?5table?$CB?6?$AA@IMHBAIGO@ ;  ?? ::IMHBAIGO::`string'
PUBLIC	??_C@_0M@DFPCGKIO@SeamldrAcm?6?$AA@IMHBAIGO@	;  ?? ::IMHBAIGO::`string'
PUBLIC	??_C@_0BL@PDBNDKDJ@MaximumSupportMemAddress?3?5?$AA@IMHBAIGO@ ;  ?? ::IMHBAIGO::`string'
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@IMHBAIGO@		;  ?? ::IMHBAIGO::`string'
PUBLIC	??_C@_0BC@JHBKFAN@SEAMRR_BASE_MSR?3?5?$AA@IMHBAIGO@ ;  ?? ::IMHBAIGO::`string'
PUBLIC	??_C@_0BC@IPADEDPJ@SEAMRR_MASK_MSR?3?5?$AA@IMHBAIGO@ ;  ?? ::IMHBAIGO::`string'
PUBLIC	??_C@_0BH@EEOILHJA@Seamrr?5mask?5not?5valid?6?$AA@IMHBAIGO@ ;  ?? ::IMHBAIGO::`string'
PUBLIC	??_C@_0O@GKEDAJFE@Seamrr?5size?3?5?$AA@IMHBAIGO@ ;  ?? ::IMHBAIGO::`string'
PUBLIC	??_C@_0BH@MBPLKHLD@Writing?5seamrr?5mask?5?9?5?$AA@IMHBAIGO@ ;  ?? ::IMHBAIGO::`string'
PUBLIC	??_C@_0CH@NMPGKIPA@Mapped?5PSysInfoTable?5to?5virtual?5@IMHBAIGO@ ;  ?? ::IMHBAIGO::`string'
PUBLIC	??_C@_0DB@CIEFJNBN@SeamldrData?4SysInfoTable?9?$DOPSeaml@IMHBAIGO@ ;  ?? ::IMHBAIGO::`string'
PUBLIC	??_C@_0CN@CNLBMENP@SeamldrData?4PSeamldrConsts?9?$DOCCod@IMHBAIGO@ ;  ?? ::IMHBAIGO::`string'
PUBLIC	??_C@_0CP@HJNGJCGG@SeamldrData?4PSeamldrConsts?9?$DOCDat@IMHBAIGO@ ;  ?? ::IMHBAIGO::`string'
PUBLIC	??_C@_0CN@JLDAHCCF@SeamldrData?4PSeamldrConsts?9?$DOCDat@IMHBAIGO@ ;  ?? ::IMHBAIGO::`string'
PUBLIC	??_C@_0DM@IAMDNGHM@Can?8t?5map?5the?5Sysinfo?5table?0?5not@IMHBAIGO@ ;  ?? ::IMHBAIGO::`string'
PUBLIC	??_C@_0BH@KNKIAGPB@Seamrr?5range?5too?5big?3?5?$AA@IMHBAIGO@ ;  ?? ::IMHBAIGO::`string'
PUBLIC	??_C@_0DM@ILANBIGJ@Can?8t?5map?5the?5SEAMRR?5region?0?5not@IMHBAIGO@ ;  ?? ::IMHBAIGO::`string'
PUBLIC	??_C@_0BN@EABEMNCL@Invalid?5number?5of?5sockets?3?5?6?$AA@IMHBAIGO@ ;  ?? ::IMHBAIGO::`string'
PUBLIC	??_C@_0BO@INKHCOGJ@Socket?5CPUID?5table?5not?5valid?6?$AA@IMHBAIGO@ ;  ?? ::IMHBAIGO::`string'
PUBLIC	??_C@_0DB@BBEGNBAJ@P_SYS_INFO_TABLE?5version?5mismatc@IMHBAIGO@ ;  ?? ::IMHBAIGO::`string'
PUBLIC	??_C@_0BH@EKBKOKDP@Acquiring?5SEAMRR?5lock?6?$AA@IMHBAIGO@ ;  ?? ::IMHBAIGO::`string'
PUBLIC	??_C@_0CD@JDEDDDDN@SeamldrMutexStatus?5is?5not?5correc@IMHBAIGO@ ;  ?? ::IMHBAIGO::`string'
PUBLIC	??_C@_0BD@FOBAGBFE@AcmX2ApicId?5error?6?$AA@IMHBAIGO@ ;  ?? ::IMHBAIGO::`string'
PUBLIC	??_C@_0CM@LIHANEGM@Error?3?5P?5Seamldr?5hasn?8t?5shut?5dow@IMHBAIGO@ ;  ?? ::IMHBAIGO::`string'
PUBLIC	??_C@_0P@JKMHMCO@RDSEED?5failed?6?$AA@IMHBAIGO@	;  ?? ::IMHBAIGO::`string'
PUBLIC	??_C@_09LMCHEAJO@AslrRand?5?$AA@IMHBAIGO@	;  ?? ::IMHBAIGO::`string'
PUBLIC	??_C@_0BK@HHJIMKFB@Pseamldr?5Range?5too?5small?6?$AA@IMHBAIGO@ ;  ?? ::IMHBAIGO::`string'
PUBLIC	??_C@_0O@FKFJLLIL@SeamRR?5VA?3?50x?$AA@IMHBAIGO@ ;  ?? ::IMHBAIGO::`string'
PUBLIC	??_C@_0BA@HINKIKFF@SeamRR?5Size?3?50x?$AA@IMHBAIGO@ ;  ?? ::IMHBAIGO::`string'
PUBLIC	??_C@_0BF@LGBACFPP@Load?5?5P?9Seamld?5code?6?$AA@IMHBAIGO@ ;  ?? ::IMHBAIGO::`string'
PUBLIC	??_C@_0BP@KEEGAGND@Loading?5P?9Seamldr?5code?5failed?6?$AA@IMHBAIGO@ ;  ?? ::IMHBAIGO::`string'
PUBLIC	??_C@_0BO@FCLKAN@Failed?5to?5relocate?5P?9Seamldr?6?$AA@IMHBAIGO@ ;  ?? ::IMHBAIGO::`string'
PUBLIC	??_C@_0BF@CKNDFINP@Map?5P?9Seamldr?5pages?6?$AA@IMHBAIGO@ ;  ?? ::IMHBAIGO::`string'
PUBLIC	??_C@_0BM@DDMELFPJ@Failed?5to?5map?5module?5pages?6?$AA@IMHBAIGO@ ;  ?? ::IMHBAIGO::`string'
PUBLIC	??_C@_0O@NNMOLPJK@Setup?5stacks?6?$AA@IMHBAIGO@	;  ?? ::IMHBAIGO::`string'
PUBLIC	??_C@_0BI@CDALIHGP@Failed?5to?5setup?5stacks?6?$AA@IMHBAIGO@ ;  ?? ::IMHBAIGO::`string'
PUBLIC	??_C@_0P@MNGGMCMN@Setup?5keyhole?6?$AA@IMHBAIGO@ ;  ?? ::IMHBAIGO::`string'
PUBLIC	??_C@_0BK@FBODADJ@Failed?5to?5setup?5keyholes?6?$AA@IMHBAIGO@ ;  ?? ::IMHBAIGO::`string'
PUBLIC	??_C@_0BD@KDAKIHP@Setup?5Data?5Region?6?$AA@IMHBAIGO@ ;  ?? ::IMHBAIGO::`string'
PUBLIC	??_C@_0BN@OICIBGCH@Failed?5to?5setup?5data?5region?6?$AA@IMHBAIGO@ ;  ?? ::IMHBAIGO::`string'
PUBLIC	??_C@_0BC@DBKHJAMB@Map?5SysInfoTable?6?$AA@IMHBAIGO@ ;  ?? ::IMHBAIGO::`string'
PUBLIC	??_C@_0BF@FEICECMF@Setup?5Module?5Region?6?$AA@IMHBAIGO@ ;  ?? ::IMHBAIGO::`string'
PUBLIC	??_C@_0BO@OEPBOPGA@Failed?5to?5map?5Module?5Region?$CB?6?$AA@IMHBAIGO@ ;  ?? ::IMHBAIGO::`string'
PUBLIC	??_C@_0BG@DLHFFDEJ@Setup?5PSysinfo?5table?6?$AA@IMHBAIGO@ ;  ?? ::IMHBAIGO::`string'
PUBLIC	??_C@_0M@KPDHHIMA@Setup?5VMCS?6?$AA@IMHBAIGO@	;  ?? ::IMHBAIGO::`string'
PUBLIC	??_C@_0BG@NNIHHKKC@Record?5Seam?5identity?6?$AA@IMHBAIGO@ ;  ?? ::IMHBAIGO::`string'
PUBLIC	??_C@_0BK@EBJAMEFH@Exitingseamldr?6Status?3?50x?$AA@IMHBAIGO@ ;  ?? ::IMHBAIGO::`string'
EXTRN	Movdir64B:PROC
EXTRN	__readMsr64:PROC
EXTRN	__writeMsr64:PROC
EXTRN	shiftLeft64:PROC
EXTRN	BitScanForward64:PROC
EXTRN	GetPhyAddrMask:PROC
EXTRN	ComSerialOut:PROC
EXTRN	printHex:PROC
EXTRN	SetupVmcs:PROC
EXTRN	memcpy_s:PROC
EXTRN	MapPhysicalRange:PROC
EXTRN	MapPage:PROC
EXTRN	InitPseamldrPtCtx:PROC
EXTRN	InterlockedCompareExchange8:PROC
EXTRN	CpuidEx:PROC
EXTRN	RdSeed16:PROC
EXTRN	RelocateImage:PROC
EXTRN	memset:PROC
EXTRN	SeamldrData:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$MemZeroWithMovdir64B DD imagerel $LN11
	DD	imagerel $LN11+116
	DD	imagerel $unwind$MemZeroWithMovdir64B
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$GetX2ApicId DD imagerel GetX2ApicId
	DD	imagerel GetX2ApicId+47
	DD	imagerel $unwind$GetX2ApicId
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$MapModulePages DD imagerel $LN13
	DD	imagerel $LN13+190
	DD	imagerel $unwind$MapModulePages
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$SetupStacks DD imagerel $LN14
	DD	imagerel $LN14+252
	DD	imagerel $unwind$SetupStacks
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$SetupKeyholeMapping DD imagerel $LN17
	DD	imagerel $LN17+245
	DD	imagerel $unwind$SetupKeyholeMapping
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$SetupDataRegion DD imagerel $LN13
	DD	imagerel $LN13+209
	DD	imagerel $unwind$SetupDataRegion
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$MapSysInfoTables DD imagerel $LN5
	DD	imagerel $LN5+110
	DD	imagerel $unwind$MapSysInfoTables
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$MapModuleRegion DD imagerel $LN26
	DD	imagerel $LN26+387
	DD	imagerel $unwind$MapModuleRegion
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$SetupSysInfoTable DD imagerel $LN4
	DD	imagerel $LN4+379
	DD	imagerel $unwind$SetupSysInfoTable
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$RecordSeamIdentity DD imagerel $LN4
	DD	imagerel $LN4+98
	DD	imagerel $unwind$RecordSeamIdentity
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$SeamldrAcm DD imagerel $LN56
	DD	imagerel $LN56+2655
	DD	imagerel $unwind$SeamldrAcm
pdata	ENDS
;	COMDAT ??_C@_0BK@EBJAMEFH@Exitingseamldr?6Status?3?50x?$AA@IMHBAIGO@
EDATA32	SEGMENT
??_C@_0BK@EBJAMEFH@Exitingseamldr?6Status?3?50x?$AA@IMHBAIGO@ DB 'Exiting'
	DB	'seamldr', 0aH, 'Status: 0x', 00H		;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT ??_C@_0BG@NNIHHKKC@Record?5Seam?5identity?6?$AA@IMHBAIGO@
EDATA32	SEGMENT
??_C@_0BG@NNIHHKKC@Record?5Seam?5identity?6?$AA@IMHBAIGO@ DB 'Record Seam'
	DB	' identity', 0aH, 00H			;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT ??_C@_0M@KPDHHIMA@Setup?5VMCS?6?$AA@IMHBAIGO@
EDATA32	SEGMENT
??_C@_0M@KPDHHIMA@Setup?5VMCS?6?$AA@IMHBAIGO@ DB 'Setup VMCS', 0aH, 00H ;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT ??_C@_0BG@DLHFFDEJ@Setup?5PSysinfo?5table?6?$AA@IMHBAIGO@
EDATA32	SEGMENT
??_C@_0BG@DLHFFDEJ@Setup?5PSysinfo?5table?6?$AA@IMHBAIGO@ DB 'Setup PSysi'
	DB	'nfo table', 0aH, 00H			;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT ??_C@_0BO@OEPBOPGA@Failed?5to?5map?5Module?5Region?$CB?6?$AA@IMHBAIGO@
EDATA32	SEGMENT
??_C@_0BO@OEPBOPGA@Failed?5to?5map?5Module?5Region?$CB?6?$AA@IMHBAIGO@ DB 'F'
	DB	'ailed to map Module Region!', 0aH, 00H	;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT ??_C@_0BF@FEICECMF@Setup?5Module?5Region?6?$AA@IMHBAIGO@
EDATA32	SEGMENT
??_C@_0BF@FEICECMF@Setup?5Module?5Region?6?$AA@IMHBAIGO@ DB 'Setup Module'
	DB	' Region', 0aH, 00H				;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT ??_C@_0BC@DBKHJAMB@Map?5SysInfoTable?6?$AA@IMHBAIGO@
EDATA32	SEGMENT
??_C@_0BC@DBKHJAMB@Map?5SysInfoTable?6?$AA@IMHBAIGO@ DB 'Map SysInfoTable'
	DB	0aH, 00H					;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT ??_C@_0BN@OICIBGCH@Failed?5to?5setup?5data?5region?6?$AA@IMHBAIGO@
EDATA32	SEGMENT
??_C@_0BN@OICIBGCH@Failed?5to?5setup?5data?5region?6?$AA@IMHBAIGO@ DB 'Fa'
	DB	'iled to setup data region', 0aH, 00H	;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT ??_C@_0BD@KDAKIHP@Setup?5Data?5Region?6?$AA@IMHBAIGO@
EDATA32	SEGMENT
??_C@_0BD@KDAKIHP@Setup?5Data?5Region?6?$AA@IMHBAIGO@ DB 'Setup Data Regi'
	DB	'on', 0aH, 00H				;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT ??_C@_0BK@FBODADJ@Failed?5to?5setup?5keyholes?6?$AA@IMHBAIGO@
EDATA32	SEGMENT
??_C@_0BK@FBODADJ@Failed?5to?5setup?5keyholes?6?$AA@IMHBAIGO@ DB 'Failed '
	DB	'to setup keyholes', 0aH, 00H		;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT ??_C@_0P@MNGGMCMN@Setup?5keyhole?6?$AA@IMHBAIGO@
EDATA32	SEGMENT
??_C@_0P@MNGGMCMN@Setup?5keyhole?6?$AA@IMHBAIGO@ DB 'Setup keyhole', 0aH, 00H ;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT ??_C@_0BI@CDALIHGP@Failed?5to?5setup?5stacks?6?$AA@IMHBAIGO@
EDATA32	SEGMENT
??_C@_0BI@CDALIHGP@Failed?5to?5setup?5stacks?6?$AA@IMHBAIGO@ DB 'Failed t'
	DB	'o setup stacks', 0aH, 00H			;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT ??_C@_0O@NNMOLPJK@Setup?5stacks?6?$AA@IMHBAIGO@
EDATA32	SEGMENT
??_C@_0O@NNMOLPJK@Setup?5stacks?6?$AA@IMHBAIGO@ DB 'Setup stacks', 0aH, 00H ;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT ??_C@_0BM@DDMELFPJ@Failed?5to?5map?5module?5pages?6?$AA@IMHBAIGO@
EDATA32	SEGMENT
??_C@_0BM@DDMELFPJ@Failed?5to?5map?5module?5pages?6?$AA@IMHBAIGO@ DB 'Fai'
	DB	'led to map module pages', 0aH, 00H		;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT ??_C@_0BF@CKNDFINP@Map?5P?9Seamldr?5pages?6?$AA@IMHBAIGO@
EDATA32	SEGMENT
??_C@_0BF@CKNDFINP@Map?5P?9Seamldr?5pages?6?$AA@IMHBAIGO@ DB 'Map P-Seaml'
	DB	'dr pages', 0aH, 00H				;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT ??_C@_0BO@FCLKAN@Failed?5to?5relocate?5P?9Seamldr?6?$AA@IMHBAIGO@
EDATA32	SEGMENT
??_C@_0BO@FCLKAN@Failed?5to?5relocate?5P?9Seamldr?6?$AA@IMHBAIGO@ DB 'Fai'
	DB	'led to relocate P-Seamldr', 0aH, 00H	;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT ??_C@_0BP@KEEGAGND@Loading?5P?9Seamldr?5code?5failed?6?$AA@IMHBAIGO@
EDATA32	SEGMENT
??_C@_0BP@KEEGAGND@Loading?5P?9Seamldr?5code?5failed?6?$AA@IMHBAIGO@ DB 'L'
	DB	'oading P-Seamldr code failed', 0aH, 00H	;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT ??_C@_0BF@LGBACFPP@Load?5?5P?9Seamld?5code?6?$AA@IMHBAIGO@
EDATA32	SEGMENT
??_C@_0BF@LGBACFPP@Load?5?5P?9Seamld?5code?6?$AA@IMHBAIGO@ DB 'Load  P-Se'
	DB	'amld code', 0aH, 00H			;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT ??_C@_0BA@HINKIKFF@SeamRR?5Size?3?50x?$AA@IMHBAIGO@
EDATA32	SEGMENT
??_C@_0BA@HINKIKFF@SeamRR?5Size?3?50x?$AA@IMHBAIGO@ DB 'SeamRR Size: 0x', 00H ;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT ??_C@_0O@FKFJLLIL@SeamRR?5VA?3?50x?$AA@IMHBAIGO@
EDATA32	SEGMENT
??_C@_0O@FKFJLLIL@SeamRR?5VA?3?50x?$AA@IMHBAIGO@ DB 'SeamRR VA: 0x', 00H ;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT ??_C@_0BK@HHJIMKFB@Pseamldr?5Range?5too?5small?6?$AA@IMHBAIGO@
EDATA32	SEGMENT
??_C@_0BK@HHJIMKFB@Pseamldr?5Range?5too?5small?6?$AA@IMHBAIGO@ DB 'Pseaml'
	DB	'dr Range too small', 0aH, 00H		;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT ??_C@_09LMCHEAJO@AslrRand?5?$AA@IMHBAIGO@
EDATA32	SEGMENT
??_C@_09LMCHEAJO@AslrRand?5?$AA@IMHBAIGO@ DB 'AslrRand ', 00H ;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT ??_C@_0P@JKMHMCO@RDSEED?5failed?6?$AA@IMHBAIGO@
EDATA32	SEGMENT
??_C@_0P@JKMHMCO@RDSEED?5failed?6?$AA@IMHBAIGO@ DB 'RDSEED failed', 0aH, 00H ;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT ??_C@_0CM@LIHANEGM@Error?3?5P?5Seamldr?5hasn?8t?5shut?5dow@IMHBAIGO@
EDATA32	SEGMENT
??_C@_0CM@LIHANEGM@Error?3?5P?5Seamldr?5hasn?8t?5shut?5dow@IMHBAIGO@ DB 'E'
	DB	'rror: P Seamldr hasn''t shut down properly', 0aH, 00H ;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT ??_C@_0BD@FOBAGBFE@AcmX2ApicId?5error?6?$AA@IMHBAIGO@
EDATA32	SEGMENT
??_C@_0BD@FOBAGBFE@AcmX2ApicId?5error?6?$AA@IMHBAIGO@ DB 'AcmX2ApicId err'
	DB	'or', 0aH, 00H				;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT ??_C@_0CD@JDEDDDDN@SeamldrMutexStatus?5is?5not?5correc@IMHBAIGO@
EDATA32	SEGMENT
??_C@_0CD@JDEDDDDN@SeamldrMutexStatus?5is?5not?5correc@IMHBAIGO@ DB 'Seam'
	DB	'ldrMutexStatus is not correct', 0aH, 00H	;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT ??_C@_0BH@EKBKOKDP@Acquiring?5SEAMRR?5lock?6?$AA@IMHBAIGO@
EDATA32	SEGMENT
??_C@_0BH@EKBKOKDP@Acquiring?5SEAMRR?5lock?6?$AA@IMHBAIGO@ DB 'Acquiring '
	DB	'SEAMRR lock', 0aH, 00H			;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT ??_C@_0DB@BBEGNBAJ@P_SYS_INFO_TABLE?5version?5mismatc@IMHBAIGO@
EDATA32	SEGMENT
??_C@_0DB@BBEGNBAJ@P_SYS_INFO_TABLE?5version?5mismatc@IMHBAIGO@ DB 'P_SYS'
	DB	'_INFO_TABLE version mismatch, got version ', 0aH, 00H ;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT ??_C@_0BO@INKHCOGJ@Socket?5CPUID?5table?5not?5valid?6?$AA@IMHBAIGO@
EDATA32	SEGMENT
??_C@_0BO@INKHCOGJ@Socket?5CPUID?5table?5not?5valid?6?$AA@IMHBAIGO@ DB 'S'
	DB	'ocket CPUID table not valid', 0aH, 00H	;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT ??_C@_0BN@EABEMNCL@Invalid?5number?5of?5sockets?3?5?6?$AA@IMHBAIGO@
EDATA32	SEGMENT
??_C@_0BN@EABEMNCL@Invalid?5number?5of?5sockets?3?5?6?$AA@IMHBAIGO@ DB 'I'
	DB	'nvalid number of sockets: ', 0aH, 00H	;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT ??_C@_0DM@ILANBIGJ@Can?8t?5map?5the?5SEAMRR?5region?0?5not@IMHBAIGO@
EDATA32	SEGMENT
??_C@_0DM@ILANBIGJ@Can?8t?5map?5the?5SEAMRR?5region?0?5not@IMHBAIGO@ DB 'C'
	DB	'an''t map the SEAMRR region, not enough page table entries', 0aH
	DB	00H						;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT ??_C@_0BH@KNKIAGPB@Seamrr?5range?5too?5big?3?5?$AA@IMHBAIGO@
EDATA32	SEGMENT
??_C@_0BH@KNKIAGPB@Seamrr?5range?5too?5big?3?5?$AA@IMHBAIGO@ DB 'Seamrr r'
	DB	'ange too big: ', 00H			;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT ??_C@_0DM@IAMDNGHM@Can?8t?5map?5the?5Sysinfo?5table?0?5not@IMHBAIGO@
EDATA32	SEGMENT
??_C@_0DM@IAMDNGHM@Can?8t?5map?5the?5Sysinfo?5table?0?5not@IMHBAIGO@ DB 'C'
	DB	'an''t map the Sysinfo table, not enough page table entries', 0aH
	DB	00H						;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT ??_C@_0CN@JLDAHCCF@SeamldrData?4PSeamldrConsts?9?$DOCDat@IMHBAIGO@
EDATA32	SEGMENT
??_C@_0CN@JLDAHCCF@SeamldrData?4PSeamldrConsts?9?$DOCDat@IMHBAIGO@ DB 'Se'
	DB	'amldrData.PSeamldrConsts->CDataRgnSize: 0x', 00H ;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT ??_C@_0CP@HJNGJCGG@SeamldrData?4PSeamldrConsts?9?$DOCDat@IMHBAIGO@
EDATA32	SEGMENT
??_C@_0CP@HJNGJCGG@SeamldrData?4PSeamldrConsts?9?$DOCDat@IMHBAIGO@ DB 'Se'
	DB	'amldrData.PSeamldrConsts->CDataStackSize: 0x', 00H ;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT ??_C@_0CN@CNLBMENP@SeamldrData?4PSeamldrConsts?9?$DOCCod@IMHBAIGO@
EDATA32	SEGMENT
??_C@_0CN@CNLBMENP@SeamldrData?4PSeamldrConsts?9?$DOCCod@IMHBAIGO@ DB 'Se'
	DB	'amldrData.PSeamldrConsts->CCodeRgnSize: 0x', 00H ;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT ??_C@_0DB@CIEFJNBN@SeamldrData?4SysInfoTable?9?$DOPSeaml@IMHBAIGO@
EDATA32	SEGMENT
??_C@_0DB@CIEFJNBN@SeamldrData?4SysInfoTable?9?$DOPSeaml@IMHBAIGO@ DB 'Se'
	DB	'amldrData.SysInfoTable->PSeamldrRange.Size: 0x', 00H ;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT ??_C@_0CH@NMPGKIPA@Mapped?5PSysInfoTable?5to?5virtual?5@IMHBAIGO@
EDATA32	SEGMENT
??_C@_0CH@NMPGKIPA@Mapped?5PSysInfoTable?5to?5virtual?5@IMHBAIGO@ DB 'Map'
	DB	'ped PSysInfoTable to virtual addr: ', 00H	;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT ??_C@_0BH@MBPLKHLD@Writing?5seamrr?5mask?5?9?5?$AA@IMHBAIGO@
EDATA32	SEGMENT
??_C@_0BH@MBPLKHLD@Writing?5seamrr?5mask?5?9?5?$AA@IMHBAIGO@ DB 'Writing '
	DB	'seamrr mask - ', 00H			;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT ??_C@_0O@GKEDAJFE@Seamrr?5size?3?5?$AA@IMHBAIGO@
EDATA32	SEGMENT
??_C@_0O@GKEDAJFE@Seamrr?5size?3?5?$AA@IMHBAIGO@ DB 'Seamrr size: ', 00H ;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT ??_C@_0BH@EEOILHJA@Seamrr?5mask?5not?5valid?6?$AA@IMHBAIGO@
EDATA32	SEGMENT
??_C@_0BH@EEOILHJA@Seamrr?5mask?5not?5valid?6?$AA@IMHBAIGO@ DB 'Seamrr ma'
	DB	'sk not valid', 0aH, 00H			;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT ??_C@_0BC@IPADEDPJ@SEAMRR_MASK_MSR?3?5?$AA@IMHBAIGO@
EDATA32	SEGMENT
??_C@_0BC@IPADEDPJ@SEAMRR_MASK_MSR?3?5?$AA@IMHBAIGO@ DB 'SEAMRR_MASK_MSR:'
	DB	' ', 00H					;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT ??_C@_0BC@JHBKFAN@SEAMRR_BASE_MSR?3?5?$AA@IMHBAIGO@
EDATA32	SEGMENT
??_C@_0BC@JHBKFAN@SEAMRR_BASE_MSR?3?5?$AA@IMHBAIGO@ DB 'SEAMRR_BASE_MSR: '
	DB	00H						;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@IMHBAIGO@
EDATA32	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@IMHBAIGO@ DB 0aH, 00H		;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT ??_C@_0BL@PDBNDKDJ@MaximumSupportMemAddress?3?5?$AA@IMHBAIGO@
EDATA32	SEGMENT
??_C@_0BL@PDBNDKDJ@MaximumSupportMemAddress?3?5?$AA@IMHBAIGO@ DB 'Maximum'
	DB	'SupportMemAddress: ', 00H			;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT ??_C@_0M@DFPCGKIO@SeamldrAcm?6?$AA@IMHBAIGO@
EDATA32	SEGMENT
??_C@_0M@DFPCGKIO@SeamldrAcm?6?$AA@IMHBAIGO@ DB 'SeamldrAcm', 0aH, 00H ;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT ??_C@_0BO@JDKLNIGF@Failed?5to?5map?5sysinfo?5table?$CB?6?$AA@IMHBAIGO@
EDATA32	SEGMENT
??_C@_0BO@JDKLNIGF@Failed?5to?5map?5sysinfo?5table?$CB?6?$AA@IMHBAIGO@ DB 'F'
	DB	'ailed to map sysinfo table!', 0aH, 00H	;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$SeamldrAcm DD 0d2d01H
	DD	03c741fH
	DD	03b641fH
	DD	03a341fH
	DD	034011fH
	DD	0e016f018H
	DD	0c012d014H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$RecordSeamIdentity DD 031801H
	DD	0440109H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$SetupSysInfoTable DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$MapModuleRegion DD 0c1d01H
	DD	0d741dH
	DD	0c641dH
	DD	0b541dH
	DD	0a341dH
	DD	0f019521dH
	DD	0d015e017H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$MapSysInfoTables DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$SetupDataRegion DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$SetupKeyholeMapping DD 0a1801H
	DD	0c6418H
	DD	0b5418H
	DD	0a3418H
	DD	0f0145218H
	DD	07010e012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$SetupStacks DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$MapModulePages DD 0a1901H
	DD	0b7419H
	DD	0a6419H
	DD	095419H
	DD	083419H
	DD	0e0155219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GetX2ApicId DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$MemZeroWithMovdir64B DD 091f01H
	DD	0187417H
	DD	0176417H
	DD	0163417H
	DD	0140117H
	DD	05010H
xdata	ENDS
; Function compile flags: /Ogsp
; File c:\users\jwhur\downloads\seam-loader\seam-loader-main-1.5\np-seam-loader\seamldr_src\core\commonseamldr64\seamldrcore64.c
;	COMDAT SeamldrAcm
_TEXT	SEGMENT
OriginalBIOSID$1$ = 0
Rrrr$ = 8
BitScanIdx$ = 32
ia32_misc_enable_org$1$ = 40
CpuInfo$1 = 40
CPagingStructSize$1$ = 56
SeamrrPtCtx$ = 64
pCom64$ = 464
PtCtx$ = 472
SeamldrAcm PROC						; COMDAT

; 236  : void SeamldrAcm(SEAMLDR_COM64_DATA *pCom64, PT_CTX* PtCtx) {

$LN56:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 70 10	 mov	 QWORD PTR [rax+16], rsi
  0000b	48 89 78 18	 mov	 QWORD PTR [rax+24], rdi
  0000f	55		 push	 rbp
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 81 ec a0 01
	00 00		 sub	 rsp, 416		; 000001a0H
  0001f	48 8d a8 68 ff
	ff ff		 lea	 rbp, QWORD PTR [rax-152]
  00026	48 81 e5 00 ff
	ff ff		 and	 rbp, -256		; ffffffffffffff00H
  0002d	4c 8b e9	 mov	 r13, rcx
  00030	48 8b f2	 mov	 rsi, rdx

; 237  :     SEAMRR_PT_CTX SeamrrPtCtx;
; 238  :     UINT16 Rrrr;
; 239  :     UINT8  Comparand = NP_SEAMLDR_MUTEX_CLEAR;
; 240  :     UINT8  SeamldrMutexStatus;
; 241  :     UINT64 Status = NP_SEAMLDR_PARAMS_STATUS_SUCCESS;
; 242  : 	BOOL MutexAcquired = FALSE;
; 243  :     BOOL SEAMRRUnlocked = FALSE;
; 244  :     UINT64 CPagingStructSize;
; 245  :     UINT64 OriginalBIOSID;
; 246  :     UINT64 ia32_misc_enable_org;
; 247  :     SeamrrBase_u     SeamrrBaseMsr;
; 248  :     SeamrrMask_u     SeamrrMaskMsr;
; 249  :     UINT32 BitScanRes, BitScanIdx;
; 250  : 
; 251  : 
; 252  :     COMSERIALOUT("SeamldrAcm\n");

  00033	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@DFPCGKIO@SeamldrAcm?6?$AA@IMHBAIGO@
  0003a	45 32 e4	 xor	 r12b, r12b
  0003d	45 32 ff	 xor	 r15b, r15b
  00040	e8 00 00 00 00	 call	 ComSerialOut

; 253  :     SIMICS_BREAKPOINT;

  00045	33 c9		 xor	 ecx, ecx
  00047	b8 11 47 00 00	 mov	 eax, 18193		; 00004711H
  0004c	0f a2		 cpuid

; 254  :     //     DEBUG ((EFI_D_INFO, ("SeamldrAcm\n Param struct PA: 0x%x", OriginalEDX));
; 255  : 
; 256  :     // SAVE BIOS ID before the first CPUID
; 257  :     OriginalBIOSID = readMsr64(MSR_IA32_BIOS_SIGN_ID);

  0004e	b9 8b 00 00 00	 mov	 ecx, 139		; 0000008bH
  00053	89 45 28	 mov	 DWORD PTR CpuInfo$1[rbp], eax
  00056	89 5d 2c	 mov	 DWORD PTR CpuInfo$1[rbp+4], ebx
  00059	e8 00 00 00 00	 call	 __readMsr64

; 258  : 
; 259  :     ia32_misc_enable_org = readMsr64(MSR_IA32_MISC_ENABLES);

  0005e	bb a0 01 00 00	 mov	 ebx, 416		; 000001a0H
  00063	48 89 45 00	 mov	 QWORD PTR OriginalBIOSID$1$[rbp], rax
  00067	8b cb		 mov	 ecx, ebx
  00069	4c 8b f0	 mov	 r14, rax
  0006c	e8 00 00 00 00	 call	 __readMsr64

; 260  :     writeMsr64(MSR_IA32_MISC_ENABLES, ia32_misc_enable_org & (~(UINT64)IA32_CR_MISC_ENABLES_BOOT_NT4_BIT));

  00071	48 8b d0	 mov	 rdx, rax
  00074	48 89 45 28	 mov	 QWORD PTR ia32_misc_enable_org$1$[rbp], rax
  00078	48 0f ba f2 16	 btr	 rdx, 22
  0007d	8b cb		 mov	 ecx, ebx
  0007f	e8 00 00 00 00	 call	 __writeMsr64

; 261  : 
; 262  : 
; 263  :     // SAVE OS XMM's
; 264  : 
; 265  :     SeamldrData.PhysAddrMask = GetPhyAddrMask();

  00084	e8 00 00 00 00	 call	 GetPhyAddrMask

; 266  :     PRINT_HEX_VAL("MaximumSupportMemAddress: ", SeamldrData.PhysAddrMask);

  00089	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BL@PDBNDKDJ@MaximumSupportMemAddress?3?5?$AA@IMHBAIGO@
  00090	48 89 05 18 00
	00 00		 mov	 QWORD PTR SeamldrData+24, rax
  00097	e8 00 00 00 00	 call	 ComSerialOut
  0009c	48 8b 0d 18 00
	00 00		 mov	 rcx, QWORD PTR SeamldrData+24
  000a3	e8 00 00 00 00	 call	 printHex
  000a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@IMHBAIGO@
  000af	e8 00 00 00 00	 call	 ComSerialOut

; 267  :     SeamldrData.PSeamldrConsts = (P_SEAMLDR_CONSTS_t*)pCom64->PseamldrConstsOffset;

  000b4	49 8b 85 82 00
	00 00		 mov	 rax, QWORD PTR [r13+130]

; 268  : 
; 269  :     SeamrrBaseMsr.raw = readMsr64(MSR_IA32_SEAMRR_BASE);

  000bb	b9 00 14 00 00	 mov	 ecx, 5120		; 00001400H
  000c0	48 89 05 88 01
	00 00		 mov	 QWORD PTR SeamldrData+392, rax
  000c7	e8 00 00 00 00	 call	 __readMsr64

; 270  :     SeamrrMaskMsr.raw = readMsr64(MSR_IA32_SEAMRR_MASK);

  000cc	b9 01 14 00 00	 mov	 ecx, 5121		; 00001401H
  000d1	48 8b d8	 mov	 rbx, rax
  000d4	e8 00 00 00 00	 call	 __readMsr64

; 271  :     //PRINT_HEX_VAL("PSeamldrConsts Location: ", SeamldrData.PSeamldrConsts);
; 272  :     PRINT_HEX_VAL("SEAMRR_BASE_MSR: ", SeamrrBaseMsr.raw);

  000d9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@JHBKFAN@SEAMRR_BASE_MSR?3?5?$AA@IMHBAIGO@
  000e0	48 8b f8	 mov	 rdi, rax
  000e3	e8 00 00 00 00	 call	 ComSerialOut
  000e8	48 8b cb	 mov	 rcx, rbx
  000eb	e8 00 00 00 00	 call	 printHex
  000f0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@IMHBAIGO@
  000f7	e8 00 00 00 00	 call	 ComSerialOut

; 273  :     PRINT_HEX_VAL("SEAMRR_MASK_MSR: ", SeamrrMaskMsr.raw);

  000fc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@IPADEDPJ@SEAMRR_MASK_MSR?3?5?$AA@IMHBAIGO@
  00103	e8 00 00 00 00	 call	 ComSerialOut
  00108	48 8b cf	 mov	 rcx, rdi
  0010b	e8 00 00 00 00	 call	 printHex
  00110	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@IMHBAIGO@
  00117	e8 00 00 00 00	 call	 ComSerialOut

; 274  : 
; 275  :     // Read the IA32_SEAMRR_MASK range register and if the VALID bit is not set in the IA32_SEAMRR_MASK register, then set error code to EBADRANGE
; 276  :     if (SeamrrMaskMsr.valid == 0) {

  0011c	48 0f ba e7 0b	 bt	 rdi, 11
  00121	72 1b		 jb	 SHORT $LN17@SeamldrAcm

; 277  :         COMSERIALOUT("Seamrr mask not valid\n");

  00123	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@EEOILHJA@Seamrr?5mask?5not?5valid?6?$AA@IMHBAIGO@
$LN51@SeamldrAcm:
  0012a	e8 00 00 00 00	 call	 ComSerialOut

; 278  :         Status = NP_SEAMLDR_PARAMS_STATUS_EBADRANGE;

  0012f	48 be 00 00 01
	00 00 00 00 80	 mov	 rsi, -9223372036854710272 ; 8000000000010000H

; 279  :         goto EXIT;

  00139	e9 bc 05 00 00	 jmp	 $EXIT$57
$LN17@SeamldrAcm:

; 280  :     }
; 281  : 
; 282  : 
; 283  :     // Start of SEAMLDR 64-bit code:
; 284  : 
; 285  :     SeamldrData.SeamrrBase = (SeamrrBaseMsr.raw & B_SEAMRR_BASE);

  0013e	48 c7 c0 00 00
	00 fe		 mov	 rax, -33554432		; fffffffffe000000H

; 286  : //    SeamldrData.SeamrrSize = ~(shiftLeft64(SeamrrMaskMsr.mask, N_SEAMRR_MASK_MASK) | SeamldrData.TdxPrivateKidMask | (~SeamldrData.MaximumSupportMemAddress)) + 1;
; 287  :     SeamldrData.SeamrrSize = 0;
; 288  :     BitScanRes = BitScanForward64(&BitScanIdx, (SeamrrMaskMsr.raw & B_SEAMRR_MASK));

  00145	48 8d 4d 20	 lea	 rcx, QWORD PTR BitScanIdx$[rbp]
  00149	48 23 d8	 and	 rbx, rax
  0014c	48 8b d7	 mov	 rdx, rdi
  0014f	48 89 1d 38 00
	00 00		 mov	 QWORD PTR SeamldrData+56, rbx
  00156	48 23 d0	 and	 rdx, rax
  00159	33 db		 xor	 ebx, ebx
  0015b	48 89 1d 40 00
	00 00		 mov	 QWORD PTR SeamldrData+64, rbx
  00162	e8 00 00 00 00	 call	 BitScanForward64

; 289  :     if (BitScanRes != 0) {

  00167	44 8d 7b 01	 lea	 r15d, QWORD PTR [rbx+1]
  0016b	85 c0		 test	 eax, eax
  0016d	74 12		 je	 SHORT $LN18@SeamldrAcm

; 290  :         SeamldrData.SeamrrSize = shiftLeft64(1, BitScanIdx);

  0016f	8b 55 20	 mov	 edx, DWORD PTR BitScanIdx$[rbp]
  00172	41 8b cf	 mov	 ecx, r15d
  00175	e8 00 00 00 00	 call	 shiftLeft64
  0017a	48 89 05 40 00
	00 00		 mov	 QWORD PTR SeamldrData+64, rax
$LN18@SeamldrAcm:

; 291  :     }
; 292  : 
; 293  :     PRINT_HEX_VAL("Seamrr size: ", SeamldrData.SeamrrSize);

  00181	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@GKEDAJFE@Seamrr?5size?3?5?$AA@IMHBAIGO@
  00188	e8 00 00 00 00	 call	 ComSerialOut
  0018d	48 8b 0d 40 00
	00 00		 mov	 rcx, QWORD PTR SeamldrData+64
  00194	e8 00 00 00 00	 call	 printHex
  00199	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@IMHBAIGO@
  001a0	e8 00 00 00 00	 call	 ComSerialOut

; 294  : 
; 295  : #ifdef _SEAMRR_MASK_WA_
; 296  :     // The SEAMLDR now needs to unlock the SEAMRR range so that it can read and write the memory contents of this range. 
; 297  :     // The SEAMLDR does that by clearing the VALID bit in the IA32_SEAMRR_MASK register. 
; 298  :     
; 299  :     // SEAM range unlocking:
; 300  :     writeMsr64(MSR_BIOS_DONE, BiosDone & ~0x1); // clear the ENABLE_IA_UNTRUSTED bit (0)
; 301  :     COMSERIALOUT("Cleared BIOS_DONE\n");
; 302  :     SeamldrData.SeamrrMask.raw &= ~SeamldrData.TdxPrivateKidMask;
; 303  : #endif
; 304  :     SeamrrMaskMsr.valid = 0;
; 305  : 
; 306  :     PRINT_HEX_VAL("Writing seamrr mask - ", SeamrrMaskMsr.raw);

  001a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@MBPLKHLD@Writing?5seamrr?5mask?5?9?5?$AA@IMHBAIGO@
  001ac	48 0f ba f7 0b	 btr	 rdi, 11
  001b1	e8 00 00 00 00	 call	 ComSerialOut
  001b6	48 8b cf	 mov	 rcx, rdi
  001b9	e8 00 00 00 00	 call	 printHex
  001be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@IMHBAIGO@
  001c5	e8 00 00 00 00	 call	 ComSerialOut

; 307  :     writeMsr64(MSR_IA32_SEAMRR_MASK, SeamrrMaskMsr.raw);

  001ca	48 8b d7	 mov	 rdx, rdi
  001cd	b9 01 14 00 00	 mov	 ecx, 5121		; 00001401H
  001d2	e8 00 00 00 00	 call	 __writeMsr64

; 308  : 
; 309  : 	// If the SEAMRR is successfully unlocked, then set the SEAMRR_UNLOCKED flag to 1.
; 310  : 	SEAMRRUnlocked = TRUE;
; 311  : 
; 312  :     // Map the SysInfoTable as a single 4KB page with UC memtype
; 313  :     SeamldrData.PSysInfoTable = (P_SYS_INFO_TABLE_t*)MapPhysicalRange(PtCtx, SeamldrData.SeamrrBase + SeamldrData.SeamrrSize - PAGE4K, PAGE4K, PAGE_WRITABLE, PAGE_4K, PAGE_UC_MEMTYPE);

  001d7	48 8b 05 40 00
	00 00		 mov	 rax, QWORD PTR SeamldrData+64
  001de	45 8b cf	 mov	 r9d, r15d
  001e1	48 8b 15 38 00
	00 00		 mov	 rdx, QWORD PTR SeamldrData+56
  001e8	48 05 00 f0 ff
	ff		 add	 rax, -4096		; fffffffffffff000H
  001ee	48 03 d0	 add	 rdx, rax
  001f1	89 5c 24 28	 mov	 DWORD PTR [rsp+40], ebx
  001f5	41 b8 00 10 00
	00		 mov	 r8d, 4096		; 00001000H
  001fb	89 5c 24 20	 mov	 DWORD PTR [rsp+32], ebx
  001ff	48 8b ce	 mov	 rcx, rsi
  00202	e8 00 00 00 00	 call	 MapPhysicalRange

; 314  : 
; 315  :     PRINT_HEX_VAL("Mapped PSysInfoTable to virtual addr: ", (UINT64)SeamldrData.PSysInfoTable);

  00207	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CH@NMPGKIPA@Mapped?5PSysInfoTable?5to?5virtual?5@IMHBAIGO@
  0020e	48 89 05 48 00
	00 00		 mov	 QWORD PTR SeamldrData+72, rax
  00215	e8 00 00 00 00	 call	 ComSerialOut
  0021a	48 8b 0d 48 00
	00 00		 mov	 rcx, QWORD PTR SeamldrData+72
  00221	e8 00 00 00 00	 call	 printHex
  00226	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@IMHBAIGO@
  0022d	e8 00 00 00 00	 call	 ComSerialOut

; 316  :     PRINT_HEX_VAL("SeamldrData.SysInfoTable->PSeamldrRange.Size: 0x", SeamldrData.PSysInfoTable->PSeamldrRange.Size);

  00232	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DB@CIEFJNBN@SeamldrData?4SysInfoTable?9?$DOPSeaml@IMHBAIGO@
  00239	e8 00 00 00 00	 call	 ComSerialOut
  0023e	48 8b 0d 48 00
	00 00		 mov	 rcx, QWORD PTR SeamldrData+72
  00245	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  00249	e8 00 00 00 00	 call	 printHex
  0024e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@IMHBAIGO@
  00255	e8 00 00 00 00	 call	 ComSerialOut

; 317  :     PRINT_HEX_VAL("SeamldrData.PSeamldrConsts->CCodeRgnSize: 0x", SeamldrData.PSeamldrConsts->CCodeRgnSize);

  0025a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CN@CNLBMENP@SeamldrData?4PSeamldrConsts?9?$DOCCod@IMHBAIGO@
  00261	e8 00 00 00 00	 call	 ComSerialOut
  00266	48 8b 0d 88 01
	00 00		 mov	 rcx, QWORD PTR SeamldrData+392
  0026d	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00271	e8 00 00 00 00	 call	 printHex
  00276	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@IMHBAIGO@
  0027d	e8 00 00 00 00	 call	 ComSerialOut

; 318  :     PRINT_HEX_VAL("SeamldrData.PSeamldrConsts->CDataStackSize: 0x", SeamldrData.PSeamldrConsts->CDataStackSize);

  00282	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CP@HJNGJCGG@SeamldrData?4PSeamldrConsts?9?$DOCDat@IMHBAIGO@
  00289	e8 00 00 00 00	 call	 ComSerialOut
  0028e	48 8b 0d 88 01
	00 00		 mov	 rcx, QWORD PTR SeamldrData+392
  00295	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00298	e8 00 00 00 00	 call	 printHex
  0029d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@IMHBAIGO@
  002a4	e8 00 00 00 00	 call	 ComSerialOut

; 319  :     PRINT_HEX_VAL("SeamldrData.PSeamldrConsts->CDataRgnSize: 0x", SeamldrData.PSeamldrConsts->CDataRgnSize);

  002a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CN@JLDAHCCF@SeamldrData?4PSeamldrConsts?9?$DOCDat@IMHBAIGO@
  002b0	e8 00 00 00 00	 call	 ComSerialOut
  002b5	48 8b 0d 88 01
	00 00		 mov	 rcx, QWORD PTR SeamldrData+392
  002bc	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  002c0	e8 00 00 00 00	 call	 printHex
  002c5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@IMHBAIGO@
  002cc	e8 00 00 00 00	 call	 ComSerialOut

; 320  :     //PRINT_HEX_VAL("pCom64: ", pCom64);
; 321  :     //for (UINT32 i = 0; i < sizeof(SEAMLDR_COM64_DATA)/8; i++) {
; 322  :     //    PRINT_HEX_VAL("pCom64 data: ", *((UINT64*)pCom64 + i));
; 323  :     //}
; 324  : 
; 325  :     if ((UINT64)SeamldrData.PSysInfoTable == BAD_MAPPING) {

  002d1	48 83 3d 48 00
	00 00 ff	 cmp	 QWORD PTR SeamldrData+72, -1
  002d9	75 1b		 jne	 SHORT $LN19@SeamldrAcm

; 326  :         COMSERIALOUT("Can't map the Sysinfo table, not enough page table entries\n");

  002db	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DM@IAMDNGHM@Can?8t?5map?5the?5Sysinfo?5table?0?5not@IMHBAIGO@
$LN52@SeamldrAcm:
  002e2	e8 00 00 00 00	 call	 ComSerialOut

; 327  :         Status = NP_SEAMLDR_PARAMS_STATUS_ENOMEM;

  002e7	48 be 02 00 01
	00 00 00 00 80	 mov	 rsi, -9223372036854710270 ; 8000000000010002H

; 328  :         goto EXIT;

  002f1	e9 04 04 00 00	 jmp	 $EXIT$57
$LN19@SeamldrAcm:

; 329  :     }
; 330  : 
; 331  :     // Verify that all sockets in the platform have identical family and model numbers by comparing bits 31:4 of first entry 
; 332  :     // in SYS_INFO_TABLE.SOCKET_CPUID_TABLE to all valid entries in the table.
; 333  :     // The stepping numbers can be different.If this check fails then set error code to EBADPLATF
; 334  : 
; 335  :     // System info table is in the first 4k of the SEAMRR
; 336  :     
; 337  :     if (SeamldrData.SeamrrSize > _1GB) {

  002f6	4c 8b 05 40 00
	00 00		 mov	 r8, QWORD PTR SeamldrData+64
  002fd	49 81 f8 00 00
	00 40		 cmp	 r8, 1073741824		; 40000000H
  00304	76 24		 jbe	 SHORT $LN20@SeamldrAcm

; 338  :         PRINT_HEX_VAL("Seamrr range too big: ", SeamldrData.SeamrrSize);

  00306	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@KNKIAGPB@Seamrr?5range?5too?5big?3?5?$AA@IMHBAIGO@
  0030d	e8 00 00 00 00	 call	 ComSerialOut
  00312	48 8b 0d 40 00
	00 00		 mov	 rcx, QWORD PTR SeamldrData+64
  00319	e8 00 00 00 00	 call	 printHex
  0031e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@IMHBAIGO@

; 339  :         Status = NP_SEAMLDR_PARAMS_STATUS_EBADRANGE;
; 340  :         goto EXIT;

  00325	e9 00 fe ff ff	 jmp	 $LN51@SeamldrAcm
$LN20@SeamldrAcm:

; 341  :     }
; 342  : 
; 343  :     // Map the SEAMRR with 2MB pages
; 344  :     SeamldrData.SeamrrVa = MapPhysicalRange(PtCtx, SeamldrData.SeamrrBase, SeamldrData.SeamrrSize, PAGE_WRITABLE, PAGE_2M, PAGE_WB_MEMTYPE);

  0032a	48 8b 15 38 00
	00 00		 mov	 rdx, QWORD PTR SeamldrData+56
  00331	45 8b cf	 mov	 r9d, r15d
  00334	44 89 7c 24 28	 mov	 DWORD PTR [rsp+40], r15d
  00339	48 8b ce	 mov	 rcx, rsi
  0033c	44 89 7c 24 20	 mov	 DWORD PTR [rsp+32], r15d
  00341	e8 00 00 00 00	 call	 MapPhysicalRange
  00346	48 89 05 00 00
	00 00		 mov	 QWORD PTR SeamldrData, rax
  0034d	48 8b c8	 mov	 rcx, rax

; 345  : 
; 346  :     if (SeamldrData.SeamrrVa == BAD_MAPPING) {

  00350	48 83 f8 ff	 cmp	 rax, -1
  00354	75 09		 jne	 SHORT $LN21@SeamldrAcm

; 347  :         COMSERIALOUT("Can't map the SEAMRR region, not enough page table entries\n");

  00356	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DM@ILANBIGJ@Can?8t?5map?5the?5SEAMRR?5region?0?5not@IMHBAIGO@

; 348  :         Status = NP_SEAMLDR_PARAMS_STATUS_ENOMEM;
; 349  :         goto EXIT;

  0035d	eb 83		 jmp	 SHORT $LN52@SeamldrAcm
$LN21@SeamldrAcm:

; 350  :     }
; 351  :     //    DEBUG ((EFI_D_INFO, "Seamrr VA: 0x%llx", SeamldrData.SeamrrVa));
; 352  :     SeamldrData.SeamrrVaLimit = SeamldrData.SeamrrVa + SeamldrData.SeamrrSize;

  0035f	48 03 0d 40 00
	00 00		 add	 rcx, QWORD PTR SeamldrData+64

; 353  : 
; 354  :     if ((SeamldrData.PSysInfoTable->TotNumSockets > SYS_INFO_TABLE_SOCKET_CPUID_TABLE_SIZE) ||

  00366	48 8b 1d 48 00
	00 00		 mov	 rbx, QWORD PTR SeamldrData+72
  0036d	48 89 0d 08 00
	00 00		 mov	 QWORD PTR SeamldrData+8, rcx
  00374	44 8b 43 0c	 mov	 r8d, DWORD PTR [rbx+12]
  00378	41 8d 40 ff	 lea	 eax, DWORD PTR [r8-1]
  0037c	83 f8 07	 cmp	 eax, 7
  0037f	0f 87 a4 06 00
	00		 ja	 $LN23@SeamldrAcm

; 358  :         goto EXIT;
; 359  :     }
; 360  : 
; 361  :     for (UINT8 Idx = 1; Idx < SeamldrData.PSysInfoTable->TotNumSockets; Idx++) {

  00385	41 8a d7	 mov	 dl, r15b
  00388	45 3b c7	 cmp	 r8d, r15d
  0038b	76 27		 jbe	 SHORT $LN6@SeamldrAcm
  0038d	44 8b 4b 10	 mov	 r9d, DWORD PTR [rbx+16]
  00391	41 ba f0 ff ff
	ff		 mov	 r10d, -16		; fffffff0H
  00397	45 23 ca	 and	 r9d, r10d
$LL7@SeamldrAcm:

; 362  :         if ((SeamldrData.PSysInfoTable->SocketCpuidTable[0] & CPUID_FM_MASK) != (SeamldrData.PSysInfoTable->SocketCpuidTable[Idx] & CPUID_FM_MASK)) {

  0039a	0f b6 c2	 movzx	 eax, dl
  0039d	8b 4c 83 10	 mov	 ecx, DWORD PTR [rbx+rax*4+16]
  003a1	41 23 ca	 and	 ecx, r10d
  003a4	44 3b c9	 cmp	 r9d, ecx
  003a7	75 36		 jne	 SHORT $LN44@SeamldrAcm

; 358  :         goto EXIT;
; 359  :     }
; 360  : 
; 361  :     for (UINT8 Idx = 1; Idx < SeamldrData.PSysInfoTable->TotNumSockets; Idx++) {

  003a9	41 02 d7	 add	 dl, r15b
  003ac	0f b6 c2	 movzx	 eax, dl
  003af	41 3b c0	 cmp	 eax, r8d
  003b2	72 e6		 jb	 SHORT $LL7@SeamldrAcm
$LN6@SeamldrAcm:

; 366  :         }
; 367  :     }
; 368  : 
; 369  :     if (SeamldrData.PSysInfoTable->Version != P_SYS_INFO_TABLE_VERSION) {

  003b4	33 f6		 xor	 esi, esi
  003b6	48 39 33	 cmp	 QWORD PTR [rbx], rsi
  003b9	74 3f		 je	 SHORT $LN25@SeamldrAcm

; 370  :         PRINT_HEX_VAL("P_SYS_INFO_TABLE version mismatch, got version \n", SeamldrData.PSysInfoTable->Version);

  003bb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DB@BBEGNBAJ@P_SYS_INFO_TABLE?5version?5mismatc@IMHBAIGO@
  003c2	e8 00 00 00 00	 call	 ComSerialOut
  003c7	48 8b 0d 48 00
	00 00		 mov	 rcx, QWORD PTR SeamldrData+72
  003ce	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  003d1	e8 00 00 00 00	 call	 printHex
  003d6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@IMHBAIGO@

; 371  :         Status = NP_SEAMLDR_PARAMS_STATUS_EBADPLATF;
; 372  :         goto EXIT;

  003dd	eb 07		 jmp	 SHORT $LN53@SeamldrAcm
$LN44@SeamldrAcm:

; 363  :             COMSERIALOUT("Socket CPUID table not valid\n");

  003df	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BO@INKHCOGJ@Socket?5CPUID?5table?5not?5valid?6?$AA@IMHBAIGO@
$LN53@SeamldrAcm:
  003e6	e8 00 00 00 00	 call	 ComSerialOut

; 364  :             Status = NP_SEAMLDR_PARAMS_STATUS_EBADPLATF;

  003eb	48 be 01 00 01
	00 00 00 00 80	 mov	 rsi, -9223372036854710271 ; 8000000000010001H

; 365  :             goto EXIT;

  003f5	e9 00 03 00 00	 jmp	 $EXIT$57
$LN25@SeamldrAcm:

; 373  :     }
; 374  : 
; 375  : 
; 376  :     COMSERIALOUT("Acquiring SEAMRR lock\n");

  003fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@EKBKOKDP@Acquiring?5SEAMRR?5lock?6?$AA@IMHBAIGO@
  00401	e8 00 00 00 00	 call	 ComSerialOut

; 377  : 
; 378  :     // Acquire exclusive access to the SEAMRR by atomically setting the NP_SEAMLDR_MUTEX of the SYS_INFO_TABLE 
; 379  :     // in the SEAMRR using a locked CMPXCHG8B 
; 380  :     SeamldrMutexStatus = InterlockedCompareExchange8((volatile INT8 *)&SeamldrData.PSysInfoTable->NpSeamldrMutex, NP_SEAMLDR_MUTEX_ACQUIRED, Comparand);

  00406	48 8b 0d 48 00
	00 00		 mov	 rcx, QWORD PTR SeamldrData+72
  0040d	45 33 c0	 xor	 r8d, r8d
  00410	48 81 c1 00 08
	00 00		 add	 rcx, 2048		; 00000800H
  00417	41 8a d7	 mov	 dl, r15b
  0041a	e8 00 00 00 00	 call	 InterlockedCompareExchange8

; 381  :     if (SeamldrMutexStatus != Comparand) {

  0041f	84 c0		 test	 al, al
  00421	74 1b		 je	 SHORT $LN26@SeamldrAcm

; 382  :         COMSERIALOUT("SeamldrMutexStatus is not correct\n");

  00423	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CD@JDEDDDDN@SeamldrMutexStatus?5is?5not?5correc@IMHBAIGO@
  0042a	e8 00 00 00 00	 call	 ComSerialOut

; 383  :         Status = NP_SEAMLDR_PARAMS_STATUS_ELDRINPROG;

  0042f	48 be 02 00 00
	00 00 00 00 80	 mov	 rsi, -9223372036854775806 ; 8000000000000002H

; 384  :         goto EXIT;

  00439	e9 bc 02 00 00	 jmp	 $EXIT$57
$LN26@SeamldrAcm:

; 385  :     }
; 386  : 
; 387  : 	// If the compare succeeds, then the SeamldrMutexStatus moves to LOAD_IN_PROGRESS and set a flag - SET_LOAD_IN_PROGRESS to 1 - 
; 388  : 	// to indicate that this instance of the SEAMLDR moved the SeamldrMutexStatus field to LOAD_IN_PROGRESS.
; 389  : 	MutexAcquired = TRUE;
; 390  : 
; 391  :     if ((SeamldrData.PSysInfoTable->AcmX2ApicIdValid == SYS_INFO_TABLE_X2APICID_VALID) && (SeamldrData.PSysInfoTable->AcmX2ApicId != GetX2ApicId())) {

  0043e	48 8b 05 48 00
	00 00		 mov	 rax, QWORD PTR SeamldrData+72
  00445	45 8a e7	 mov	 r12b, r15b
  00448	44 39 b8 64 08
	00 00		 cmp	 DWORD PTR [rax+2148], r15d
  0044f	75 31		 jne	 SHORT $LN27@SeamldrAcm
  00451	e8 00 00 00 00	 call	 GetX2ApicId
  00456	8b c8		 mov	 ecx, eax
  00458	48 8b 05 48 00
	00 00		 mov	 rax, QWORD PTR SeamldrData+72
  0045f	39 88 60 08 00
	00		 cmp	 DWORD PTR [rax+2144], ecx
  00465	74 1b		 je	 SHORT $LN27@SeamldrAcm

; 392  :         COMSERIALOUT("AcmX2ApicId error\n");

  00467	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@FOBAGBFE@AcmX2ApicId?5error?6?$AA@IMHBAIGO@
$LN54@SeamldrAcm:
  0046e	e8 00 00 00 00	 call	 ComSerialOut

; 393  :         Status = NP_SEAMLDR_PARAMS_STATUS_EMODBUSY;

  00473	48 be 01 00 00
	00 00 00 00 80	 mov	 rsi, -9223372036854775807 ; 8000000000000001H

; 394  :         goto EXIT;

  0047d	e9 78 02 00 00	 jmp	 $EXIT$57
$LN27@SeamldrAcm:

; 395  :     }
; 396  : 
; 397  :     ReadSeamExtendMsr((UINT64) &SeamldrData.SeamExtend);

  00482	48 8d 0d 00 01
	00 00		 lea	 rcx, OFFSET FLAT:SeamldrData+256
  00489	e8 00 00 00 00	 call	 ReadSeamExtendMsr

; 398  :     if ((SeamldrData.SeamExtend.PSeamldrReady != 0) || (SeamldrData.SeamExtend.SeamReady != 0)) {

  0048e	40 38 35 82 01
	00 00		 cmp	 BYTE PTR SeamldrData+386, sil
  00495	0f 85 82 05 00
	00		 jne	 $LN29@SeamldrAcm
  0049b	40 38 35 80 01
	00 00		 cmp	 BYTE PTR SeamldrData+384, sil
  004a2	0f 85 75 05 00
	00		 jne	 $LN29@SeamldrAcm

; 402  :     }
; 403  :     
; 404  :     if (!RdSeed16(&Rrrr)) {

  004a8	48 8d 4d 08	 lea	 rcx, QWORD PTR Rrrr$[rbp]
  004ac	e8 00 00 00 00	 call	 RdSeed16
  004b1	85 c0		 test	 eax, eax
  004b3	75 1b		 jne	 SHORT $LN30@SeamldrAcm

; 405  :         Status = NP_SEAMLDR_PARAMS_STATUS_EUNSPECERR;
; 406  :         COMSERIALOUT("RDSEED failed\n");

  004b5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@JKMHMCO@RDSEED?5failed?6?$AA@IMHBAIGO@
  004bc	48 be 03 00 01
	00 00 00 00 80	 mov	 rsi, -9223372036854710269 ; 8000000000010003H
  004c6	e8 00 00 00 00	 call	 ComSerialOut

; 407  :         goto EXIT;

  004cb	e9 2a 02 00 00	 jmp	 $EXIT$57
$LN30@SeamldrAcm:

; 408  :     }
; 409  : 
; 410  :     SeamldrData.AslrRand = (((UINT64)(Rrrr & ASLR_MASK)) << 32);

  004d0	0f b7 45 08	 movzx	 eax, WORD PTR Rrrr$[rbp]

; 411  :     PRINT_HEX_VAL("AslrRand ", SeamldrData.AslrRand);

  004d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09LMCHEAJO@AslrRand?5?$AA@IMHBAIGO@
  004db	25 fc 7f 00 00	 and	 eax, 32764		; 00007ffcH
  004e0	48 c1 e0 20	 shl	 rax, 32			; 00000020H
  004e4	48 89 05 10 00
	00 00		 mov	 QWORD PTR SeamldrData+16, rax
  004eb	e8 00 00 00 00	 call	 ComSerialOut
  004f0	48 8b 0d 10 00
	00 00		 mov	 rcx, QWORD PTR SeamldrData+16
  004f7	e8 00 00 00 00	 call	 printHex
  004fc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@IMHBAIGO@
  00503	e8 00 00 00 00	 call	 ComSerialOut

; 412  : #if (defined(BULLSEYE_BUILD) && (BULLSEYE_BUILD==1))
; 413  :     SeamldrData.AslrRand = 0;
; 414  : #endif
; 415  : 
; 416  :     CPagingStructSize = PAGING_STRUCTURE_SIZE(SeamldrData.PSeamldrConsts->CDataRgnSize) + PAGING_STRUCTURE_SIZE(SeamldrData.PSeamldrConsts->CCodeRgnSize) +

  00508	48 8b 05 48 00
	00 00		 mov	 rax, QWORD PTR SeamldrData+72
  0050f	48 8b 35 40 00
	00 00		 mov	 rsi, QWORD PTR SeamldrData+64
  00516	4c 8b 70 38	 mov	 r14, QWORD PTR [rax+56]
  0051a	48 8b 05 88 01
	00 00		 mov	 rax, QWORD PTR SeamldrData+392
  00521	49 2b f6	 sub	 rsi, r14
  00524	4c 8b 08	 mov	 r9, QWORD PTR [rax]
  00527	48 8b 50 18	 mov	 rdx, QWORD PTR [rax+24]
  0052b	48 8b 58 20	 mov	 rbx, QWORD PTR [rax+32]
  0052f	4c 8b 58 10	 mov	 r11, QWORD PTR [rax+16]
  00533	4c 8b 50 08	 mov	 r10, QWORD PTR [rax+8]
  00537	49 8d 89 00 10
	00 00		 lea	 rcx, QWORD PTR [r9+4096]
  0053e	48 8b c1	 mov	 rax, rcx
  00541	48 c1 e8 1e	 shr	 rax, 30
  00545	4c 8d 04 c5 ff
	0f 00 00	 lea	 r8, QWORD PTR [rax*8+4095]
  0054d	48 8b c1	 mov	 rax, rcx
  00550	48 c1 e8 15	 shr	 rax, 21
  00554	49 c1 e8 0c	 shr	 r8, 12
  00558	48 c1 e9 0c	 shr	 rcx, 12
  0055c	48 8d 04 c5 ff
	0f 00 00	 lea	 rax, QWORD PTR [rax*8+4095]
  00564	48 c1 e8 0c	 shr	 rax, 12
  00568	4c 03 c0	 add	 r8, rax
  0056b	48 8d 04 cd ff
	0f 00 00	 lea	 rax, QWORD PTR [rcx*8+4095]
  00573	48 c1 e8 0c	 shr	 rax, 12
  00577	4c 03 c0	 add	 r8, rax
  0057a	49 8b c2	 mov	 rax, r10
  0057d	48 c1 e8 1e	 shr	 rax, 30
  00581	48 8d 04 c5 ff
	0f 00 00	 lea	 rax, QWORD PTR [rax*8+4095]
  00589	48 c1 e8 0c	 shr	 rax, 12
  0058d	4c 03 c0	 add	 r8, rax
  00590	49 8b c2	 mov	 rax, r10
  00593	48 c1 e8 15	 shr	 rax, 21
  00597	48 8d 04 c5 ff
	0f 00 00	 lea	 rax, QWORD PTR [rax*8+4095]
  0059f	48 c1 e8 0c	 shr	 rax, 12
  005a3	4c 03 c0	 add	 r8, rax
  005a6	49 8b c2	 mov	 rax, r10
  005a9	48 c1 e8 0c	 shr	 rax, 12
  005ad	48 8d 04 c5 ff
	0f 00 00	 lea	 rax, QWORD PTR [rax*8+4095]
  005b5	48 c1 e8 0c	 shr	 rax, 12
  005b9	4c 03 c0	 add	 r8, rax
  005bc	49 8b c3	 mov	 rax, r11
  005bf	48 c1 e8 1e	 shr	 rax, 30
  005c3	48 8d 04 c5 ff
	0f 00 00	 lea	 rax, QWORD PTR [rax*8+4095]
  005cb	48 c1 e8 0c	 shr	 rax, 12
  005cf	4c 03 c0	 add	 r8, rax
  005d2	49 8b c3	 mov	 rax, r11
  005d5	48 c1 e8 15	 shr	 rax, 21
  005d9	48 8d 04 c5 ff
	0f 00 00	 lea	 rax, QWORD PTR [rax*8+4095]
  005e1	48 c1 e8 0c	 shr	 rax, 12
  005e5	4c 03 c0	 add	 r8, rax
  005e8	49 8b c3	 mov	 rax, r11
  005eb	48 c1 e8 0c	 shr	 rax, 12
  005ef	48 8d 04 c5 ff
	0f 00 00	 lea	 rax, QWORD PTR [rax*8+4095]
  005f7	48 c1 e8 0c	 shr	 rax, 12
  005fb	4c 03 c0	 add	 r8, rax
  005fe	48 8b c2	 mov	 rax, rdx
  00601	48 c1 e8 1e	 shr	 rax, 30
  00605	48 8d 04 c5 ff
	0f 00 00	 lea	 rax, QWORD PTR [rax*8+4095]
  0060d	48 c1 e8 0c	 shr	 rax, 12
  00611	4c 03 c0	 add	 r8, rax
  00614	48 8b c2	 mov	 rax, rdx
  00617	48 c1 e8 15	 shr	 rax, 21
  0061b	48 c1 ea 0c	 shr	 rdx, 12
  0061f	48 8d 04 c5 ff
	0f 00 00	 lea	 rax, QWORD PTR [rax*8+4095]
  00627	48 c1 e8 0c	 shr	 rax, 12
  0062b	4c 03 c0	 add	 r8, rax
  0062e	48 8d 04 d5 ff
	0f 00 00	 lea	 rax, QWORD PTR [rdx*8+4095]
  00636	48 c1 e8 0c	 shr	 rax, 12
  0063a	4c 03 c0	 add	 r8, rax
  0063d	48 8b c3	 mov	 rax, rbx
  00640	48 c1 e8 1e	 shr	 rax, 30
  00644	48 8d 04 c5 ff
	0f 00 00	 lea	 rax, QWORD PTR [rax*8+4095]
  0064c	48 c1 e8 0c	 shr	 rax, 12
  00650	4c 03 c0	 add	 r8, rax
  00653	48 8b c3	 mov	 rax, rbx
  00656	48 c1 e8 15	 shr	 rax, 21
  0065a	48 c1 eb 0c	 shr	 rbx, 12
  0065e	48 8d 04 c5 ff
	0f 00 00	 lea	 rax, QWORD PTR [rax*8+4095]
  00666	48 c1 e8 0c	 shr	 rax, 12
  0066a	4c 03 c0	 add	 r8, rax
  0066d	48 8d 04 dd ff
	0f 00 00	 lea	 rax, QWORD PTR [rbx*8+4095]
  00675	48 c1 e8 0c	 shr	 rax, 12
  00679	4c 03 c0	 add	 r8, rax
  0067c	48 8b c6	 mov	 rax, rsi
  0067f	48 c1 e8 1e	 shr	 rax, 30
  00683	48 8d 04 c5 ff
	0f 00 00	 lea	 rax, QWORD PTR [rax*8+4095]
  0068b	48 c1 e8 0c	 shr	 rax, 12
  0068f	4c 03 c0	 add	 r8, rax
  00692	48 8b c6	 mov	 rax, rsi
  00695	48 c1 e8 15	 shr	 rax, 21
  00699	48 c1 ee 0c	 shr	 rsi, 12
  0069d	48 8d 04 c5 ff
	0f 00 00	 lea	 rax, QWORD PTR [rax*8+4095]
  006a5	48 c1 e8 0c	 shr	 rax, 12
  006a9	48 8d 0c f5 ff
	0f 00 00	 lea	 rcx, QWORD PTR [rsi*8+4095]
  006b1	4c 03 c0	 add	 r8, rax
  006b4	48 c1 e9 0c	 shr	 rcx, 12
  006b8	48 83 c1 02	 add	 rcx, 2

; 417  :         PAGING_STRUCTURE_SIZE(SeamldrData.PSeamldrConsts->CDataStackSize + P_SEAMLDR_SHADOW_STACK_SIZE) + PAGING_STRUCTURE_SIZE(SeamldrData.PSeamldrConsts->CKeyholeRgnSize) +
; 418  :         PAGING_STRUCTURE_SIZE(SeamldrData.PSeamldrConsts->CKeyholeEditRgnSize) + PAGING_STRUCTURE_SIZE(C_P_SYS_INFO_TABLE_SIZE) + 
; 419  :         PAGING_STRUCTURE_SIZE(SeamldrData.SeamrrSize - SeamldrData.PSysInfoTable->PSeamldrRange.Size) + _4KB;
; 420  :     
; 421  : 
; 422  :     if (SeamldrData.PSysInfoTable->PSeamldrRange.Size < SeamldrData.PSeamldrConsts->CCodeRgnSize + SeamldrData.PSeamldrConsts->CDataStackSize + P_SEAMLDR_SHADOW_STACK_SIZE +

  006bc	49 8d 82 00 40
	00 00		 lea	 rax, QWORD PTR [r10+16384]
  006c3	49 03 c1	 add	 rax, r9
  006c6	49 03 c8	 add	 rcx, r8
  006c9	48 c1 e1 0c	 shl	 rcx, 12
  006cd	49 03 c3	 add	 rax, r11
  006d0	48 03 c1	 add	 rax, rcx
  006d3	48 89 4d 38	 mov	 QWORD PTR CPagingStructSize$1$[rbp], rcx
  006d7	4c 3b f0	 cmp	 r14, rax
  006da	0f 83 ae 00 00
	00		 jae	 $LN31@SeamldrAcm

; 423  :         + C_VMCS_REGION_SIZE + C_P_SYS_INFO_TABLE_SIZE + SeamldrData.PSeamldrConsts->CDataRgnSize + CPagingStructSize) {
; 424  :         COMSERIALOUT("Pseamldr Range too small\n");

  006e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@HHJIMKFB@Pseamldr?5Range?5too?5small?6?$AA@IMHBAIGO@
  006e7	e8 00 00 00 00	 call	 ComSerialOut

; 425  :         Status = NP_SEAMLDR_PARAMS_STATUS_ENOMEM;

  006ec	48 be 02 00 01
	00 00 00 00 80	 mov	 rsi, -9223372036854710270 ; 8000000000010002H
$LN49@SeamldrAcm:
  006f6	4c 8b 75 00	 mov	 r14, QWORD PTR OriginalBIOSID$1$[rbp]
$EXIT$57:

; 506  : 
; 507  : EXIT:
; 508  :     pCom64->RetVal = Status;
; 509  :     writeMsr64(MSR_IA32_MISC_ENABLES, ia32_misc_enable_org);

  006fa	48 8b 55 28	 mov	 rdx, QWORD PTR ia32_misc_enable_org$1$[rbp]
  006fe	b9 a0 01 00 00	 mov	 ecx, 416		; 000001a0H
  00703	49 89 75 66	 mov	 QWORD PTR [r13+102], rsi
  00707	e8 00 00 00 00	 call	 __writeMsr64

; 510  :     if (SEAMRRUnlocked) {

  0070c	45 84 ff	 test	 r15b, r15b
  0070f	74 26		 je	 SHORT $LN40@SeamldrAcm

; 511  :         if (MutexAcquired) {

  00711	45 84 e4	 test	 r12b, r12b
  00714	74 0f		 je	 SHORT $LN41@SeamldrAcm

; 512  :             SeamldrData.PSysInfoTable->NpSeamldrMutex = NP_SEAMLDR_MUTEX_CLEAR;

  00716	48 8b 05 48 00
	00 00		 mov	 rax, QWORD PTR SeamldrData+72
  0071d	48 83 a0 00 08
	00 00 00	 and	 QWORD PTR [rax+2048], 0
$LN41@SeamldrAcm:

; 513  :         }
; 514  : 
; 515  : 
; 516  :         // SEAM range relocking:
; 517  :         SeamrrMaskMsr.valid = 1;

  00725	48 0f ba ef 0b	 bts	 rdi, 11

; 518  :         writeMsr64(MSR_IA32_SEAMRR_MASK, SeamrrMaskMsr.raw);

  0072a	b9 01 14 00 00	 mov	 ecx, 5121		; 00001401H
  0072f	48 8b d7	 mov	 rdx, rdi
  00732	e8 00 00 00 00	 call	 __writeMsr64
$LN40@SeamldrAcm:

; 519  : #ifdef _SEAMRR_MASK_WA_
; 520  :         writeMsr64(MSR_BIOS_DONE, BiosDone); // restore the ENABLE_IA_UNTRUSTED bit
; 521  : #endif
; 522  :     }
; 523  : 
; 524  : 
; 525  :     // RESTORE BIOS ID after the last CPUID
; 526  :     writeMsr64(MSR_IA32_BIOS_SIGN_ID, OriginalBIOSID);

  00737	49 8b d6	 mov	 rdx, r14
  0073a	b9 8b 00 00 00	 mov	 ecx, 139		; 0000008bH
  0073f	e8 00 00 00 00	 call	 __writeMsr64

; 527  : 
; 528  :     PRINT_HEX_VAL("Exitingseamldr\nStatus: 0x", Status);

  00744	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@EBJAMEFH@Exitingseamldr?6Status?3?50x?$AA@IMHBAIGO@
  0074b	e8 00 00 00 00	 call	 ComSerialOut
  00750	48 8b ce	 mov	 rcx, rsi
  00753	e8 00 00 00 00	 call	 printHex
  00758	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@IMHBAIGO@
  0075f	e8 00 00 00 00	 call	 ComSerialOut

; 529  :     SIMICS_BREAKPOINT;

  00764	b8 11 47 00 00	 mov	 eax, 18193		; 00004711H
  00769	33 c9		 xor	 ecx, ecx
  0076b	0f a2		 cpuid

; 530  : //    DEBUG ((EFI_D_INFO, ("Exit 64 bit code\n"));
; 531  : }

  0076d	4c 8d 9c 24 a0
	01 00 00	 lea	 r11, QWORD PTR [rsp+416]
  00775	49 8b 5b 30	 mov	 rbx, QWORD PTR [r11+48]
  00779	49 8b 73 38	 mov	 rsi, QWORD PTR [r11+56]
  0077d	49 8b 7b 40	 mov	 rdi, QWORD PTR [r11+64]
  00781	49 8b e3	 mov	 rsp, r11
  00784	41 5f		 pop	 r15
  00786	41 5e		 pop	 r14
  00788	41 5d		 pop	 r13
  0078a	41 5c		 pop	 r12
  0078c	5d		 pop	 rbp
  0078d	c3		 ret	 0
$LN31@SeamldrAcm:

; 426  :         goto EXIT;
; 427  :     }
; 428  :     PRINT_HEX_VAL("SeamRR VA: 0x", SeamldrData.SeamrrVa);

  0078e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@FKFJLLIL@SeamRR?5VA?3?50x?$AA@IMHBAIGO@
  00795	e8 00 00 00 00	 call	 ComSerialOut
  0079a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR SeamldrData
  007a1	e8 00 00 00 00	 call	 printHex
  007a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@IMHBAIGO@
  007ad	e8 00 00 00 00	 call	 ComSerialOut

; 429  :     PRINT_HEX_VAL("SeamRR Size: 0x", SeamldrData.SeamrrSize);

  007b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@HINKIKFF@SeamRR?5Size?3?50x?$AA@IMHBAIGO@
  007b9	e8 00 00 00 00	 call	 ComSerialOut
  007be	48 8b 0d 40 00
	00 00		 mov	 rcx, QWORD PTR SeamldrData+64
  007c5	e8 00 00 00 00	 call	 printHex
  007ca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@IMHBAIGO@
  007d1	e8 00 00 00 00	 call	 ComSerialOut

; 430  :     
; 431  :     MemZeroWithMovdir64B((UINT8*)(SeamldrData.SeamrrVa + SeamldrData.PSysInfoTable->PSeamldrRange.Base - SeamldrData.SeamrrBase), (SeamldrData.SeamrrBase + SeamldrData.SeamrrSize -

  007d6	48 8b 05 48 00
	00 00		 mov	 rax, QWORD PTR SeamldrData+72
  007dd	48 8b 1d 38 00
	00 00		 mov	 rbx, QWORD PTR SeamldrData+56
  007e4	48 8b 48 30	 mov	 rcx, QWORD PTR [rax+48]
  007e8	48 8b 05 40 00
	00 00		 mov	 rax, QWORD PTR SeamldrData+64
  007ef	48 8d 93 00 f0
	ff ff		 lea	 rdx, QWORD PTR [rbx-4096]
  007f6	48 2b c1	 sub	 rax, rcx
  007f9	48 2b cb	 sub	 rcx, rbx
  007fc	48 03 0d 00 00
	00 00		 add	 rcx, QWORD PTR SeamldrData
  00803	48 03 d0	 add	 rdx, rax
  00806	e8 00 00 00 00	 call	 MemZeroWithMovdir64B

; 432  :         SeamldrData.PSysInfoTable->PSeamldrRange.Base - C_P_SYS_INFO_TABLE_SIZE));
; 433  :     MemZeroWithMovdir64B((UINT8*)(SeamldrData.SeamrrVa + SeamldrData.SeamrrSize - _2KB), _2KB);

  0080b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR SeamldrData
  00812	ba 00 08 00 00	 mov	 edx, 2048		; 00000800H
  00817	48 8b 0d 40 00
	00 00		 mov	 rcx, QWORD PTR SeamldrData+64
  0081e	48 05 00 f8 ff
	ff		 add	 rax, -2048		; fffffffffffff800H
  00824	48 03 c8	 add	 rcx, rax
  00827	e8 00 00 00 00	 call	 MemZeroWithMovdir64B

; 434  : 
; 435  :     COMSERIALOUT("Load  P-Seamld code\n");

  0082c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@LGBACFPP@Load?5?5P?9Seamld?5code?6?$AA@IMHBAIGO@
  00833	e8 00 00 00 00	 call	 ComSerialOut

; 436  :     SIMICS_BREAKPOINT;

  00838	33 c9		 xor	 ecx, ecx
  0083a	41 be 11 47 00
	00		 mov	 r14d, 18193		; 00004711H
  00840	41 8b c6	 mov	 eax, r14d
  00843	0f a2		 cpuid

; 437  : 
; 438  :     // After copying(or as part of copying) into the SEAMRR, measure the copied image using SHA384.
; 439  :     // Specifically, the measurement must not be done on the module image outside SEAMRR.
; 440  :     Status = LoadModuleCode((UINT8*) pCom64->PseamldrOffset, pCom64->PseamldrSize);

  00845	41 8b 55 76	 mov	 edx, DWORD PTR [r13+118]
  00849	49 8b 4d 7a	 mov	 rcx, QWORD PTR [r13+122]
  0084d	e8 00 00 00 00	 call	 LoadModuleCode
  00852	48 8b f0	 mov	 rsi, rax

; 441  :     if (Status != NP_SEAMLDR_PARAMS_STATUS_SUCCESS) {

  00855	48 85 c0	 test	 rax, rax
  00858	74 11		 je	 SHORT $LN32@SeamldrAcm

; 442  :         COMSERIALOUT("Loading P-Seamldr code failed\n");

  0085a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BP@KEEGAGND@Loading?5P?9Seamldr?5code?5failed?6?$AA@IMHBAIGO@
$LN50@SeamldrAcm:
  00861	e8 00 00 00 00	 call	 ComSerialOut

; 443  :         goto EXIT;

  00866	e9 8b fe ff ff	 jmp	 $LN49@SeamldrAcm
$LN32@SeamldrAcm:

; 444  :     }
; 445  :     
; 446  :     InitPseamldrPtCtx(&SeamrrPtCtx, SeamldrData.SeamrrVa, SeamldrData.SeamrrBase, SeamldrData.SeamrrSize, SeamldrData.PSysInfoTable->PSeamldrRange.Base, CPagingStructSize);

  0086b	48 8b 45 38	 mov	 rax, QWORD PTR CPagingStructSize$1$[rbp]
  0086f	4c 8b 0d 40 00
	00 00		 mov	 r9, QWORD PTR SeamldrData+64
  00876	4c 8b 05 38 00
	00 00		 mov	 r8, QWORD PTR SeamldrData+56
  0087d	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR SeamldrData
  00884	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00889	48 8b 05 48 00
	00 00		 mov	 rax, QWORD PTR SeamldrData+72
  00890	48 8b 48 30	 mov	 rcx, QWORD PTR [rax+48]
  00894	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00899	48 8d 4d 40	 lea	 rcx, QWORD PTR SeamrrPtCtx$[rbp]
  0089d	e8 00 00 00 00	 call	 InitPseamldrPtCtx

; 447  : 
; 448  :     Status = RelocateImage(SeamldrData.SeamrrVaLimit - (SeamldrData.PSeamldrConsts->CCodeRgnSize + C_P_SYS_INFO_TABLE_SIZE), C_CODE_RGN_BASE | SeamldrData.AslrRand);

  008a2	48 8b 15 10 00
	00 00		 mov	 rdx, QWORD PTR SeamldrData+16
  008a9	48 b8 00 00 00
	00 00 80 ff ff	 mov	 rax, -140737488355328	; ffff800000000000H
  008b3	48 8b 0d 08 00
	00 00		 mov	 rcx, QWORD PTR SeamldrData+8
  008ba	48 0b d0	 or	 rdx, rax
  008bd	48 8b 05 88 01
	00 00		 mov	 rax, QWORD PTR SeamldrData+392
  008c4	48 2b 48 08	 sub	 rcx, QWORD PTR [rax+8]
  008c8	48 81 e9 00 10
	00 00		 sub	 rcx, 4096		; 00001000H
  008cf	e8 00 00 00 00	 call	 RelocateImage
  008d4	48 8b f0	 mov	 rsi, rax

; 449  :     if (Status != NP_SEAMLDR_PARAMS_STATUS_SUCCESS) {

  008d7	48 85 c0	 test	 rax, rax
  008da	74 0c		 je	 SHORT $LN33@SeamldrAcm

; 450  :         COMSERIALOUT("Failed to relocate P-Seamldr\n");

  008dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BO@FCLKAN@Failed?5to?5relocate?5P?9Seamldr?6?$AA@IMHBAIGO@

; 451  :         goto EXIT;

  008e3	e9 79 ff ff ff	 jmp	 $LN50@SeamldrAcm
$LN33@SeamldrAcm:

; 452  :     };
; 453  : 
; 454  :     COMSERIALOUT("Map P-Seamldr pages\n");

  008e8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@CKNDFINP@Map?5P?9Seamldr?5pages?6?$AA@IMHBAIGO@
  008ef	e8 00 00 00 00	 call	 ComSerialOut

; 455  :     Status = MapModulePages(&SeamrrPtCtx, pCom64->PseamldrSize);

  008f4	41 8b 55 76	 mov	 edx, DWORD PTR [r13+118]
  008f8	48 8d 4d 40	 lea	 rcx, QWORD PTR SeamrrPtCtx$[rbp]
  008fc	e8 00 00 00 00	 call	 MapModulePages
  00901	48 8b f0	 mov	 rsi, rax

; 456  :     if (Status != NP_SEAMLDR_PARAMS_STATUS_SUCCESS) {

  00904	48 85 c0	 test	 rax, rax
  00907	74 0c		 je	 SHORT $LN34@SeamldrAcm

; 457  :         COMSERIALOUT("Failed to map module pages\n");

  00909	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BM@DDMELFPJ@Failed?5to?5map?5module?5pages?6?$AA@IMHBAIGO@

; 458  :         goto EXIT;

  00910	e9 4c ff ff ff	 jmp	 $LN50@SeamldrAcm
$LN34@SeamldrAcm:

; 459  :     };
; 460  : 
; 461  :     COMSERIALOUT("Setup stacks\n");

  00915	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@NNMOLPJK@Setup?5stacks?6?$AA@IMHBAIGO@
  0091c	e8 00 00 00 00	 call	 ComSerialOut

; 462  :     Status = SetupStacks(&SeamrrPtCtx);

  00921	48 8d 4d 40	 lea	 rcx, QWORD PTR SeamrrPtCtx$[rbp]
  00925	e8 00 00 00 00	 call	 SetupStacks
  0092a	48 8b f0	 mov	 rsi, rax

; 463  :     if (Status != NP_SEAMLDR_PARAMS_STATUS_SUCCESS) {

  0092d	48 85 c0	 test	 rax, rax
  00930	74 0c		 je	 SHORT $LN35@SeamldrAcm

; 464  :         COMSERIALOUT("Failed to setup stacks\n");

  00932	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@CDALIHGP@Failed?5to?5setup?5stacks?6?$AA@IMHBAIGO@

; 465  :         goto EXIT;

  00939	e9 23 ff ff ff	 jmp	 $LN50@SeamldrAcm
$LN35@SeamldrAcm:

; 466  :     };
; 467  :     COMSERIALOUT("Setup keyhole\n");

  0093e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@MNGGMCMN@Setup?5keyhole?6?$AA@IMHBAIGO@
  00945	e8 00 00 00 00	 call	 ComSerialOut

; 468  :     //    DEBUG ((EFI_D_INFO, ("Setup keyhole\n"));
; 469  :     Status = SetupKeyholeMapping(&SeamrrPtCtx);

  0094a	48 8d 4d 40	 lea	 rcx, QWORD PTR SeamrrPtCtx$[rbp]
  0094e	e8 00 00 00 00	 call	 SetupKeyholeMapping
  00953	48 8b f0	 mov	 rsi, rax

; 470  :     if (Status != NP_SEAMLDR_PARAMS_STATUS_SUCCESS) {

  00956	48 85 c0	 test	 rax, rax
  00959	74 0c		 je	 SHORT $LN36@SeamldrAcm

; 471  :         COMSERIALOUT("Failed to setup keyholes\n");

  0095b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@FBODADJ@Failed?5to?5setup?5keyholes?6?$AA@IMHBAIGO@

; 472  :         goto EXIT;

  00962	e9 fa fe ff ff	 jmp	 $LN50@SeamldrAcm
$LN36@SeamldrAcm:

; 473  :     };
; 474  : 
; 475  :     COMSERIALOUT("Setup Data Region\n");

  00967	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@KDAKIHP@Setup?5Data?5Region?6?$AA@IMHBAIGO@
  0096e	e8 00 00 00 00	 call	 ComSerialOut

; 476  :     Status = SetupDataRegion(&SeamrrPtCtx);

  00973	48 8d 4d 40	 lea	 rcx, QWORD PTR SeamrrPtCtx$[rbp]
  00977	e8 00 00 00 00	 call	 SetupDataRegion
  0097c	48 8b f0	 mov	 rsi, rax

; 477  :     if (Status != NP_SEAMLDR_PARAMS_STATUS_SUCCESS) {

  0097f	48 85 c0	 test	 rax, rax
  00982	74 0c		 je	 SHORT $LN37@SeamldrAcm

; 478  :         COMSERIALOUT("Failed to setup data region\n");

  00984	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BN@OICIBGCH@Failed?5to?5setup?5data?5region?6?$AA@IMHBAIGO@

; 479  :         goto EXIT;

  0098b	e9 d1 fe ff ff	 jmp	 $LN50@SeamldrAcm
$LN37@SeamldrAcm:

; 480  :     };
; 481  : 
; 482  :     // map system information tables
; 483  :     COMSERIALOUT("Map SysInfoTable\n");

  00990	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@DBKHJAMB@Map?5SysInfoTable?6?$AA@IMHBAIGO@
  00997	e8 00 00 00 00	 call	 ComSerialOut

; 484  :     Status = MapSysInfoTables(&SeamrrPtCtx);

  0099c	48 8d 4d 40	 lea	 rcx, QWORD PTR SeamrrPtCtx$[rbp]
  009a0	e8 00 00 00 00	 call	 MapSysInfoTables
  009a5	48 8b f0	 mov	 rsi, rax

; 485  :     if (Status != NP_SEAMLDR_PARAMS_STATUS_SUCCESS) {

  009a8	48 85 c0	 test	 rax, rax
  009ab	0f 85 45 fd ff
	ff		 jne	 $LN49@SeamldrAcm

; 486  :         goto EXIT;
; 487  :     }
; 488  : 
; 489  :     COMSERIALOUT("Setup Module Region\n");

  009b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@FEICECMF@Setup?5Module?5Region?6?$AA@IMHBAIGO@
  009b8	e8 00 00 00 00	 call	 ComSerialOut

; 490  :     Status = MapModuleRegion(&SeamrrPtCtx);

  009bd	48 8d 4d 40	 lea	 rcx, QWORD PTR SeamrrPtCtx$[rbp]
  009c1	e8 00 00 00 00	 call	 MapModuleRegion
  009c6	48 8b f0	 mov	 rsi, rax

; 491  :     if (Status != NP_SEAMLDR_PARAMS_STATUS_SUCCESS) {

  009c9	48 85 c0	 test	 rax, rax
  009cc	74 0c		 je	 SHORT $LN39@SeamldrAcm

; 492  :         COMSERIALOUT("Failed to map Module Region!\n");

  009ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BO@OEPBOPGA@Failed?5to?5map?5Module?5Region?$CB?6?$AA@IMHBAIGO@

; 493  :         goto EXIT;

  009d5	e9 87 fe ff ff	 jmp	 $LN50@SeamldrAcm
$LN39@SeamldrAcm:

; 494  :     }
; 495  : 
; 496  : 
; 497  :     COMSERIALOUT("Setup PSysinfo table\n");

  009da	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@DLHFFDEJ@Setup?5PSysinfo?5table?6?$AA@IMHBAIGO@
  009e1	e8 00 00 00 00	 call	 ComSerialOut

; 498  :     SetupSysInfoTable();

  009e6	e8 00 00 00 00	 call	 SetupSysInfoTable

; 499  : 
; 500  :     COMSERIALOUT("Setup VMCS\n");

  009eb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@KPDHHIMA@Setup?5VMCS?6?$AA@IMHBAIGO@
  009f2	e8 00 00 00 00	 call	 ComSerialOut

; 501  :     SetupVmcs(SeamrrPtCtx.PtBaseAddrPa);

  009f7	48 8b 4d 48	 mov	 rcx, QWORD PTR SeamrrPtCtx$[rbp+8]
  009fb	e8 00 00 00 00	 call	 SetupVmcs

; 502  : 
; 503  :     COMSERIALOUT("Record Seam identity\n");

  00a00	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@NNIHHKKC@Record?5Seam?5identity?6?$AA@IMHBAIGO@
  00a07	e8 00 00 00 00	 call	 ComSerialOut

; 504  :     SIMICS_BREAKPOINT;

  00a0c	41 8b c6	 mov	 eax, r14d
  00a0f	33 c9		 xor	 ecx, ecx
  00a11	0f a2		 cpuid

; 505  :     RecordSeamIdentity();

  00a13	e8 00 00 00 00	 call	 RecordSeamIdentity
  00a18	e9 d9 fc ff ff	 jmp	 $LN49@SeamldrAcm
$LN29@SeamldrAcm:

; 399  :         COMSERIALOUT("Error: P Seamldr hasn't shut down properly\n");

  00a1d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CM@LIHANEGM@Error?3?5P?5Seamldr?5hasn?8t?5shut?5dow@IMHBAIGO@

; 400  :         Status = NP_SEAMLDR_PARAMS_STATUS_EMODBUSY;
; 401  :         goto EXIT;

  00a24	e9 45 fa ff ff	 jmp	 $LN54@SeamldrAcm
$LN23@SeamldrAcm:

; 355  :         (SeamldrData.PSysInfoTable->TotNumSockets == 0)){
; 356  :         PRINT_HEX_VAL("Invalid number of sockets: \n", SeamldrData.PSysInfoTable->TotNumSockets);

  00a29	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BN@EABEMNCL@Invalid?5number?5of?5sockets?3?5?6?$AA@IMHBAIGO@
  00a30	e8 00 00 00 00	 call	 ComSerialOut
  00a35	48 8b 05 48 00
	00 00		 mov	 rax, QWORD PTR SeamldrData+72
  00a3c	8b 48 0c	 mov	 ecx, DWORD PTR [rax+12]
  00a3f	e8 00 00 00 00	 call	 printHex
  00a44	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@IMHBAIGO@
  00a4b	e8 00 00 00 00	 call	 ComSerialOut

; 357  :         Status = NP_SEAMLDR_PARAMS_STATUS_EBADPARAM;

  00a50	48 be 00 00 00
	00 00 00 00 80	 mov	 rsi, -9223372036854775808 ; 8000000000000000H
  00a5a	e9 9b fc ff ff	 jmp	 $EXIT$57
SeamldrAcm ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File c:\users\jwhur\downloads\seam-loader\seam-loader-main-1.5\np-seam-loader\seamldr_src\core\commonseamldr64\seamldrcore64.c
;	COMDAT RecordSeamIdentity
_TEXT	SEGMENT
SeamExtend$ = 0
RecordSeamIdentity PROC					; COMDAT

; 226  : void RecordSeamIdentity() {

$LN4:
  00000	40 55		 push	 rbp
  00002	48 81 ec 20 02
	00 00		 sub	 rsp, 544		; 00000220H
  00009	48 8d ac 24 20
	01 00 00	 lea	 rbp, QWORD PTR [rsp+288]
  00011	48 81 e5 00 ff
	ff ff		 and	 rbp, -256		; ffffffffffffff00H
  00018	33 d2		 xor	 edx, edx
  0001a	48 8d 4d 00	 lea	 rcx, QWORD PTR SeamExtend$[rbp]
  0001e	41 b8 88 00 00
	00		 mov	 r8d, 136		; 00000088H
  00024	e8 00 00 00 00	 call	 memset

; 227  :     __declspec(align(256)) SEAM_EXTEND_t SeamExtend = { 0 };
; 228  : 
; 229  :     SeamExtend.SeamReady =  SEAM_EXTEND_SEAM_READY_VAL;
; 230  :     SeamExtend.SeamUnderDebug = (readMsr64(MSR_SGX_DEBUG_MODE) & BIT1) >> 1;

  00029	b9 03 05 00 00	 mov	 ecx, 1283		; 00000503H
  0002e	c6 85 80 00 00
	00 00		 mov	 BYTE PTR SeamExtend$[rbp+128], 0
  00035	e8 00 00 00 00	 call	 __readMsr64
  0003a	d0 e8		 shr	 al, 1

; 231  :     SeamExtend.PSeamldrReady = SP_SEAMLDR_PLAG_READY;
; 232  :     writeMsr64(MSR_IA32_SEAMEXTEND, (UINT64) &SeamExtend);

  0003c	48 8d 55 00	 lea	 rdx, QWORD PTR SeamExtend$[rbp]
  00040	24 01		 and	 al, 1
  00042	c6 85 82 00 00
	00 01		 mov	 BYTE PTR SeamExtend$[rbp+130], 1
  00049	b9 02 14 00 00	 mov	 ecx, 5122		; 00001402H
  0004e	88 85 81 00 00
	00		 mov	 BYTE PTR SeamExtend$[rbp+129], al
  00054	e8 00 00 00 00	 call	 __writeMsr64

; 233  : }

  00059	48 81 c4 20 02
	00 00		 add	 rsp, 544		; 00000220H
  00060	5d		 pop	 rbp
  00061	c3		 ret	 0
RecordSeamIdentity ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File c:\users\jwhur\downloads\seam-loader\seam-loader-main-1.5\np-seam-loader\seamldr_src\core\commonseamldr64\seamldrcore64.c
;	COMDAT ReadSeamExtendMsr
_TEXT	SEGMENT
SeamExtendAddr$ = 8
ReadSeamExtendMsr PROC					; COMDAT

; 223  :     writeMsr64(MSR_IA32_SEAMEXTEND, SeamExtendAddr | 0x1);

  00000	48 83 c9 01	 or	 rcx, 1
  00004	48 8b d1	 mov	 rdx, rcx
  00007	b9 02 14 00 00	 mov	 ecx, 5122		; 00001402H
  0000c	e9 00 00 00 00	 jmp	 __writeMsr64
ReadSeamExtendMsr ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File c:\users\jwhur\downloads\seam-loader\seam-loader-main-1.5\np-seam-loader\seamldr_src\core\commonseamldr64\seamldrcore64.c
;	COMDAT SetupSysInfoTable
_TEXT	SEGMENT
SetupSysInfoTable PROC					; COMDAT

; 202  : void SetupSysInfoTable() {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 203  :     SeamldrData.PSysInfoTable->CodeRgn.Base = C_CODE_RGN_BASE | SeamldrData.AslrRand;

  00004	48 8b 0d 10 00
	00 00		 mov	 rcx, QWORD PTR SeamldrData+16
  0000b	48 b8 00 00 00
	00 00 80 ff ff	 mov	 rax, -140737488355328	; ffff800000000000H
  00015	48 0b c8	 or	 rcx, rax
  00018	48 8b 05 48 00
	00 00		 mov	 rax, QWORD PTR SeamldrData+72
  0001f	48 89 88 08 08
	00 00		 mov	 QWORD PTR [rax+2056], rcx

; 204  :     SeamldrData.PSysInfoTable->CodeRgn.Size = SeamldrData.PSeamldrConsts->CCodeRgnSize;

  00026	48 8b 05 88 01
	00 00		 mov	 rax, QWORD PTR SeamldrData+392
  0002d	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00031	48 8b 05 48 00
	00 00		 mov	 rax, QWORD PTR SeamldrData+72
  00038	48 89 88 10 08
	00 00		 mov	 QWORD PTR [rax+2064], rcx

; 205  :     SeamldrData.PSysInfoTable->DataRgn.Base = C_DATA_RGN_BASE | SeamldrData.AslrRand;

  0003f	48 b8 00 00 00
	00 03 80 ff ff	 mov	 rax, -140724603453440	; ffff800300000000H
  00049	48 8b 0d 10 00
	00 00		 mov	 rcx, QWORD PTR SeamldrData+16
  00050	48 0b c8	 or	 rcx, rax
  00053	48 8b 05 48 00
	00 00		 mov	 rax, QWORD PTR SeamldrData+72
  0005a	48 89 88 18 08
	00 00		 mov	 QWORD PTR [rax+2072], rcx

; 206  :     SeamldrData.PSysInfoTable->DataRgn.Size = SeamldrData.PSeamldrConsts->CDataRgnSize;

  00061	48 8b 05 88 01
	00 00		 mov	 rax, QWORD PTR SeamldrData+392
  00068	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  0006c	48 8b 05 48 00
	00 00		 mov	 rax, QWORD PTR SeamldrData+72
  00073	48 89 88 20 08
	00 00		 mov	 QWORD PTR [rax+2080], rcx

; 207  :     SeamldrData.PSysInfoTable->StackRgn.Base = C_STACK_RGN_BASE | SeamldrData.AslrRand;

  0007a	48 b8 00 00 00
	00 01 80 ff ff	 mov	 rax, -140733193388032	; ffff800100000000H
  00084	48 8b 0d 10 00
	00 00		 mov	 rcx, QWORD PTR SeamldrData+16
  0008b	48 0b c8	 or	 rcx, rax
  0008e	48 8b 05 48 00
	00 00		 mov	 rax, QWORD PTR SeamldrData+72
  00095	48 89 88 28 08
	00 00		 mov	 QWORD PTR [rax+2088], rcx

; 208  :     SeamldrData.PSysInfoTable->StackRgn.Size = SeamldrData.PSeamldrConsts->CDataStackSize + P_SEAMLDR_SHADOW_STACK_SIZE;

  0009c	48 8b 05 88 01
	00 00		 mov	 rax, QWORD PTR SeamldrData+392
  000a3	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000a6	48 8b 05 48 00
	00 00		 mov	 rax, QWORD PTR SeamldrData+72
  000ad	48 81 c1 00 10
	00 00		 add	 rcx, 4096		; 00001000H
  000b4	48 89 88 30 08
	00 00		 mov	 QWORD PTR [rax+2096], rcx

; 209  :     SeamldrData.PSysInfoTable->KeyholeRgn.Base = C_KEYHOLE_RGN_BASE | SeamldrData.AslrRand;

  000bb	48 b8 00 00 00
	00 02 80 ff ff	 mov	 rax, -140728898420736	; ffff800200000000H
  000c5	48 8b 0d 10 00
	00 00		 mov	 rcx, QWORD PTR SeamldrData+16
  000cc	48 0b c8	 or	 rcx, rax
  000cf	48 8b 05 48 00
	00 00		 mov	 rax, QWORD PTR SeamldrData+72
  000d6	48 89 88 38 08
	00 00		 mov	 QWORD PTR [rax+2104], rcx

; 210  :     SeamldrData.PSysInfoTable->KeyholeRgn.Size = SeamldrData.PSeamldrConsts->CKeyholeRgnSize;

  000dd	48 8b 05 88 01
	00 00		 mov	 rax, QWORD PTR SeamldrData+392
  000e4	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  000e8	48 8b 05 48 00
	00 00		 mov	 rax, QWORD PTR SeamldrData+72
  000ef	48 89 88 40 08
	00 00		 mov	 QWORD PTR [rax+2112], rcx

; 211  :     SeamldrData.PSysInfoTable->KeyholeEditRgn.Base = C_KEYHOLE_EDIT_REGION_BASE | SeamldrData.AslrRand;

  000f6	48 b8 00 00 00
	00 01 00 00 00	 mov	 rax, 4294967296		; 0000000100000000H
  00100	48 8b 0d 10 00
	00 00		 mov	 rcx, QWORD PTR SeamldrData+16
  00107	48 0b c8	 or	 rcx, rax
  0010a	48 8b 05 48 00
	00 00		 mov	 rax, QWORD PTR SeamldrData+72
  00111	48 89 88 48 08
	00 00		 mov	 QWORD PTR [rax+2120], rcx

; 212  :     SeamldrData.PSysInfoTable->KeyholeEditRgn.Size = SeamldrData.PSeamldrConsts->CKeyholeEditRgnSize;

  00118	48 8b 05 88 01
	00 00		 mov	 rax, QWORD PTR SeamldrData+392
  0011f	48 8b 48 20	 mov	 rcx, QWORD PTR [rax+32]
  00123	48 8b 05 48 00
	00 00		 mov	 rax, QWORD PTR SeamldrData+72
  0012a	48 89 88 50 08
	00 00		 mov	 QWORD PTR [rax+2128], rcx

; 213  :     SeamldrData.PSysInfoTable->ModuleRgnBase = C_MODULE_RGN_BASE | SeamldrData.AslrRand;

  00131	48 b8 00 00 00
	00 02 00 00 00	 mov	 rax, 8589934592		; 0000000200000000H
  0013b	48 8b 0d 10 00
	00 00		 mov	 rcx, QWORD PTR SeamldrData+16
  00142	48 0b c8	 or	 rcx, rax
  00145	48 8b 05 48 00
	00 00		 mov	 rax, QWORD PTR SeamldrData+72
  0014c	48 89 88 58 08
	00 00		 mov	 QWORD PTR [rax+2136], rcx

; 214  :     SeamldrData.PSysInfoTable->AcmX2ApicId = GetX2ApicId();

  00153	e8 00 00 00 00	 call	 GetX2ApicId
  00158	48 8b 0d 48 00
	00 00		 mov	 rcx, QWORD PTR SeamldrData+72
  0015f	89 81 60 08 00
	00		 mov	 DWORD PTR [rcx+2144], eax

; 215  :     SeamldrData.PSysInfoTable->AcmX2ApicIdValid = SYS_INFO_TABLE_X2APICID_VALID;

  00165	48 8b 05 48 00
	00 00		 mov	 rax, QWORD PTR SeamldrData+72
  0016c	c7 80 64 08 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+2148], 1

; 216  : }

  00176	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0017a	c3		 ret	 0
SetupSysInfoTable ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File c:\users\jwhur\downloads\seam-loader\seam-loader-main-1.5\np-seam-loader\seamldr_src\core\commonseamldr64\seamldrcore64.c
;	COMDAT MapModuleRegion
_TEXT	SEGMENT
SeamrrPtCtx$ = 80
MapModuleRegion PROC					; COMDAT

; 170  : UINT64 MapModuleRegion(SEAMRR_PT_CTX* SeamrrPtCtx) {

$LN26:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000f	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  00013	41 55		 push	 r13
  00015	41 56		 push	 r14
  00017	41 57		 push	 r15
  00019	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 171  :     UINT64 CurLinAddr = C_MODULE_RGN_BASE | SeamldrData.AslrRand;

  0001d	48 8b 3d 10 00
	00 00		 mov	 rdi, QWORD PTR SeamldrData+16
  00024	48 b8 00 00 00
	00 02 00 00 00	 mov	 rax, 8589934592		; 0000000200000000H

; 172  :     UINT64 CurPhysAddr = SeamldrData.SeamrrBase;
; 173  :     UINT32 Idx;
; 174  :     UINT64 SeamrrSize = SeamldrData.SeamrrSize;
; 175  :     UINT64 EndOf2MbMappingPhysAddr;
; 176  :     
; 177  :     for (Idx = 0; Idx < (SeamrrSize - SeamldrData.PSysInfoTable->PSeamldrRange.Size) / PAGE2M; Idx++) {

  0002e	4c 8b 05 48 00
	00 00		 mov	 r8, QWORD PTR SeamldrData+72
  00035	48 0b f8	 or	 rdi, rax
  00038	4c 8b 35 40 00
	00 00		 mov	 r14, QWORD PTR SeamldrData+64
  0003f	33 ed		 xor	 ebp, ebp
  00041	48 8b 15 38 00
	00 00		 mov	 rdx, QWORD PTR SeamldrData+56
  00048	49 8b c6	 mov	 rax, r14
  0004b	4c 8b f9	 mov	 r15, rcx
  0004e	48 8b da	 mov	 rbx, rdx
  00051	49 2b 40 38	 sub	 rax, QWORD PTR [r8+56]
  00055	49 b9 63 00 00
	00 00 00 00 80	 mov	 r9, -9223372036854775709 ; 8000000000000063H
  0005f	48 a9 00 00 e0
	ff		 test	 rax, -2097152		; ffffffffffe00000H
  00065	76 6c		 jbe	 SHORT $LN3@MapModuleR

; 171  :     UINT64 CurLinAddr = C_MODULE_RGN_BASE | SeamldrData.AslrRand;

  00067	48 8d b2 00 00
	20 00		 lea	 rsi, QWORD PTR [rdx+2097152]
  0006e	41 bd 00 00 20
	00		 mov	 r13d, 2097152		; 00200000H
$LL4@MapModuleR:

; 178  :         if (CurPhysAddr + PAGE2M > SeamldrData.PSysInfoTable->PSeamldrRange.Base) {

  00074	49 3b 70 30	 cmp	 rsi, QWORD PTR [r8+48]
  00078	77 52		 ja	 SHORT $LN24@MapModuleR

; 179  :             break;
; 180  :         }
; 181  :         if (MapPage(SeamrrPtCtx, CurLinAddr, CurPhysAddr, IA32_PG_P | IA32_PG_RW | IA32_PG_A | IA32_PG_D | IA32_PG_NX, PAGE_2M, FALSE) == NULL) {

  0007a	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  0007f	4c 8b c3	 mov	 r8, rbx
  00082	48 8b d7	 mov	 rdx, rdi
  00085	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  0008d	49 8b cf	 mov	 rcx, r15
  00090	e8 00 00 00 00	 call	 MapPage
  00095	48 85 c0	 test	 rax, rax
  00098	0f 84 d9 00 00
	00		 je	 $LN16@MapModuleR

; 172  :     UINT64 CurPhysAddr = SeamldrData.SeamrrBase;
; 173  :     UINT32 Idx;
; 174  :     UINT64 SeamrrSize = SeamldrData.SeamrrSize;
; 175  :     UINT64 EndOf2MbMappingPhysAddr;
; 176  :     
; 177  :     for (Idx = 0; Idx < (SeamrrSize - SeamldrData.PSysInfoTable->PSeamldrRange.Size) / PAGE2M; Idx++) {

  0009e	4c 8b 05 48 00
	00 00		 mov	 r8, QWORD PTR SeamldrData+72
  000a5	ff c5		 inc	 ebp
  000a7	49 8b ce	 mov	 rcx, r14
  000aa	8b c5		 mov	 eax, ebp

; 183  :         }
; 184  :         CurLinAddr += PAGE2M;

  000ac	49 03 fd	 add	 rdi, r13

; 185  :         CurPhysAddr += PAGE2M;

  000af	49 03 dd	 add	 rbx, r13
  000b2	49 03 f5	 add	 rsi, r13
  000b5	49 b9 63 00 00
	00 00 00 00 80	 mov	 r9, -9223372036854775709 ; 8000000000000063H
  000bf	49 2b 48 38	 sub	 rcx, QWORD PTR [r8+56]
  000c3	48 c1 e9 15	 shr	 rcx, 21
  000c7	48 3b c1	 cmp	 rax, rcx
  000ca	72 a8		 jb	 SHORT $LL4@MapModuleR
$LN24@MapModuleR:

; 182  :             return NP_SEAMLDR_PARAMS_STATUS_ENOMEM;

  000cc	48 8b 15 38 00
	00 00		 mov	 rdx, QWORD PTR SeamldrData+56
$LN3@MapModuleR:

; 186  :     }
; 187  :     
; 188  :     if (CurPhysAddr < SeamldrData.SeamrrBase + SeamldrData.SeamrrSize - SeamldrData.PSysInfoTable->PSeamldrRange.Size) {

  000d3	48 8b 0d 40 00
	00 00		 mov	 rcx, QWORD PTR SeamldrData+64
  000da	49 2b 48 38	 sub	 rcx, QWORD PTR [r8+56]
  000de	48 8d 04 11	 lea	 rax, QWORD PTR [rcx+rdx]
  000e2	48 3b d8	 cmp	 rbx, rax
  000e5	73 6f		 jae	 SHORT $LN6@MapModuleR

; 189  :         EndOf2MbMappingPhysAddr = CurPhysAddr;
; 190  :         for (Idx = 0; Idx < (SeamldrData.SeamrrBase + SeamldrData.SeamrrSize - SeamldrData.PSysInfoTable->PSeamldrRange.Size - EndOf2MbMappingPhysAddr) / PAGE4K; Idx++) {

  000e7	48 2b cb	 sub	 rcx, rbx
  000ea	33 ed		 xor	 ebp, ebp
  000ec	48 03 ca	 add	 rcx, rdx
  000ef	48 f7 c1 00 f0
	ff ff		 test	 rcx, -4096		; fffffffffffff000H
  000f6	76 5e		 jbe	 SHORT $LN6@MapModuleR
  000f8	48 8b f3	 mov	 rsi, rbx
  000fb	48 2b f7	 sub	 rsi, rdi
$LL7@MapModuleR:
  000fe	4c 8d 04 3e	 lea	 r8, QWORD PTR [rsi+rdi]

; 191  :             if (MapPage(SeamrrPtCtx, CurLinAddr, CurPhysAddr, IA32_PG_P | IA32_PG_RW | IA32_PG_A | IA32_PG_D | IA32_PG_NX, PAGE_4K, FALSE) == NULL) {

  00102	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  00107	83 64 24 20 00	 and	 DWORD PTR [rsp+32], 0
  0010c	48 8b d7	 mov	 rdx, rdi
  0010f	49 8b cf	 mov	 rcx, r15
  00112	e8 00 00 00 00	 call	 MapPage
  00117	48 85 c0	 test	 rax, rax
  0011a	74 5b		 je	 SHORT $LN16@MapModuleR

; 189  :         EndOf2MbMappingPhysAddr = CurPhysAddr;
; 190  :         for (Idx = 0; Idx < (SeamldrData.SeamrrBase + SeamldrData.SeamrrSize - SeamldrData.PSysInfoTable->PSeamldrRange.Size - EndOf2MbMappingPhysAddr) / PAGE4K; Idx++) {

  0011c	48 8b 05 48 00
	00 00		 mov	 rax, QWORD PTR SeamldrData+72
  00123	ff c5		 inc	 ebp
  00125	48 8b 0d 40 00
	00 00		 mov	 rcx, QWORD PTR SeamldrData+64

; 192  :                 return NP_SEAMLDR_PARAMS_STATUS_ENOMEM;
; 193  :             }
; 194  :             CurLinAddr += PAGE4K;

  0012c	48 81 c7 00 10
	00 00		 add	 rdi, 4096		; 00001000H
  00133	49 b9 63 00 00
	00 00 00 00 80	 mov	 r9, -9223372036854775709 ; 8000000000000063H
  0013d	48 2b 48 38	 sub	 rcx, QWORD PTR [rax+56]
  00141	48 2b cb	 sub	 rcx, rbx
  00144	8b c5		 mov	 eax, ebp
  00146	48 03 0d 38 00
	00 00		 add	 rcx, QWORD PTR SeamldrData+56
  0014d	48 c1 e9 0c	 shr	 rcx, 12
  00151	48 3b c1	 cmp	 rax, rcx
  00154	72 a8		 jb	 SHORT $LL7@MapModuleR
$LN6@MapModuleR:

; 195  :             CurPhysAddr += PAGE4K;
; 196  :         }
; 197  :     }
; 198  : 
; 199  :     return NP_SEAMLDR_PARAMS_STATUS_SUCCESS;

  00156	33 c0		 xor	 eax, eax
$LN1@MapModuleR:

; 200  : }

  00158	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0015d	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  00162	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  00167	48 8b 7c 24 68	 mov	 rdi, QWORD PTR [rsp+104]
  0016c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00170	41 5f		 pop	 r15
  00172	41 5e		 pop	 r14
  00174	41 5d		 pop	 r13
  00176	c3		 ret	 0
$LN16@MapModuleR:

; 182  :             return NP_SEAMLDR_PARAMS_STATUS_ENOMEM;

  00177	48 b8 02 00 01
	00 00 00 00 80	 mov	 rax, -9223372036854710270 ; 8000000000010002H
  00181	eb d5		 jmp	 SHORT $LN1@MapModuleR
MapModuleRegion ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File c:\users\jwhur\downloads\seam-loader\seam-loader-main-1.5\np-seam-loader\seamldr_src\core\commonseamldr64\seamldrcore64.c
;	COMDAT MapSysInfoTables
_TEXT	SEGMENT
SeamrrPtCtx$ = 64
MapSysInfoTables PROC					; COMDAT

; 154  : UINT64 MapSysInfoTables(SEAMRR_PT_CTX* SeamrrPtCtx) {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 155  :     UINT64 Status = NP_SEAMLDR_PARAMS_STATUS_SUCCESS;    
; 156  :     UINT64 CurPhysAddress = SeamldrData.SeamrrBase + SeamldrData.SeamrrSize - PAGE4K;

  00006	48 8b 05 40 00
	00 00		 mov	 rax, QWORD PTR SeamldrData+64
  0000d	33 db		 xor	 ebx, ebx
  0000f	4c 8b 05 38 00
	00 00		 mov	 r8, QWORD PTR SeamldrData+56
  00016	48 05 00 f0 ff
	ff		 add	 rax, -4096		; fffffffffffff000H

; 157  :     UINT64 CurLinAddress = C_SYS_INFO_TABLE_BASE | SeamldrData.AslrRand;

  0001c	48 8b 15 10 00
	00 00		 mov	 rdx, QWORD PTR SeamldrData+16
  00023	4c 03 c0	 add	 r8, rax
  00026	48 b8 00 00 ff
	ff 03 80 ff ff	 mov	 rax, -140720308551680	; ffff8003ffff0000H

; 158  : 
; 159  :     if (MapPage(SeamrrPtCtx, CurLinAddress, CurPhysAddress, IA32_PG_P | IA32_PG_A | IA32_PG_NX, PAGE_4K, FALSE) == NULL) {

  00030	88 5c 24 28	 mov	 BYTE PTR [rsp+40], bl
  00034	48 0b d0	 or	 rdx, rax
  00037	89 5c 24 20	 mov	 DWORD PTR [rsp+32], ebx
  0003b	49 b9 21 00 00
	00 00 00 00 80	 mov	 r9, -9223372036854775775 ; 8000000000000021H
  00045	e8 00 00 00 00	 call	 MapPage
  0004a	48 85 c0	 test	 rax, rax
  0004d	75 16		 jne	 SHORT $EXIT$6

; 160  :         Status = NP_SEAMLDR_PARAMS_STATUS_ENOMEM;
; 161  :         COMSERIALOUT("Failed to map sysinfo table!\n");

  0004f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BO@JDKLNIGF@Failed?5to?5map?5sysinfo?5table?$CB?6?$AA@IMHBAIGO@
  00056	48 bb 02 00 01
	00 00 00 00 80	 mov	 rbx, -9223372036854710270 ; 8000000000010002H
  00060	e8 00 00 00 00	 call	 ComSerialOut
$EXIT$6:

; 162  :         goto EXIT;
; 163  :     }
; 164  : 
; 165  : 
; 166  : EXIT:
; 167  :     return Status;

  00065	48 8b c3	 mov	 rax, rbx

; 168  : }

  00068	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0006c	5b		 pop	 rbx
  0006d	c3		 ret	 0
MapSysInfoTables ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File c:\users\jwhur\downloads\seam-loader\seam-loader-main-1.5\np-seam-loader\seamldr_src\core\commonseamldr64\seamldrcore64.c
;	COMDAT SetupDataRegion
_TEXT	SEGMENT
SeamrrPtCtx$ = 64
SetupDataRegion PROC					; COMDAT

; 138  : UINT64 SetupDataRegion(SEAMRR_PT_CTX *SeamrrPtCtx) {

$LN13:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 139  :     UINT64 CurLinAddr = C_DATA_RGN_BASE | SeamldrData.AslrRand;     

  00014	48 8b 1d 10 00
	00 00		 mov	 rbx, QWORD PTR SeamldrData+16
  0001b	48 b8 00 00 00
	00 03 80 ff ff	 mov	 rax, -140724603453440	; ffff800300000000H

; 140  :     UINT64 CurPhysAddr = SeamldrData.SeamrrBase + SeamldrData.SeamrrSize - (_4KB + SeamldrData.PSeamldrConsts->CCodeRgnSize + SeamldrData.PSeamldrConsts->CDataStackSize + C_P_SYS_INFO_TABLE_SIZE + SeamldrData.PSeamldrConsts->CDataRgnSize);

  00025	48 8b 15 40 00
	00 00		 mov	 rdx, QWORD PTR SeamldrData+64
  0002c	48 0b d8	 or	 rbx, rax
  0002f	48 8b 05 88 01
	00 00		 mov	 rax, QWORD PTR SeamldrData+392

; 141  :     UINT32 Idx;
; 142  : 
; 143  :     for (Idx = 0; Idx < SeamldrData.PSeamldrConsts->CDataRgnSize / SEAMRR_PAGE_SIZE; Idx++) {

  00036	33 ff		 xor	 edi, edi
  00038	48 8b 35 38 00
	00 00		 mov	 rsi, QWORD PTR SeamldrData+56
  0003f	48 8b e9	 mov	 rbp, rcx
  00042	48 81 c6 00 e0
	ff ff		 add	 rsi, -8192		; ffffffffffffe000H
  00049	48 2b 50 08	 sub	 rdx, QWORD PTR [rax+8]
  0004d	48 2b 50 10	 sub	 rdx, QWORD PTR [rax+16]
  00051	48 2b 10	 sub	 rdx, QWORD PTR [rax]
  00054	48 03 f2	 add	 rsi, rdx
  00057	48 f7 40 10 00
	f0 ff ff	 test	 QWORD PTR [rax+16], -4096 ; fffffffffffff000H
  0005f	76 4d		 jbe	 SHORT $LN3@SetupDataR
$LL4@SetupDataR:

; 144  :         if (MapPage(SeamrrPtCtx, CurLinAddr, CurPhysAddr, IA32_PG_P | IA32_PG_RW | IA32_PG_A | IA32_PG_D | IA32_PG_NX, PAGE_4K, FALSE) == NULL) {

  00061	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  00066	49 b9 63 00 00
	00 00 00 00 80	 mov	 r9, -9223372036854775709 ; 8000000000000063H
  00070	83 64 24 20 00	 and	 DWORD PTR [rsp+32], 0
  00075	4c 8b c6	 mov	 r8, rsi
  00078	48 8b d3	 mov	 rdx, rbx
  0007b	48 8b cd	 mov	 rcx, rbp
  0007e	e8 00 00 00 00	 call	 MapPage
  00083	48 85 c0	 test	 rax, rax
  00086	74 3d		 je	 SHORT $LN8@SetupDataR

; 141  :     UINT32 Idx;
; 142  : 
; 143  :     for (Idx = 0; Idx < SeamldrData.PSeamldrConsts->CDataRgnSize / SEAMRR_PAGE_SIZE; Idx++) {

  00088	48 8b 05 88 01
	00 00		 mov	 rax, QWORD PTR SeamldrData+392
  0008f	ff c7		 inc	 edi

; 146  :         }          
; 147  :         CurLinAddr += SEAMRR_PAGE_SIZE;

  00091	48 81 c3 00 10
	00 00		 add	 rbx, 4096		; 00001000H

; 148  :         CurPhysAddr += SEAMRR_PAGE_SIZE;

  00098	48 81 c6 00 10
	00 00		 add	 rsi, 4096		; 00001000H
  0009f	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  000a3	48 c1 e9 0c	 shr	 rcx, 12
  000a7	8b c7		 mov	 eax, edi
  000a9	48 3b c1	 cmp	 rax, rcx
  000ac	72 b3		 jb	 SHORT $LL4@SetupDataR
$LN3@SetupDataR:

; 149  :     }
; 150  : 
; 151  :     return NP_SEAMLDR_PARAMS_STATUS_SUCCESS;

  000ae	33 c0		 xor	 eax, eax
$LN1@SetupDataR:

; 152  : }

  000b0	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000b5	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000ba	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  000bf	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000c3	5f		 pop	 rdi
  000c4	c3		 ret	 0
$LN8@SetupDataR:

; 145  :             return NP_SEAMLDR_PARAMS_STATUS_ENOMEM;

  000c5	48 b8 02 00 01
	00 00 00 00 80	 mov	 rax, -9223372036854710270 ; 8000000000010002H
  000cf	eb df		 jmp	 SHORT $LN1@SetupDataR
SetupDataRegion ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File c:\users\jwhur\downloads\seam-loader\seam-loader-main-1.5\np-seam-loader\seamldr_src\core\commonseamldr64\seamldrcore64.c
;	COMDAT SetupKeyholeMapping
_TEXT	SEGMENT
SeamrrPtCtx$ = 80
SetupKeyholeMapping PROC				; COMDAT

; 110  : UINT64 SetupKeyholeMapping(SEAMRR_PT_CTX *SeamrrPtCtx) {

$LN17:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	41 56		 push	 r14
  00012	41 57		 push	 r15
  00014	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 111  :     UINT64 CurLinAddr = C_KEYHOLE_RGN_BASE | SeamldrData.AslrRand;

  00018	48 8b 1d 10 00
	00 00		 mov	 rbx, QWORD PTR SeamldrData+16
  0001f	48 b8 00 00 00
	00 02 80 ff ff	 mov	 rax, -140728898420736	; ffff800200000000H
  00029	48 8b f3	 mov	 rsi, rbx

; 112  :     UINT64 PrevMappedPtPa = (UINT64)-1;

  0002c	49 83 ce ff	 or	 r14, -1
  00030	48 0b f0	 or	 rsi, rax

; 113  :     UINT64 CurMappedPtPa = (UINT64)NULL;
; 114  :     UINT64 CurEditRgnLinAddr = C_KEYHOLE_EDIT_REGION_BASE | SeamldrData.AslrRand;
; 115  :     UINT32 Idx;
; 116  : 
; 117  :       
; 118  :     for (Idx = 0; Idx < SeamldrData.PSeamldrConsts->CKeyholeRgnSize / SEAMRR_PAGE_SIZE; Idx++) {

  00033	33 ed		 xor	 ebp, ebp
  00035	48 b8 00 00 00
	00 01 00 00 00	 mov	 rax, 4294967296		; 0000000100000000H
  0003f	4c 8b f9	 mov	 r15, rcx
  00042	48 0b d8	 or	 rbx, rax
  00045	48 8b 05 88 01
	00 00		 mov	 rax, QWORD PTR SeamldrData+392
  0004c	48 f7 40 18 00
	f0 ff ff	 test	 QWORD PTR [rax+24], -4096 ; fffffffffffff000H
  00054	76 78		 jbe	 SHORT $LN3@SetupKeyho
$LL4@SetupKeyho:

; 119  :         CurMappedPtPa = (UINT64)MapPage(SeamrrPtCtx, CurLinAddr, 0, 0, PAGE_4K, TRUE);

  00056	c6 44 24 28 01	 mov	 BYTE PTR [rsp+40], 1
  0005b	45 33 c9	 xor	 r9d, r9d
  0005e	83 64 24 20 00	 and	 DWORD PTR [rsp+32], 0
  00063	45 33 c0	 xor	 r8d, r8d
  00066	48 8b d6	 mov	 rdx, rsi
  00069	49 8b cf	 mov	 rcx, r15
  0006c	e8 00 00 00 00	 call	 MapPage
  00071	48 8b f8	 mov	 rdi, rax

; 120  :         if (CurMappedPtPa == (UINT64) NULL) {

  00074	48 85 c0	 test	 rax, rax
  00077	74 70		 je	 SHORT $LN10@SetupKeyho

; 122  :         }
; 123  :         if (CurMappedPtPa != PrevMappedPtPa) {

  00079	49 3b c6	 cmp	 rax, r14
  0007c	74 31		 je	 SHORT $LN6@SetupKeyho

; 124  :             if (MapPage(SeamrrPtCtx, CurEditRgnLinAddr, CurMappedPtPa,
; 125  :                 IA32_PG_P | IA32_PG_RW | IA32_PG_U | IA32_PG_A | IA32_PG_D | IA32_PG_NX, PAGE_4K, FALSE) == NULL) {

  0007e	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  00083	49 b9 67 00 00
	00 00 00 00 80	 mov	 r9, -9223372036854775705 ; 8000000000000067H
  0008d	83 64 24 20 00	 and	 DWORD PTR [rsp+32], 0
  00092	4c 8b c0	 mov	 r8, rax
  00095	48 8b d3	 mov	 rdx, rbx
  00098	49 8b cf	 mov	 rcx, r15
  0009b	e8 00 00 00 00	 call	 MapPage
  000a0	48 85 c0	 test	 rax, rax
  000a3	74 44		 je	 SHORT $LN10@SetupKeyho

; 126  :                 return NP_SEAMLDR_PARAMS_STATUS_ENOMEM;
; 127  :             }
; 128  : 
; 129  :             PrevMappedPtPa = CurMappedPtPa;

  000a5	4c 8b f7	 mov	 r14, rdi

; 130  :             CurEditRgnLinAddr += SEAMRR_PAGE_SIZE;

  000a8	48 81 c3 00 10
	00 00		 add	 rbx, 4096		; 00001000H
$LN6@SetupKeyho:

; 113  :     UINT64 CurMappedPtPa = (UINT64)NULL;
; 114  :     UINT64 CurEditRgnLinAddr = C_KEYHOLE_EDIT_REGION_BASE | SeamldrData.AslrRand;
; 115  :     UINT32 Idx;
; 116  : 
; 117  :       
; 118  :     for (Idx = 0; Idx < SeamldrData.PSeamldrConsts->CKeyholeRgnSize / SEAMRR_PAGE_SIZE; Idx++) {

  000af	48 8b 05 88 01
	00 00		 mov	 rax, QWORD PTR SeamldrData+392
  000b6	ff c5		 inc	 ebp

; 131  :         }
; 132  :         CurLinAddr += SEAMRR_PAGE_SIZE;

  000b8	48 81 c6 00 10
	00 00		 add	 rsi, 4096		; 00001000H
  000bf	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  000c3	48 c1 e9 0c	 shr	 rcx, 12
  000c7	8b c5		 mov	 eax, ebp
  000c9	48 3b c1	 cmp	 rax, rcx
  000cc	72 88		 jb	 SHORT $LL4@SetupKeyho
$LN3@SetupKeyho:

; 133  :     }
; 134  : 
; 135  :     return NP_SEAMLDR_PARAMS_STATUS_SUCCESS;

  000ce	33 c0		 xor	 eax, eax
$LN1@SetupKeyho:

; 136  : }

  000d0	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  000d5	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  000da	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  000df	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000e3	41 5f		 pop	 r15
  000e5	41 5e		 pop	 r14
  000e7	5f		 pop	 rdi
  000e8	c3		 ret	 0
$LN10@SetupKeyho:

; 121  :             return NP_SEAMLDR_PARAMS_STATUS_ENOMEM;

  000e9	48 b8 02 00 01
	00 00 00 00 80	 mov	 rax, -9223372036854710270 ; 8000000000010002H
  000f3	eb db		 jmp	 SHORT $LN1@SetupKeyho
SetupKeyholeMapping ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File c:\users\jwhur\downloads\seam-loader\seam-loader-main-1.5\np-seam-loader\seamldr_src\core\commonseamldr64\seamldrcore64.c
;	COMDAT SetupStacks
_TEXT	SEGMENT
SeamrrPtCtx$ = 64
SetupStacks PROC					; COMDAT

; 87   : UINT64 SetupStacks(SEAMRR_PT_CTX *SeamrrPtCtx) {

$LN14:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 88   :     UINT32 StkPageIdx;
; 89   :     UINT64 CurLinAddr = C_STACK_RGN_BASE | SeamldrData.AslrRand;
; 90   :     UINT64 CurPhysAddr;
; 91   :     
; 92   :     CurPhysAddr = SeamldrData.SeamrrBase + SeamldrData.SeamrrSize - C_P_SYS_INFO_TABLE_SIZE - (SeamldrData.PSeamldrConsts->CCodeRgnSize) - (SeamldrData.PSeamldrConsts->CDataStackSize) - P_SEAMLDR_SHADOW_STACK_SIZE;

  00014	4c 8b 05 88 01
	00 00		 mov	 r8, QWORD PTR SeamldrData+392
  0001b	48 b8 00 00 00
	00 01 80 ff ff	 mov	 rax, -140733193388032	; ffff800100000000H
  00025	48 8b 15 40 00
	00 00		 mov	 rdx, QWORD PTR SeamldrData+64

; 93   : 
; 94   :     for (StkPageIdx = 0; StkPageIdx < (UINT32)SeamldrData.PSeamldrConsts->CDataStackSize / SEAMRR_PAGE_SIZE; StkPageIdx++) {

  0002c	33 f6		 xor	 esi, esi
  0002e	48 8b 3d 38 00
	00 00		 mov	 rdi, QWORD PTR SeamldrData+56
  00035	48 8b e9	 mov	 rbp, rcx
  00038	48 8b 1d 10 00
	00 00		 mov	 rbx, QWORD PTR SeamldrData+16
  0003f	48 81 c7 00 e0
	ff ff		 add	 rdi, -8192		; ffffffffffffe000H
  00046	49 2b 50 08	 sub	 rdx, QWORD PTR [r8+8]
  0004a	48 0b d8	 or	 rbx, rax
  0004d	49 2b 10	 sub	 rdx, QWORD PTR [r8]
  00050	48 03 fa	 add	 rdi, rdx
  00053	41 f7 00 00 f0
	ff ff		 test	 DWORD PTR [r8], -4096	; fffff000H
  0005a	76 47		 jbe	 SHORT $LN3@SetupStack
$LL4@SetupStack:

; 95   :         if (MapPage(SeamrrPtCtx, CurLinAddr, CurPhysAddr, IA32_PG_RW | IA32_PG_A | IA32_PG_D | IA32_PG_NX | IA32_PG_P, PAGE_4K, FALSE) == NULL) {

  0005c	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  00061	49 b9 63 00 00
	00 00 00 00 80	 mov	 r9, -9223372036854775709 ; 8000000000000063H
  0006b	83 64 24 20 00	 and	 DWORD PTR [rsp+32], 0
  00070	4c 8b c7	 mov	 r8, rdi
  00073	48 8b d3	 mov	 rdx, rbx
  00076	48 8b cd	 mov	 rcx, rbp
  00079	e8 00 00 00 00	 call	 MapPage
  0007e	48 85 c0	 test	 rax, rax
  00081	74 6d		 je	 SHORT $LN9@SetupStack

; 97   :         }
; 98   :         CurLinAddr += SEAMRR_PAGE_SIZE;

  00083	48 8b 05 88 01
	00 00		 mov	 rax, QWORD PTR SeamldrData+392
  0008a	48 81 c3 00 10
	00 00		 add	 rbx, 4096		; 00001000H

; 99   :         CurPhysAddr += SEAMRR_PAGE_SIZE;

  00091	48 81 c7 00 10
	00 00		 add	 rdi, 4096		; 00001000H
  00098	ff c6		 inc	 esi
  0009a	8b 08		 mov	 ecx, DWORD PTR [rax]
  0009c	c1 e9 0c	 shr	 ecx, 12
  0009f	3b f1		 cmp	 esi, ecx
  000a1	72 b9		 jb	 SHORT $LL4@SetupStack
$LN3@SetupStack:

; 100  :     }
; 101  :     // shadow stack page
; 102  :     if (MapPage(SeamrrPtCtx, CurLinAddr, CurPhysAddr, IA32_PG_A | IA32_PG_D | IA32_PG_NX | IA32_PG_P, PAGE_4K, FALSE) == NULL) {

  000a3	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  000a8	49 b9 61 00 00
	00 00 00 00 80	 mov	 r9, -9223372036854775711 ; 8000000000000061H
  000b2	83 64 24 20 00	 and	 DWORD PTR [rsp+32], 0
  000b7	4c 8b c7	 mov	 r8, rdi
  000ba	48 8b d3	 mov	 rdx, rbx
  000bd	48 8b cd	 mov	 rcx, rbp
  000c0	e8 00 00 00 00	 call	 MapPage
  000c5	48 f7 d8	 neg	 rax
  000c8	48 b9 02 00 01
	00 00 00 00 80	 mov	 rcx, -9223372036854710270 ; 8000000000010002H
  000d2	48 1b c0	 sbb	 rax, rax
  000d5	48 f7 d0	 not	 rax
  000d8	48 23 c1	 and	 rax, rcx
$LN6@SetupStack:

; 103  :         return NP_SEAMLDR_PARAMS_STATUS_ENOMEM;
; 104  :     }
; 105  :     
; 106  :     return NP_SEAMLDR_PARAMS_STATUS_SUCCESS;
; 107  : }

  000db	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000e0	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000e5	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  000ea	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000ee	5f		 pop	 rdi
  000ef	c3		 ret	 0
$LN9@SetupStack:

; 96   :             return NP_SEAMLDR_PARAMS_STATUS_ENOMEM;

  000f0	48 b8 02 00 01
	00 00 00 00 80	 mov	 rax, -9223372036854710270 ; 8000000000010002H
  000fa	eb df		 jmp	 SHORT $LN6@SetupStack
SetupStacks ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File c:\users\jwhur\downloads\seam-loader\seam-loader-main-1.5\np-seam-loader\seamldr_src\core\commonseamldr64\seamldrcore64.c
;	COMDAT MapModulePages
_TEXT	SEGMENT
SeamrrPtCtx$ = 64
ModuleSize$ = 72
MapModulePages PROC					; COMDAT

; 69   : UINT64 MapModulePages(SEAMRR_PT_CTX * SeamrrPtCtx, UINT32 ModuleSize) {

$LN13:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000f	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  00013	41 56		 push	 r14
  00015	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 70   :     UINT64 CurCodeLinearAddr = C_CODE_RGN_BASE | SeamldrData.AslrRand;

  00019	48 8b 1d 10 00
	00 00		 mov	 rbx, QWORD PTR SeamldrData+16
  00020	48 b8 00 00 00
	00 00 80 ff ff	 mov	 rax, -140737488355328	; ffff800000000000H

; 71   :     UINT64 CurCodePhysicalAddr;
; 72   :     uint32_t Idx;
; 73   :         
; 74   :     CurCodePhysicalAddr = SeamldrData.SeamrrBase + SeamldrData.SeamrrSize - (SeamldrData.PSeamldrConsts->CCodeRgnSize + C_P_SYS_INFO_TABLE_SIZE);

  0002a	4c 8b 05 40 00
	00 00		 mov	 r8, QWORD PTR SeamldrData+64
  00031	48 0b d8	 or	 rbx, rax
  00034	48 8b 05 88 01
	00 00		 mov	 rax, QWORD PTR SeamldrData+392
  0003b	8b ea		 mov	 ebp, edx
  0003d	48 8b 35 38 00
	00 00		 mov	 rsi, QWORD PTR SeamldrData+56

; 75   :     
; 76   :     for (Idx = 0; Idx < ModuleSize / MOD_PAGE_SIZE; Idx++) {

  00044	33 ff		 xor	 edi, edi
  00046	48 81 c6 00 f0
	ff ff		 add	 rsi, -4096		; fffffffffffff000H
  0004d	c1 ed 0c	 shr	 ebp, 12
  00050	4c 8b f1	 mov	 r14, rcx
  00053	4c 2b 40 08	 sub	 r8, QWORD PTR [rax+8]
  00057	49 03 f0	 add	 rsi, r8
  0005a	85 ed		 test	 ebp, ebp
  0005c	74 37		 je	 SHORT $LN3@MapModuleP
$LL4@MapModuleP:

; 77   :         if (MapPage(SeamrrPtCtx, CurCodeLinearAddr, CurCodePhysicalAddr, IA32_PG_A | IA32_PG_P, PAGE_4K, FALSE) == NULL) {

  0005e	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  00063	41 b9 21 00 00
	00		 mov	 r9d, 33			; 00000021H
  00069	83 64 24 20 00	 and	 DWORD PTR [rsp+32], 0
  0006e	4c 8b c6	 mov	 r8, rsi
  00071	48 8b d3	 mov	 rdx, rbx
  00074	49 8b ce	 mov	 rcx, r14
  00077	e8 00 00 00 00	 call	 MapPage
  0007c	48 85 c0	 test	 rax, rax
  0007f	74 31		 je	 SHORT $LN8@MapModuleP

; 80   :         }
; 81   :         CurCodeLinearAddr += SEAMRR_PAGE_SIZE;

  00081	48 81 c3 00 10
	00 00		 add	 rbx, 4096		; 00001000H

; 82   :         CurCodePhysicalAddr += SEAMRR_PAGE_SIZE;

  00088	48 81 c6 00 10
	00 00		 add	 rsi, 4096		; 00001000H
  0008f	ff c7		 inc	 edi
  00091	3b fd		 cmp	 edi, ebp
  00093	72 c9		 jb	 SHORT $LL4@MapModuleP
$LN3@MapModuleP:

; 83   :     }    
; 84   :     return NP_SEAMLDR_PARAMS_STATUS_SUCCESS;

  00095	33 c0		 xor	 eax, eax
$LN1@MapModuleP:

; 85   : }

  00097	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0009c	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000a1	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  000a6	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  000ab	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000af	41 5e		 pop	 r14
  000b1	c3		 ret	 0
$LN8@MapModuleP:

; 78   : 
; 79   :             return NP_SEAMLDR_PARAMS_STATUS_ENOMEM;

  000b2	48 b8 02 00 01
	00 00 00 00 80	 mov	 rax, -9223372036854710270 ; 8000000000010002H
  000bc	eb d9		 jmp	 SHORT $LN1@MapModuleP
MapModulePages ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File c:\users\jwhur\downloads\seam-loader\seam-loader-main-1.5\np-seam-loader\seamldr_src\core\commonseamldr64\seamldrcore64.c
;	COMDAT LoadModuleCode
_TEXT	SEGMENT
Module$ = 8
ModuleSize$ = 16
LoadModuleCode PROC					; COMDAT

; 62   :     UINT64 Status = NP_SEAMLDR_PARAMS_STATUS_SUCCESS;
; 63   : 
; 64   :     Status = memcpy_s((void *)(SeamldrData.SeamrrVaLimit - (SeamldrData.PSeamldrConsts->CCodeRgnSize + C_P_SYS_INFO_TABLE_SIZE)), SeamldrData.PSeamldrConsts->CCodeRgnSize, Module, ModuleSize);

  00000	48 8b 05 88 01
	00 00		 mov	 rax, QWORD PTR SeamldrData+392
  00007	4c 8b c1	 mov	 r8, rcx

; 65   : 
; 66   :     return Status;

  0000a	48 8b 0d 08 00
	00 00		 mov	 rcx, QWORD PTR SeamldrData+8
  00011	44 8b ca	 mov	 r9d, edx
  00014	48 2b 48 08	 sub	 rcx, QWORD PTR [rax+8]
  00018	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0001c	48 81 e9 00 10
	00 00		 sub	 rcx, 4096		; 00001000H
  00023	e9 00 00 00 00	 jmp	 memcpy_s
LoadModuleCode ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File c:\users\jwhur\downloads\seam-loader\seam-loader-main-1.5\np-seam-loader\seamldr_src\core\commonseamldr64\seamldrcore64.c
;	COMDAT GetX2ApicId
_TEXT	SEGMENT
CpuidEdx$ = 64
GetX2ApicId PROC					; COMDAT

; 53   : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 54   :     UINT32 CpuidEdx;
; 55   : 
; 56   :     CpuidEx(CPUID_V2_EXTENDED_TOPOLOGY, CPUID_EXTENDED_TOPOLOGY_LEVEL_TYPE_SMT, NULL, NULL, NULL, &CpuidEdx);

  00004	45 33 c9	 xor	 r9d, r9d
  00007	48 8d 44 24 40	 lea	 rax, QWORD PTR CpuidEdx$[rsp]
  0000c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00011	45 33 c0	 xor	 r8d, r8d
  00014	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  0001a	41 8d 51 01	 lea	 edx, QWORD PTR [r9+1]
  0001e	8d 4a 1e	 lea	 ecx, QWORD PTR [rdx+30]
  00021	e8 00 00 00 00	 call	 CpuidEx

; 57   : 
; 58   :     return CpuidEdx;

  00026	8b 44 24 40	 mov	 eax, DWORD PTR CpuidEdx$[rsp]

; 59   : }

  0002a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0002e	c3		 ret	 0
GetX2ApicId ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File c:\users\jwhur\downloads\seam-loader\seam-loader-main-1.5\np-seam-loader\seamldr_src\core\commonseamldr64\seamldrcore64.c
;	COMDAT MemZeroWithMovdir64B
_TEXT	SEGMENT
ZeroBlock$ = 0
dst$ = 176
size$ = 184
MemZeroWithMovdir64B PROC				; COMDAT

; 39   : void MemZeroWithMovdir64B(UINT8* dst, UINT64 size) {

$LN11:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 70 10	 mov	 QWORD PTR [rax+16], rsi
  0000b	48 89 78 18	 mov	 QWORD PTR [rax+24], rdi
  0000f	55		 push	 rbp
  00010	48 81 ec a0 00
	00 00		 sub	 rsp, 160		; 000000a0H
  00017	48 8d 68 b8	 lea	 rbp, QWORD PTR [rax-72]
  0001b	48 83 e5 c0	 and	 rbp, -64		; ffffffffffffffc0H
  0001f	48 8b f2	 mov	 rsi, rdx
  00022	48 8b f9	 mov	 rdi, rcx
  00025	33 d2		 xor	 edx, edx
  00027	48 8d 4d 00	 lea	 rcx, QWORD PTR ZeroBlock$[rbp]
  0002b	44 8d 42 40	 lea	 r8d, QWORD PTR [rdx+64]
  0002f	e8 00 00 00 00	 call	 memset

; 40   :     __declspec(align(MOVDIR64B_BLOCK_SIZE)) UINT8 ZeroBlock[MOVDIR64B_BLOCK_SIZE] = { 0 };
; 41   :     UINT64 NumOfBlocks = size / MOVDIR64B_BLOCK_SIZE;

  00034	48 c1 ee 06	 shr	 rsi, 6

; 42   : 
; 43   :     for (UINT32 Idx = 0; Idx < NumOfBlocks; Idx++) {

  00038	33 db		 xor	 ebx, ebx
  0003a	48 85 f6	 test	 rsi, rsi
  0003d	74 19		 je	 SHORT $LN3@MemZeroWit
$LL4@MemZeroWit:

; 44   :         Movdir64B(ZeroBlock, dst);

  0003f	48 8b d7	 mov	 rdx, rdi
  00042	48 8d 4d 00	 lea	 rcx, QWORD PTR ZeroBlock$[rbp]
  00046	e8 00 00 00 00	 call	 Movdir64B
  0004b	ff c3		 inc	 ebx

; 45   :         dst += MOVDIR64B_BLOCK_SIZE;

  0004d	48 83 c7 40	 add	 rdi, 64			; 00000040H
  00051	8b c3		 mov	 eax, ebx
  00053	48 3b c6	 cmp	 rax, rsi
  00056	72 e7		 jb	 SHORT $LL4@MemZeroWit
$LN3@MemZeroWit:

; 46   :     }
; 47   :         
; 48   : 
; 49   :     _mm_sfence();

  00058	0f ae f8	 sfence

; 50   : }

  0005b	4c 8d 9c 24 a0
	00 00 00	 lea	 r11, QWORD PTR [rsp+160]
  00063	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  00067	49 8b 73 18	 mov	 rsi, QWORD PTR [r11+24]
  0006b	49 8b 7b 20	 mov	 rdi, QWORD PTR [r11+32]
  0006f	49 8b e3	 mov	 rsp, r11
  00072	5d		 pop	 rbp
  00073	c3		 ret	 0
MemZeroWithMovdir64B ENDP
_TEXT	ENDS
END

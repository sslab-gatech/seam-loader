; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24245.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	MapPhysicalRange
PUBLIC	RemoveLinearMapping
PUBLIC	??_C@_0CK@HIHMONIC@No?5free?52MB?5entries?5left?5to?5map?5@IMHBAIGO@ ;  ?? ::IMHBAIGO::`string'
PUBLIC	??_C@_0CK@BFFOGJBM@No?5free?54KB?5entries?5left?5to?5map?5@IMHBAIGO@ ;  ?? ::IMHBAIGO::`string'
EXTRN	ComSerialOut:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$MapPhysicalRange DD imagerel $LN27
	DD	imagerel $LN27+341
	DD	imagerel $unwind$MapPhysicalRange
pdata	ENDS
;	COMDAT ??_C@_0CK@BFFOGJBM@No?5free?54KB?5entries?5left?5to?5map?5@IMHBAIGO@
EDATA32	SEGMENT
??_C@_0CK@BFFOGJBM@No?5free?54KB?5entries?5left?5to?5map?5@IMHBAIGO@ DB 'N'
	DB	'o free 4KB entries left to map the range', 00H ;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT ??_C@_0CK@HIHMONIC@No?5free?52MB?5entries?5left?5to?5map?5@IMHBAIGO@
EDATA32	SEGMENT
??_C@_0CK@HIHMONIC@No?5free?52MB?5entries?5left?5to?5map?5@IMHBAIGO@ DB 'N'
	DB	'o free 2MB entries left to map the range', 00H ;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$MapPhysicalRange DD 0a1801H
	DD	0a6418H
	DD	095418H
	DD	083418H
	DD	0f0143218H
	DD	07010e012H
xdata	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\commonseamldr64\acmpaging64.c
;	COMDAT Map2MBPage
_TEXT	SEGMENT
LeafPXE$ = 8
PhysBase$ = 16
IsWritable$ = 24
IsWBMemtype$ = 32
Map2MBPage PROC						; COMDAT

; 50   :     if (LeafPXE->Raw != 0) {

  00000	45 33 d2	 xor	 r10d, r10d
  00003	4c 39 11	 cmp	 QWORD PTR [rcx], r10
  00006	74 02		 je	 SHORT $LN2@Map2MBPage

; 51   :         TXT_SHUTDOWN();

  00008	0f 0b		 ud2
$LN2@Map2MBPage:
  0000a	41 83 f8 01	 cmp	 r8d, 1

; 52   :     }
; 53   : 
; 54   :     LeafPXE->Raw = PhysBase;

  0000e	48 89 11	 mov	 QWORD PTR [rcx], rdx
  00011	b8 02 00 00 00	 mov	 eax, 2
  00016	44 0f 44 d0	 cmove	 r10d, eax

; 55   :     LeafPXE->Fields2M.P = 1;
; 56   :     LeafPXE->Fields2M.RW = (IsWritable == PAGE_WRITABLE) ? 1 : 0;
; 57   :     LeafPXE->Fields2M.A = 1;
; 58   :     LeafPXE->Fields2M.D = 1;
; 59   :     LeafPXE->Fields2M.Leaf = 1;

  0001a	8b c2		 mov	 eax, edx
  0001c	83 e0 fd	 and	 eax, -3			; fffffffdH
  0001f	44 0b d0	 or	 r10d, eax
  00022	41 81 ca e1 00
	00 00		 or	 r10d, 225		; 000000e1H
  00029	44 89 11	 mov	 DWORD PTR [rcx], r10d

; 60   : 
; 61   :     if (IsWBMemtype == PAGE_WB_MEMTYPE) {

  0002c	41 83 f9 01	 cmp	 r9d, 1
  00030	75 09		 jne	 SHORT $LN3@Map2MBPage

; 62   :         // PAT0 is supposed to be WB memtype
; 63   :         LeafPXE->Fields2M.PAT = 0;
; 64   :         LeafPXE->Fields2M.PWT = 0;
; 65   :         LeafPXE->Fields2M.PCD = 0;

  00032	41 81 e2 e7 ef
	ff ff		 and	 r10d, -4121		; ffffefe7H

; 66   :     }

  00039	eb 07		 jmp	 SHORT $LN6@Map2MBPage
$LN3@Map2MBPage:

; 67   :     else {
; 68   :         // PAT7 is supposed to be UC memtype
; 69   :         LeafPXE->Fields2M.PAT = 1;
; 70   :         LeafPXE->Fields2M.PWT = 1;
; 71   :         LeafPXE->Fields2M.PCD = 1;

  0003b	41 81 ca 18 10
	00 00		 or	 r10d, 4120		; 00001018H
$LN6@Map2MBPage:
  00042	44 89 11	 mov	 DWORD PTR [rcx], r10d

; 72   :     }
; 73   : }

  00045	c3		 ret	 0
Map2MBPage ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\commonseamldr64\acmpaging64.c
;	COMDAT Map4KPage
_TEXT	SEGMENT
LeafPXE$ = 8
PhysBase$ = 16
IsWritable$ = 24
IsWBMemtype$ = 32
Map4KPage PROC						; COMDAT

; 24   :     if (LeafPXE->Raw != 0) {

  00000	45 33 d2	 xor	 r10d, r10d
  00003	4c 39 11	 cmp	 QWORD PTR [rcx], r10
  00006	74 02		 je	 SHORT $LN2@Map4KPage

; 25   :         TXT_SHUTDOWN();

  00008	0f 0b		 ud2
$LN2@Map4KPage:
  0000a	41 83 f8 01	 cmp	 r8d, 1

; 26   :     }
; 27   : 
; 28   :     LeafPXE->Raw = PhysBase;

  0000e	48 89 11	 mov	 QWORD PTR [rcx], rdx
  00011	b8 02 00 00 00	 mov	 eax, 2
  00016	44 0f 44 d0	 cmove	 r10d, eax

; 29   :     LeafPXE->Fields4K.P = 1;
; 30   :     LeafPXE->Fields4K.RW = (IsWritable == PAGE_WRITABLE) ? 1 : 0;
; 31   :     LeafPXE->Fields4K.A = 1;
; 32   :     LeafPXE->Fields4K.D = 1;

  0001a	8b c2		 mov	 eax, edx
  0001c	83 e0 fd	 and	 eax, -3			; fffffffdH
  0001f	44 0b d0	 or	 r10d, eax
  00022	41 83 ca 61	 or	 r10d, 97		; 00000061H
  00026	44 89 11	 mov	 DWORD PTR [rcx], r10d

; 33   : 
; 34   :     if (IsWBMemtype == PAGE_WB_MEMTYPE) {

  00029	41 83 f9 01	 cmp	 r9d, 1
  0002d	75 09		 jne	 SHORT $LN3@Map4KPage

; 35   :         // PAT0 is supposed to be WB memtype
; 36   :         LeafPXE->Fields4K.PAT = 0;
; 37   :         LeafPXE->Fields4K.PWT = 0;
; 38   :         LeafPXE->Fields4K.PCD = 0;

  0002f	41 81 e2 67 ff
	ff ff		 and	 r10d, -153		; ffffff67H

; 39   :     }

  00036	eb 07		 jmp	 SHORT $LN6@Map4KPage
$LN3@Map4KPage:

; 40   :     else {
; 41   :         // PAT7 is supposed to be UC memtype
; 42   :         LeafPXE->Fields4K.PAT = 1;
; 43   :         LeafPXE->Fields4K.PWT = 1;
; 44   :         LeafPXE->Fields4K.PCD = 1;

  00038	41 81 ca 98 00
	00 00		 or	 r10d, 152		; 00000098H
$LN6@Map4KPage:
  0003f	44 89 11	 mov	 DWORD PTR [rcx], r10d

; 45   :     }
; 46   : }

  00042	c3		 ret	 0
Map4KPage ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\commonseamldr64\acmpaging64.c
;	COMDAT RemoveLinearMapping
_TEXT	SEGMENT
pctx$ = 8
LinearAddr$ = 16
LargePageMapping$ = 24
RemoveLinearMapping PROC				; COMDAT

; 127  :     IA32E_PAGING_TABLE_T* Pt;
; 128  :     UINT64 idx;
; 129  : 
; 130  :     if (LargePageMapping) {

  00000	45 84 c0	 test	 r8b, r8b

; 131  :         Pt = (IA32E_PAGING_TABLE_T*)pctx->PdBaseFor2MBMappings;
; 132  :         idx = (LinearAddr >> 21) & 0x1FF;

  00003	4c 8b c2	 mov	 r8, rdx
  00006	74 0a		 je	 SHORT $LN2@RemoveLine
  00008	48 83 c1 08	 add	 rcx, 8
  0000c	49 c1 e8 15	 shr	 r8, 21

; 133  :     }

  00010	eb 04		 jmp	 SHORT $LN3@RemoveLine
$LN2@RemoveLine:

; 134  :     else {
; 135  :         Pt = (IA32E_PAGING_TABLE_T*)pctx->PtBaseFor4KMappings;
; 136  :         idx = (LinearAddr >> 12) & 0x1FF;

  00012	49 c1 e8 0c	 shr	 r8, 12
$LN3@RemoveLine:

; 137  :     }
; 138  : 
; 139  :     Pt->PT[idx].Raw = 0;

  00016	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00019	41 81 e0 ff 01
	00 00		 and	 r8d, 511		; 000001ffH
  00020	4a 83 24 c0 00	 and	 QWORD PTR [rax+r8*8], 0

; 140  : 
; 141  :     __invlpg((void*)LinearAddr);

  00025	0f 01 3a	 invlpg	 BYTE PTR [rdx]

; 142  : }

  00028	c3		 ret	 0
RemoveLinearMapping ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\commonseamldr64\acmpaging64.c
;	COMDAT MapPhysicalRange
_TEXT	SEGMENT
pctx$ = 64
Addr$ = 72
size$ = 80
IsWritable$ = 88
PageMappingSize$ = 96
IsWBMemtype$ = 104
MapPhysicalRange PROC					; COMDAT

; 76   : {

$LN27:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	41 56		 push	 r14
  00012	41 57		 push	 r15
  00014	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 77   :     UINT32 i = 0;
; 78   :     UINT32 PagesToMap = 0;
; 79   :     UINT64 Base = 0;
; 80   :     UINT64 VirtualAddr = 0;
; 81   :     UINT64 OffsetInPage = 0;
; 82   : 
; 83   :     if (PageMappingSize == PAGE_2M) {

  00018	83 7c 24 60 01	 cmp	 DWORD PTR PageMappingSize$[rsp], 1
  0001d	41 8b e9	 mov	 ebp, r9d
  00020	4c 8b d2	 mov	 r10, rdx
  00023	4c 8b d9	 mov	 r11, rcx

; 84   : 
; 85   :         Base = Addr & _2MB_MASK;

  00026	48 8b fa	 mov	 rdi, rdx
  00029	0f 85 8d 00 00
	00		 jne	 $LN8@MapPhysica

; 86   :         OffsetInPage = Addr & (_2MB - 1);

  0002f	b8 ff ff 1f 00	 mov	 eax, 2097151		; 001fffffH
  00034	48 c7 c1 00 00
	e0 ff		 mov	 rcx, -2097152		; ffffffffffe00000H
  0003b	4c 23 d0	 and	 r10, rax
  0003e	48 23 f9	 and	 rdi, rcx

; 87   :         PagesToMap = (UINT32)(rounded((OffsetInPage + size), _2MB) / _2MB);

  00041	44 8d 78 01	 lea	 r15d, QWORD PTR [rax+1]
  00045	4b 8d 14 02	 lea	 rdx, QWORD PTR [r10+r8]
  00049	48 85 d0	 test	 rdx, rax
  0004c	74 06		 je	 SHORT $LN14@MapPhysica
  0004e	48 23 d1	 and	 rdx, rcx
  00051	49 03 d7	 add	 rdx, r15
$LN14@MapPhysica:

; 88   : 
; 89   :         if (pctx->NextFreePdIdx + PagesToMap > 512) {

  00054	41 8b 4b 24	 mov	 ecx, DWORD PTR [r11+36]
  00058	48 c1 ea 15	 shr	 rdx, 21
  0005c	8d 04 11	 lea	 eax, DWORD PTR [rcx+rdx]
  0005f	3d 00 02 00 00	 cmp	 eax, 512		; 00000200H
  00064	76 15		 jbe	 SHORT $LN10@MapPhysica

; 90   :             COMSERIALOUT("No free 2MB entries left to map the range");

  00066	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CK@HIHMONIC@No?5free?52MB?5entries?5left?5to?5map?5@IMHBAIGO@
$LN25@MapPhysica:
  0006d	e8 00 00 00 00	 call	 ComSerialOut

; 91   :             return BAD_MAPPING;

  00072	48 83 c8 ff	 or	 rax, -1
  00076	e9 c1 00 00 00	 jmp	 $LN1@MapPhysica
$LN10@MapPhysica:

; 92   :         }
; 93   : 
; 94   :         IA32E_PAGING_TABLE_T* Pd = (IA32E_PAGING_TABLE_T*)pctx->PdBaseFor2MBMappings;

  0007b	4d 8b 73 08	 mov	 r14, QWORD PTR [r11+8]

; 95   : 
; 96   :         VirtualAddr = pctx->VirtualBaseFor2MBMappings + (pctx->NextFreePdIdx * _2MB) + OffsetInPage;

  0007f	c1 e1 15	 shl	 ecx, 21
  00082	8b d9		 mov	 ebx, ecx
  00084	49 03 5b 18	 add	 rbx, QWORD PTR [r11+24]
  00088	49 03 da	 add	 rbx, r10

; 97   : 
; 98   :         for (i = 0; i < PagesToMap; i++, pctx->NextFreePdIdx++, Base += _2MB) {

  0008b	85 d2		 test	 edx, edx
  0008d	0f 84 a6 00 00
	00		 je	 $LN6@MapPhysica

; 92   :         }
; 93   : 
; 94   :         IA32E_PAGING_TABLE_T* Pd = (IA32E_PAGING_TABLE_T*)pctx->PdBaseFor2MBMappings;

  00093	8b f2		 mov	 esi, edx
$LL4@MapPhysica:

; 99   :             Map2MBPage(&Pd->PT[pctx->NextFreePdIdx], Base, IsWritable, IsWBMemtype);

  00095	41 8b 43 24	 mov	 eax, DWORD PTR [r11+36]
  00099	44 8b c5	 mov	 r8d, ebp
  0009c	44 8b 4c 24 68	 mov	 r9d, DWORD PTR IsWBMemtype$[rsp]
  000a1	48 8b d7	 mov	 rdx, rdi
  000a4	49 8d 0c c6	 lea	 rcx, QWORD PTR [r14+rax*8]
  000a8	e8 00 00 00 00	 call	 Map2MBPage
  000ad	41 ff 43 24	 inc	 DWORD PTR [r11+36]
  000b1	49 03 ff	 add	 rdi, r15
  000b4	48 83 ee 01	 sub	 rsi, 1
  000b8	75 db		 jne	 SHORT $LL4@MapPhysica

; 100  :         }
; 101  :     }

  000ba	eb 7d		 jmp	 SHORT $LN6@MapPhysica
$LN8@MapPhysica:

; 102  :     else {
; 103  : 
; 104  :         Base = Addr & _4KB_MASK;
; 105  :         OffsetInPage = Addr & (_4KB - 1);

  000bc	b8 ff 0f 00 00	 mov	 eax, 4095		; 00000fffH
  000c1	48 c7 c2 00 f0
	ff ff		 mov	 rdx, -4096		; fffffffffffff000H
  000c8	4c 23 d0	 and	 r10, rax
  000cb	48 23 fa	 and	 rdi, rdx

; 106  :         PagesToMap = (UINT32)(rounded((OffsetInPage + size), _4KB) / _4KB);

  000ce	44 8d 78 01	 lea	 r15d, QWORD PTR [rax+1]
  000d2	4b 8d 0c 02	 lea	 rcx, QWORD PTR [r10+r8]
  000d6	48 85 c8	 test	 rcx, rax
  000d9	74 06		 je	 SHORT $LN16@MapPhysica
  000db	48 23 ca	 and	 rcx, rdx
  000de	49 03 cf	 add	 rcx, r15
$LN16@MapPhysica:

; 107  : 
; 108  :         if (pctx->NextFreePtIdx + PagesToMap > 512) {

  000e1	41 8b 53 20	 mov	 edx, DWORD PTR [r11+32]
  000e5	48 c1 e9 0c	 shr	 rcx, 12
  000e9	8d 04 0a	 lea	 eax, DWORD PTR [rdx+rcx]
  000ec	3d 00 02 00 00	 cmp	 eax, 512		; 00000200H
  000f1	76 0c		 jbe	 SHORT $LN11@MapPhysica

; 109  :             COMSERIALOUT("No free 4KB entries left to map the range");

  000f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CK@BFFOGJBM@No?5free?54KB?5entries?5left?5to?5map?5@IMHBAIGO@

; 110  :             return BAD_MAPPING;

  000fa	e9 6e ff ff ff	 jmp	 $LN25@MapPhysica
$LN11@MapPhysica:

; 111  :         }
; 112  : 
; 113  :         IA32E_PAGING_TABLE_T* Pt = (IA32E_PAGING_TABLE_T*)pctx->PtBaseFor4KMappings;

  000ff	4d 8b 33	 mov	 r14, QWORD PTR [r11]

; 114  : 
; 115  :         VirtualAddr = pctx->VirtualBaseFor4KMappings + (pctx->NextFreePtIdx * _4KB) + OffsetInPage;

  00102	c1 e2 0c	 shl	 edx, 12
  00105	8b da		 mov	 ebx, edx
  00107	49 03 5b 10	 add	 rbx, QWORD PTR [r11+16]
  0010b	49 03 da	 add	 rbx, r10

; 116  : 
; 117  :         for (i = 0; i < PagesToMap; i++, pctx->NextFreePtIdx++, Base += _4KB) {

  0010e	85 c9		 test	 ecx, ecx
  00110	74 27		 je	 SHORT $LN6@MapPhysica

; 111  :         }
; 112  : 
; 113  :         IA32E_PAGING_TABLE_T* Pt = (IA32E_PAGING_TABLE_T*)pctx->PtBaseFor4KMappings;

  00112	8b f1		 mov	 esi, ecx
$LL7@MapPhysica:

; 118  :             Map4KPage(&Pt->PT[pctx->NextFreePtIdx], Base, IsWritable, IsWBMemtype);

  00114	41 8b 4b 20	 mov	 ecx, DWORD PTR [r11+32]
  00118	44 8b c5	 mov	 r8d, ebp
  0011b	44 8b 4c 24 68	 mov	 r9d, DWORD PTR IsWBMemtype$[rsp]
  00120	48 8b d7	 mov	 rdx, rdi
  00123	49 8d 0c ce	 lea	 rcx, QWORD PTR [r14+rcx*8]
  00127	e8 00 00 00 00	 call	 Map4KPage
  0012c	41 ff 43 20	 inc	 DWORD PTR [r11+32]
  00130	49 03 ff	 add	 rdi, r15
  00133	48 83 ee 01	 sub	 rsi, 1
  00137	75 db		 jne	 SHORT $LL7@MapPhysica
$LN6@MapPhysica:

; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return VirtualAddr;

  00139	48 8b c3	 mov	 rax, rbx
$LN1@MapPhysica:

; 123  : }

  0013c	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00141	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00146	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  0014b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0014f	41 5f		 pop	 r15
  00151	41 5e		 pop	 r14
  00153	5f		 pop	 rdi
  00154	c3		 ret	 0
MapPhysicalRange ENDP
_TEXT	ENDS
END

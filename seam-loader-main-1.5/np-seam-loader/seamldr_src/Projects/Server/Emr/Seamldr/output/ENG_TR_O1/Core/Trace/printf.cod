; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24245.0 

	TITLE	D:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\Core\Trace\printf.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_traceControls
EDATA32	SEGMENT
_traceControls DB 074H
EDATA32	ENDS
PUBLIC	_Printf
PUBLIC	_PrintBuffer
PUBLIC	_TraceFunction
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@IMHBAIGO@		;  ?? ::IMHBAIGO::`string'
PUBLIC	??_C@_05CNDJFPDP@?$CF02x?5?$AA@IMHBAIGO@	;  ?? ::IMHBAIGO::`string'
EXTRN	_TraceWriteString:PROC
EXTRN	_NumToStr:PROC
EXTRN	_traceRoutines:BYTE
;	COMDAT ??_C@_05CNDJFPDP@?$CF02x?5?$AA@IMHBAIGO@
EDATA32	SEGMENT
??_C@_05CNDJFPDP@?$CF02x?5?$AA@IMHBAIGO@ DB '%02x ', 00H ;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@IMHBAIGO@
EDATA32	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@IMHBAIGO@ DB 0aH, 00H		;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\trace\printf.c
;	COMDAT __printf
_TEXT	SEGMENT
_Format$ = 8						; size = 4
__printf PROC						; COMDAT

; 299  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 300  :   va_list Marker;
; 301  : 
; 302  :   va_start(Marker, Format);
; 303  :   __printf(Format, Marker);

  00003	8d 45 0c	 lea	 eax, DWORD PTR _Format$[ebp+4]
  00006	50		 push	 eax
  00007	ff 75 08	 push	 DWORD PTR _Format$[ebp]
  0000a	e8 00 00 00 00	 call	 ___printf
  0000f	59		 pop	 ecx
  00010	59		 pop	 ecx

; 304  :   return;
; 305  : }

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
__printf ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\trace\printf.c
;	COMDAT ___printf
_TEXT	SEGMENT
_Str$ = -172						; size = 160
_p$ = -12						; size = 4
_Flags$1$ = -8						; size = 4
_Width$1$ = -4						; size = 4
_String$1$ = 8						; size = 4
_Format$ = 8						; size = 4
tv404 = 11						; size = 1
_Marker$ = 12						; size = 4
___printf PROC						; COMDAT

; 199  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec ac 00 00
	00		 sub	 esp, 172		; 000000acH
  00009	56		 push	 esi

; 200  :   char *p;
; 201  :   UINT32 Width;
; 202  :   UINT32 Flags;
; 203  :   char Str[TEMP_STR_LEN];
; 204  :   char *String;
; 205  : 
; 206  :   // UINT32 i;
; 207  : 
; 208  :   for (p = (char *)Format; *p; p++) {

  0000a	8b 75 08	 mov	 esi, DWORD PTR _Format$[ebp]
  0000d	80 3e 00	 cmp	 BYTE PTR [esi], 0
  00010	0f 84 85 01 00
	00		 je	 $LN3@printf
  00016	8b 45 0c	 mov	 eax, DWORD PTR _Marker$[ebp]
  00019	53		 push	 ebx
  0001a	57		 push	 edi
  0001b	8d 78 fc	 lea	 edi, DWORD PTR [eax-4]
  0001e	8d 58 f8	 lea	 ebx, DWORD PTR [eax-8]
$LL4@printf:

; 209  :     if (*p != '%') {

  00021	80 3e 25	 cmp	 BYTE PTR [esi], 37	; 00000025H
  00024	74 08		 je	 SHORT $LN7@printf

; 210  :       TraceWriteString(p, 1);

  00026	6a 01		 push	 1
  00028	56		 push	 esi

; 211  :       continue;

  00029	e9 5a 01 00 00	 jmp	 $LN36@printf
$LN7@printf:

; 212  :     }
; 213  : 
; 214  :     p++;

  0002e	46		 inc	 esi

; 215  :     // Check for flags
; 216  :     Flags = 0;

  0002f	33 c9		 xor	 ecx, ecx
  00031	89 75 f4	 mov	 DWORD PTR _p$[ebp], esi
  00034	89 4d f8	 mov	 DWORD PTR _Flags$1$[ebp], ecx

; 217  :     if (*p == '-') {

  00037	8a 06		 mov	 al, BYTE PTR [esi]
  00039	3c 2d		 cmp	 al, 45			; 0000002dH
  0003b	75 03		 jne	 SHORT $LN8@printf

; 218  :       Flags |= LEFT_JUSTIFY;

  0003d	41		 inc	 ecx
  0003e	eb 0f		 jmp	 SHORT $LN37@printf
$LN8@printf:

; 219  :     } else if (*p == '+') {

  00040	3c 2b		 cmp	 al, 43			; 0000002bH
  00042	75 04		 jne	 SHORT $LN10@printf

; 220  :       Flags |= PREFIX_SIGN;

  00044	6a 02		 push	 2
  00046	eb 06		 jmp	 SHORT $LN38@printf
$LN10@printf:

; 221  :     } else if (*p == ' ') {

  00048	3c 20		 cmp	 al, 32			; 00000020H
  0004a	75 0a		 jne	 SHORT $LN13@printf

; 222  :       Flags |= PREFIX_PADBLANK;

  0004c	6a 04		 push	 4
$LN38@printf:
  0004e	59		 pop	 ecx
$LN37@printf:

; 223  :     }
; 224  :     if (Flags != 0) {
; 225  :       p++;

  0004f	46		 inc	 esi
  00050	89 4d f8	 mov	 DWORD PTR _Flags$1$[ebp], ecx
  00053	89 75 f4	 mov	 DWORD PTR _p$[ebp], esi
$LN13@printf:

; 226  :     }
; 227  : 
; 228  :     Width = 0;
; 229  :     // Check for width
; 230  :     if (isdigit(*p)) {

  00056	8a 06		 mov	 al, BYTE PTR [esi]
  00058	83 65 fc 00	 and	 DWORD PTR _Width$1$[ebp], 0
  0005c	88 45 0b	 mov	 BYTE PTR tv404[ebp], al
  0005f	3c 30		 cmp	 al, 48			; 00000030H
  00061	7c 26		 jl	 SHORT $LN14@printf
  00063	3c 39		 cmp	 al, 57			; 00000039H
  00065	7f 22		 jg	 SHORT $LN14@printf

; 231  :       if (*p == '0') {
; 232  :         Flags |= PREFIX_PADZERO;
; 233  :       }
; 234  :       Width = StrToNumber(&p);

  00067	8d 45 f4	 lea	 eax, DWORD PTR _p$[ebp]
  0006a	50		 push	 eax
  0006b	e8 00 00 00 00	 call	 _StrToNumber
  00070	8b 75 f4	 mov	 esi, DWORD PTR _p$[ebp]
  00073	59		 pop	 ecx
  00074	8b 4d f8	 mov	 ecx, DWORD PTR _Flags$1$[ebp]
  00077	6a 08		 push	 8
  00079	89 45 fc	 mov	 DWORD PTR _Width$1$[ebp], eax
  0007c	58		 pop	 eax
  0007d	0b c8		 or	 ecx, eax
  0007f	80 7d 0b 30	 cmp	 BYTE PTR tv404[ebp], 48	; 00000030H
  00083	0f 45 4d f8	 cmovne	 ecx, DWORD PTR _Flags$1$[ebp]
  00087	eb 10		 jmp	 SHORT $LN17@printf
$LN14@printf:

; 235  :     } else if (*p == '*') {

  00089	3c 2a		 cmp	 al, 42			; 0000002aH
  0008b	75 0c		 jne	 SHORT $LN17@printf

; 236  :       Width = va_arg(Marker, int);

  0008d	83 c7 04	 add	 edi, 4
  00090	83 c3 04	 add	 ebx, 4

; 237  :       p++;

  00093	46		 inc	 esi
  00094	8b 07		 mov	 eax, DWORD PTR [edi]
  00096	89 45 fc	 mov	 DWORD PTR _Width$1$[ebp], eax
$LN17@printf:

; 238  :     }
; 239  : 
; 240  :     if (*p == ',') {

  00099	80 3e 2c	 cmp	 BYTE PTR [esi], 44	; 0000002cH
  0009c	75 04		 jne	 SHORT $LN18@printf

; 241  :       Flags |= COMA_TYPE;

  0009e	83 c9 40	 or	 ecx, 64			; 00000040H

; 242  :       p++;

  000a1	46		 inc	 esi
$LN18@printf:

; 243  :     }
; 244  : 
; 245  :     if (!(Flags & PREFIX_PADZERO) && !(Flags & LEFT_JUSTIFY)) {
; 246  :       Flags |= PREFIX_PADBLANK;
; 247  :     }
; 248  : 
; 249  :     // get type
; 250  :     String = Str;

  000a2	8b c1		 mov	 eax, ecx
  000a4	8b d1		 mov	 edx, ecx
  000a6	83 ca 04	 or	 edx, 4
  000a9	24 09		 and	 al, 9
  000ab	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR _Str$[ebp]
  000b1	89 45 08	 mov	 DWORD PTR _String$1$[ebp], eax
  000b4	0f 45 d1	 cmovne	 edx, ecx

; 251  :     switch (*p) {

  000b7	0f be 06	 movsx	 eax, BYTE PTR [esi]
  000ba	83 f8 69	 cmp	 eax, 105		; 00000069H
  000bd	7f 63		 jg	 SHORT $LN29@printf
  000bf	74 18		 je	 SHORT $LN20@printf
  000c1	83 e8 4c	 sub	 eax, 76			; 0000004cH
  000c4	74 3e		 je	 SHORT $LN27@printf
  000c6	83 e8 0c	 sub	 eax, 12			; 0000000cH
  000c9	74 6c		 je	 SHORT $LN22@printf
  000cb	83 e8 0b	 sub	 eax, 11			; 0000000bH
  000ce	74 1d		 je	 SHORT $LN23@printf
  000d0	83 e8 01	 sub	 eax, 1
  000d3	0f 85 a9 00 00
	00		 jne	 $LN35@printf
$LN20@printf:

; 252  :     case 'd':
; 253  :     case 'i':
; 254  :       // always print as UINTN will need extra code to print different widths
; 255  :       UintnToStr((UINT32)va_arg(Marker, UINT32 *), Str, Width, Flags | INT_SIGNED, 10);

  000d9	83 c3 04	 add	 ebx, 4
  000dc	83 c7 04	 add	 edi, 4
  000df	83 ca 20	 or	 edx, 32			; 00000020H
$LN41@printf:
  000e2	6a 0a		 push	 10			; 0000000aH
$LN39@printf:
  000e4	52		 push	 edx
  000e5	ff 75 fc	 push	 DWORD PTR _Width$1$[ebp]

; 256  :       break;

  000e8	e9 84 00 00 00	 jmp	 $LN40@printf
$LN23@printf:

; 266  :     case 'c':
; 267  :       Str[0] = (char)va_arg(Marker, char);

  000ed	83 c3 04	 add	 ebx, 4

; 268  :       Str[1] = '\0';

  000f0	c6 85 55 ff ff
	ff 00		 mov	 BYTE PTR _Str$[ebp+1], 0
  000f7	83 c7 04	 add	 edi, 4
  000fa	8a 07		 mov	 al, BYTE PTR [edi]
  000fc	88 85 54 ff ff
	ff		 mov	 BYTE PTR _Str$[ebp], al

; 269  :       break;

  00102	eb 7e		 jmp	 SHORT $LN35@printf
$LN27@printf:

; 280  :       break;
; 281  :     case 'L':
; 282  :       NumToStr(Str, 8, (UINT64)va_arg(Marker, UINT64));

  00104	6a 08		 push	 8
  00106	58		 pop	 eax
  00107	03 d8		 add	 ebx, eax
  00109	03 f8		 add	 edi, eax
  0010b	ff 73 04	 push	 DWORD PTR [ebx+4]
  0010e	ff 33		 push	 DWORD PTR [ebx]
  00110	50		 push	 eax
  00111	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR _Str$[ebp]
  00117	50		 push	 eax
  00118	e8 00 00 00 00	 call	 _NumToStr
  0011d	83 c4 10	 add	 esp, 16			; 00000010H
  00120	eb 60		 jmp	 SHORT $LN35@printf
$LN29@printf:

; 251  :     switch (*p) {

  00122	83 e8 70	 sub	 eax, 112		; 00000070H
  00125	74 2c		 je	 SHORT $LN25@printf
  00127	83 e8 03	 sub	 eax, 3
  0012a	74 1d		 je	 SHORT $LN24@printf
  0012c	48		 dec	 eax
  0012d	83 e8 01	 sub	 eax, 1
  00130	74 0f		 je	 SHORT $LN21@printf
  00132	83 e8 03	 sub	 eax, 3
  00135	75 4b		 jne	 SHORT $LN35@printf
$LN22@printf:

; 261  :     case 'x':
; 262  :     case 'X':
; 263  :       // always print as UINTN will need extra code to print different widths
; 264  :       UintnToStr((UINT32)va_arg(Marker, UINT32 *), Str, Width, Flags, 16);

  00137	83 c3 04	 add	 ebx, 4
  0013a	83 c7 04	 add	 edi, 4
  0013d	6a 10		 push	 16			; 00000010H

; 265  :       break;

  0013f	eb a3		 jmp	 SHORT $LN39@printf
$LN21@printf:

; 257  :     case 'u':
; 258  :       // always print as UINTN will need extra code to print different widths
; 259  :       UintnToStr((UINT32)va_arg(Marker, UINT32 *), Str, Width, Flags, 10);

  00141	83 c3 04	 add	 ebx, 4
  00144	83 c7 04	 add	 edi, 4

; 260  :       break;

  00147	eb 99		 jmp	 SHORT $LN41@printf
$LN24@printf:

; 270  :     case 's':
; 271  :       String = (char *)va_arg(Marker, char *);

  00149	83 c3 04	 add	 ebx, 4
  0014c	83 c7 04	 add	 edi, 4
  0014f	8b 07		 mov	 eax, DWORD PTR [edi]

; 272  :       break;

  00151	eb 32		 jmp	 SHORT $LN5@printf
$LN25@printf:

; 273  :     case 'p':
; 274  :       Flags &= ~PREFIX_PADMASK;
; 275  :       Flags |= PREFIX_PADPOINTER;
; 276  :       if (Width < 8) {

  00153	8b 45 fc	 mov	 eax, DWORD PTR _Width$1$[ebp]
  00156	83 e2 f3	 and	 edx, -13		; fffffff3H
  00159	6a 08		 push	 8
  0015b	59		 pop	 ecx
  0015c	81 ca 00 02 00
	00		 or	 edx, 512		; 00000200H
  00162	3b c1		 cmp	 eax, ecx

; 277  :         Width = 8;
; 278  :       }
; 279  :       UintnToStr((UINT32)va_arg(Marker, UINT32 *), Str, Width, Flags, 16);

  00164	6a 10		 push	 16			; 00000010H
  00166	0f 42 c1	 cmovb	 eax, ecx
  00169	83 c3 04	 add	 ebx, 4
  0016c	52		 push	 edx
  0016d	83 c7 04	 add	 edi, 4
  00170	50		 push	 eax
$LN40@printf:
  00171	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR _Str$[ebp]
  00177	50		 push	 eax
  00178	ff 37		 push	 DWORD PTR [edi]
  0017a	e8 00 00 00 00	 call	 _UintnToStr
  0017f	83 c4 14	 add	 esp, 20			; 00000014H
$LN35@printf:
  00182	8b 45 08	 mov	 eax, DWORD PTR _String$1$[ebp]
$LN5@printf:

; 283  :       break;
; 284  :     }
; 285  :     TraceWriteString(String, 0);

  00185	6a 00		 push	 0
  00187	50		 push	 eax
$LN36@printf:
  00188	e8 00 00 00 00	 call	 _TraceWriteString
  0018d	46		 inc	 esi
  0018e	59		 pop	 ecx
  0018f	59		 pop	 ecx
  00190	80 3e 00	 cmp	 BYTE PTR [esi], 0
  00193	0f 85 88 fe ff
	ff		 jne	 $LL4@printf
  00199	5f		 pop	 edi
  0019a	5b		 pop	 ebx
$LN3@printf:
  0019b	5e		 pop	 esi

; 286  :   }
; 287  :   return;
; 288  : }

  0019c	8b e5		 mov	 esp, ebp
  0019e	5d		 pop	 ebp
  0019f	c3		 ret	 0
___printf ENDP
_TEXT	ENDS
; Function compile flags: /Odsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\trace\printf.c
;	COMDAT _UintnToStr
_TEXT	SEGMENT
_Hex$ = -44						; size = 16
_Negative$ = -28					; size = 4
_IntDigits$ = -24					; size = 4
_End$ = -20						; size = 4
_Int$ = -16						; size = 4
_i$ = -12						; size = 4
_Ptr$ = -8						; size = 4
_c$ = -2						; size = 1
_Prefix$ = -1						; size = 1
_Value$ = 8						; size = 4
_Str$ = 12						; size = 4
_Width$ = 16						; size = 4
_Flags$ = 20						; size = 4
_Base$ = 24						; size = 4
_UintnToStr PROC					; COMDAT

; 68   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH

; 69   :   UINT32 Negative;
; 70   :   UINT32 Int;
; 71   :   UINT32 IntDigits;
; 72   :   char *Ptr;
; 73   :   char Prefix = 0;

  00006	c6 45 ff 00	 mov	 BYTE PTR _Prefix$[ebp], 0

; 74   :   char c;
; 75   :   UINT32 i;
; 76   :   const char Hex[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };

  0000a	c6 45 d4 30	 mov	 BYTE PTR _Hex$[ebp], 48	; 00000030H
  0000e	c6 45 d5 31	 mov	 BYTE PTR _Hex$[ebp+1], 49 ; 00000031H
  00012	c6 45 d6 32	 mov	 BYTE PTR _Hex$[ebp+2], 50 ; 00000032H
  00016	c6 45 d7 33	 mov	 BYTE PTR _Hex$[ebp+3], 51 ; 00000033H
  0001a	c6 45 d8 34	 mov	 BYTE PTR _Hex$[ebp+4], 52 ; 00000034H
  0001e	c6 45 d9 35	 mov	 BYTE PTR _Hex$[ebp+5], 53 ; 00000035H
  00022	c6 45 da 36	 mov	 BYTE PTR _Hex$[ebp+6], 54 ; 00000036H
  00026	c6 45 db 37	 mov	 BYTE PTR _Hex$[ebp+7], 55 ; 00000037H
  0002a	c6 45 dc 38	 mov	 BYTE PTR _Hex$[ebp+8], 56 ; 00000038H
  0002e	c6 45 dd 39	 mov	 BYTE PTR _Hex$[ebp+9], 57 ; 00000039H
  00032	c6 45 de 41	 mov	 BYTE PTR _Hex$[ebp+10], 65 ; 00000041H
  00036	c6 45 df 42	 mov	 BYTE PTR _Hex$[ebp+11], 66 ; 00000042H
  0003a	c6 45 e0 43	 mov	 BYTE PTR _Hex$[ebp+12], 67 ; 00000043H
  0003e	c6 45 e1 44	 mov	 BYTE PTR _Hex$[ebp+13], 68 ; 00000044H
  00042	c6 45 e2 45	 mov	 BYTE PTR _Hex$[ebp+14], 69 ; 00000045H
  00046	c6 45 e3 46	 mov	 BYTE PTR _Hex$[ebp+15], 70 ; 00000046H

; 77   :   char *End = Str + TEMP_STR_LEN;

  0004a	8b 45 0c	 mov	 eax, DWORD PTR _Str$[ebp]
  0004d	05 a0 00 00 00	 add	 eax, 160		; 000000a0H
  00052	89 45 ec	 mov	 DWORD PTR _End$[ebp], eax

; 78   : 
; 79   : #define UPDATE_STR(C) do { \
; 80   :     if (Ptr < End) \
; 81   :     *Ptr++ = (C); \
; 82   : } while (0);
; 83   : 
; 84   :   Ptr = Str;

  00055	8b 45 0c	 mov	 eax, DWORD PTR _Str$[ebp]
  00058	89 45 f8	 mov	 DWORD PTR _Ptr$[ebp], eax

; 85   :   if ((Value > INT32_MAX) && (Flags & INT_SIGNED)) {

  0005b	81 7d 08 ff ff
	ff 7f		 cmp	 DWORD PTR _Value$[ebp], 2147483647 ; 7fffffffH
  00062	76 1a		 jbe	 SHORT $LN19@UintnToStr
  00064	8b 45 14	 mov	 eax, DWORD PTR _Flags$[ebp]
  00067	83 e0 20	 and	 eax, 32			; 00000020H
  0006a	74 12		 je	 SHORT $LN19@UintnToStr

; 86   :     Int = ~Value + 1; /* -Value */

  0006c	8b 45 08	 mov	 eax, DWORD PTR _Value$[ebp]
  0006f	f7 d0		 not	 eax
  00071	40		 inc	 eax
  00072	89 45 f0	 mov	 DWORD PTR _Int$[ebp], eax

; 87   :     Negative = 1;

  00075	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _Negative$[ebp], 1

; 88   :   } else {

  0007c	eb 0a		 jmp	 SHORT $LN20@UintnToStr
$LN19@UintnToStr:

; 89   :     Int = Value;

  0007e	8b 45 08	 mov	 eax, DWORD PTR _Value$[ebp]
  00081	89 45 f0	 mov	 DWORD PTR _Int$[ebp], eax

; 90   :     Negative = 0;

  00084	83 65 e4 00	 and	 DWORD PTR _Negative$[ebp], 0
$LN20@UintnToStr:

; 91   :   }
; 92   : 
; 93   :   i = 0;

  00088	83 65 f4 00	 and	 DWORD PTR _i$[ebp], 0
$LN4@UintnToStr:

; 94   :   do { /* generate digits in reverse order */
; 95   :     i++;

  0008c	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  0008f	40		 inc	 eax
  00090	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
$LN7@UintnToStr:

; 96   :     UPDATE_STR(Hex[Int % Base]);

  00093	8b 45 f8	 mov	 eax, DWORD PTR _Ptr$[ebp]
  00096	3b 45 ec	 cmp	 eax, DWORD PTR _End$[ebp]
  00099	73 18		 jae	 SHORT $LN5@UintnToStr
  0009b	8b 45 f0	 mov	 eax, DWORD PTR _Int$[ebp]
  0009e	33 d2		 xor	 edx, edx
  000a0	f7 75 18	 div	 DWORD PTR _Base$[ebp]
  000a3	8b 45 f8	 mov	 eax, DWORD PTR _Ptr$[ebp]
  000a6	8a 4c 15 d4	 mov	 cl, BYTE PTR _Hex$[ebp+edx]
  000aa	88 08		 mov	 BYTE PTR [eax], cl
  000ac	8b 45 f8	 mov	 eax, DWORD PTR _Ptr$[ebp]
  000af	40		 inc	 eax
  000b0	89 45 f8	 mov	 DWORD PTR _Ptr$[ebp], eax
$LN5@UintnToStr:
  000b3	33 c0		 xor	 eax, eax
  000b5	75 dc		 jne	 SHORT $LN7@UintnToStr

; 97   :     if (Flags & COMA_TYPE) {

  000b7	8b 45 14	 mov	 eax, DWORD PTR _Flags$[ebp]
  000ba	83 e0 40	 and	 eax, 64			; 00000040H
  000bd	74 44		 je	 SHORT $LN2@UintnToStr

; 98   :       if (Base == 16) {

  000bf	83 7d 18 10	 cmp	 DWORD PTR _Base$[ebp], 16 ; 00000010H
  000c3	75 1d		 jne	 SHORT $LN23@UintnToStr

; 99   :         if (i % 4 == 0) {

  000c5	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  000c8	33 d2		 xor	 edx, edx
  000ca	6a 04		 push	 4
  000cc	59		 pop	 ecx
  000cd	f7 f1		 div	 ecx
  000cf	85 d2		 test	 edx, edx
  000d1	75 0d		 jne	 SHORT $LN25@UintnToStr

; 100  :           *Ptr++ = ',';

  000d3	8b 45 f8	 mov	 eax, DWORD PTR _Ptr$[ebp]
  000d6	c6 00 2c	 mov	 BYTE PTR [eax], 44	; 0000002cH
  000d9	8b 45 f8	 mov	 eax, DWORD PTR _Ptr$[ebp]
  000dc	40		 inc	 eax
  000dd	89 45 f8	 mov	 DWORD PTR _Ptr$[ebp], eax
$LN25@UintnToStr:

; 101  :         }

  000e0	eb 21		 jmp	 SHORT $LN2@UintnToStr
$LN23@UintnToStr:

; 102  :       } else if (Base == 10) {

  000e2	83 7d 18 0a	 cmp	 DWORD PTR _Base$[ebp], 10 ; 0000000aH
  000e6	75 1b		 jne	 SHORT $LN2@UintnToStr

; 103  :         if (i % 3 == 0) {

  000e8	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  000eb	33 d2		 xor	 edx, edx
  000ed	6a 03		 push	 3
  000ef	59		 pop	 ecx
  000f0	f7 f1		 div	 ecx
  000f2	85 d2		 test	 edx, edx
  000f4	75 0d		 jne	 SHORT $LN2@UintnToStr

; 104  :           *Ptr++ = ',';

  000f6	8b 45 f8	 mov	 eax, DWORD PTR _Ptr$[ebp]
  000f9	c6 00 2c	 mov	 BYTE PTR [eax], 44	; 0000002cH
  000fc	8b 45 f8	 mov	 eax, DWORD PTR _Ptr$[ebp]
  000ff	40		 inc	 eax
  00100	89 45 f8	 mov	 DWORD PTR _Ptr$[ebp], eax
$LN2@UintnToStr:

; 105  :         }
; 106  :       }
; 107  :     }
; 108  :   } while ((Int /= Base) > 0);

  00103	8b 45 f0	 mov	 eax, DWORD PTR _Int$[ebp]
  00106	33 d2		 xor	 edx, edx
  00108	f7 75 18	 div	 DWORD PTR _Base$[ebp]
  0010b	89 45 f0	 mov	 DWORD PTR _Int$[ebp], eax
  0010e	83 7d f0 00	 cmp	 DWORD PTR _Int$[ebp], 0
  00112	0f 87 74 ff ff
	ff		 ja	 $LN4@UintnToStr

; 109  : 
; 110  :   if (*(Ptr - 1) == ',') {

  00118	8b 45 f8	 mov	 eax, DWORD PTR _Ptr$[ebp]
  0011b	0f be 40 ff	 movsx	 eax, BYTE PTR [eax-1]
  0011f	83 f8 2c	 cmp	 eax, 44			; 0000002cH
  00122	75 07		 jne	 SHORT $LN28@UintnToStr

; 111  :     Ptr--;

  00124	8b 45 f8	 mov	 eax, DWORD PTR _Ptr$[ebp]
  00127	48		 dec	 eax
  00128	89 45 f8	 mov	 DWORD PTR _Ptr$[ebp], eax
$LN28@UintnToStr:

; 112  :   }
; 113  : 
; 114  :   if (Negative) {

  0012b	83 7d e4 00	 cmp	 DWORD PTR _Negative$[ebp], 0
  0012f	74 0f		 je	 SHORT $LN29@UintnToStr

; 115  :     *Ptr++ = '-';

  00131	8b 45 f8	 mov	 eax, DWORD PTR _Ptr$[ebp]
  00134	c6 00 2d	 mov	 BYTE PTR [eax], 45	; 0000002dH
  00137	8b 45 f8	 mov	 eax, DWORD PTR _Ptr$[ebp]
  0013a	40		 inc	 eax
  0013b	89 45 f8	 mov	 DWORD PTR _Ptr$[ebp], eax
  0013e	eb 15		 jmp	 SHORT $LN30@UintnToStr
$LN29@UintnToStr:

; 116  :   } else if (Flags & PREFIX_SIGN) {

  00140	8b 45 14	 mov	 eax, DWORD PTR _Flags$[ebp]
  00143	83 e0 02	 and	 eax, 2
  00146	74 0d		 je	 SHORT $LN30@UintnToStr

; 117  :     *Ptr++ = '+';

  00148	8b 45 f8	 mov	 eax, DWORD PTR _Ptr$[ebp]
  0014b	c6 00 2b	 mov	 BYTE PTR [eax], 43	; 0000002bH
  0014e	8b 45 f8	 mov	 eax, DWORD PTR _Ptr$[ebp]
  00151	40		 inc	 eax
  00152	89 45 f8	 mov	 DWORD PTR _Ptr$[ebp], eax
$LN30@UintnToStr:

; 118  :   }
; 119  : 
; 120  :   IntDigits = Ptr - Str;

  00155	8b 45 f8	 mov	 eax, DWORD PTR _Ptr$[ebp]
  00158	2b 45 0c	 sub	 eax, DWORD PTR _Str$[ebp]
  0015b	89 45 e8	 mov	 DWORD PTR _IntDigits$[ebp], eax

; 121  : 
; 122  :   if ((Flags & PREFIX_PADMASK) && (Width > IntDigits)) {

  0015e	8b 45 14	 mov	 eax, DWORD PTR _Flags$[ebp]
  00161	25 0c 02 00 00	 and	 eax, 524		; 0000020cH
  00166	74 78		 je	 SHORT $LN32@UintnToStr
  00168	8b 45 10	 mov	 eax, DWORD PTR _Width$[ebp]
  0016b	3b 45 e8	 cmp	 eax, DWORD PTR _IntDigits$[ebp]
  0016e	76 70		 jbe	 SHORT $LN32@UintnToStr

; 123  :     Width -= IntDigits;

  00170	8b 45 10	 mov	 eax, DWORD PTR _Width$[ebp]
  00173	2b 45 e8	 sub	 eax, DWORD PTR _IntDigits$[ebp]
  00176	89 45 10	 mov	 DWORD PTR _Width$[ebp], eax

; 124  :     for (i = 0; i < Width; i++) {

  00179	83 65 f4 00	 and	 DWORD PTR _i$[ebp], 0
  0017d	eb 07		 jmp	 SHORT $LN10@UintnToStr
$LN8@UintnToStr:
  0017f	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00182	40		 inc	 eax
  00183	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
$LN10@UintnToStr:
  00186	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00189	3b 45 10	 cmp	 eax, DWORD PTR _Width$[ebp]
  0018c	73 52		 jae	 SHORT $LN32@UintnToStr

; 125  :       if (Flags & PREFIX_PADPOINTER) {

  0018e	8b 45 14	 mov	 eax, DWORD PTR _Flags$[ebp]
  00191	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00196	74 13		 je	 SHORT $LN33@UintnToStr

; 126  :         Prefix = '0';

  00198	c6 45 ff 30	 mov	 BYTE PTR _Prefix$[ebp], 48 ; 00000030H

; 127  :         if ((i + IntDigits) > 7) {

  0019c	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  0019f	03 45 e8	 add	 eax, DWORD PTR _IntDigits$[ebp]
  001a2	83 f8 07	 cmp	 eax, 7
  001a5	76 04		 jbe	 SHORT $LN33@UintnToStr

; 128  :           Prefix = ' ';

  001a7	c6 45 ff 20	 mov	 BYTE PTR _Prefix$[ebp], 32 ; 00000020H
$LN33@UintnToStr:

; 129  :         }
; 130  :       }
; 131  :       if (Flags & PREFIX_PADZERO) {

  001ab	8b 45 14	 mov	 eax, DWORD PTR _Flags$[ebp]
  001ae	83 e0 08	 and	 eax, 8
  001b1	74 04		 je	 SHORT $LN35@UintnToStr

; 132  :         Prefix = '0';

  001b3	c6 45 ff 30	 mov	 BYTE PTR _Prefix$[ebp], 48 ; 00000030H
$LN35@UintnToStr:

; 133  :       }
; 134  :       if (Flags & PREFIX_PADBLANK) {

  001b7	8b 45 14	 mov	 eax, DWORD PTR _Flags$[ebp]
  001ba	83 e0 04	 and	 eax, 4
  001bd	74 04		 je	 SHORT $LN13@UintnToStr

; 135  :         Prefix = ' ';

  001bf	c6 45 ff 20	 mov	 BYTE PTR _Prefix$[ebp], 32 ; 00000020H
$LN13@UintnToStr:

; 136  :       }
; 137  :       UPDATE_STR(Prefix);

  001c3	8b 45 f8	 mov	 eax, DWORD PTR _Ptr$[ebp]
  001c6	3b 45 ec	 cmp	 eax, DWORD PTR _End$[ebp]
  001c9	73 0f		 jae	 SHORT $LN11@UintnToStr
  001cb	8b 45 f8	 mov	 eax, DWORD PTR _Ptr$[ebp]
  001ce	8a 4d ff	 mov	 cl, BYTE PTR _Prefix$[ebp]
  001d1	88 08		 mov	 BYTE PTR [eax], cl
  001d3	8b 45 f8	 mov	 eax, DWORD PTR _Ptr$[ebp]
  001d6	40		 inc	 eax
  001d7	89 45 f8	 mov	 DWORD PTR _Ptr$[ebp], eax
$LN11@UintnToStr:
  001da	33 c0		 xor	 eax, eax
  001dc	75 e5		 jne	 SHORT $LN13@UintnToStr

; 138  :     }

  001de	eb 9f		 jmp	 SHORT $LN8@UintnToStr
$LN32@UintnToStr:

; 139  :   }
; 140  : 
; 141  :   // For 64-bit values, the lower 32-bits already terminated string.
; 142  :   if (!(Flags & DONT_TERMINATE)) {

  001e0	8b 45 14	 mov	 eax, DWORD PTR _Flags$[ebp]
  001e3	25 00 01 00 00	 and	 eax, 256		; 00000100H
  001e8	75 28		 jne	 SHORT $LN38@UintnToStr

; 143  :     if (Ptr >= End) {

  001ea	8b 45 f8	 mov	 eax, DWORD PTR _Ptr$[ebp]
  001ed	3b 45 ec	 cmp	 eax, DWORD PTR _End$[ebp]
  001f0	72 07		 jb	 SHORT $LN16@UintnToStr

; 144  :       Ptr = End - 1;

  001f2	8b 45 ec	 mov	 eax, DWORD PTR _End$[ebp]
  001f5	48		 dec	 eax
  001f6	89 45 f8	 mov	 DWORD PTR _Ptr$[ebp], eax
$LN16@UintnToStr:

; 145  :     }
; 146  :     UPDATE_STR('\0');

  001f9	8b 45 f8	 mov	 eax, DWORD PTR _Ptr$[ebp]
  001fc	3b 45 ec	 cmp	 eax, DWORD PTR _End$[ebp]
  001ff	73 0d		 jae	 SHORT $LN14@UintnToStr
  00201	8b 45 f8	 mov	 eax, DWORD PTR _Ptr$[ebp]
  00204	c6 00 00	 mov	 BYTE PTR [eax], 0
  00207	8b 45 f8	 mov	 eax, DWORD PTR _Ptr$[ebp]
  0020a	40		 inc	 eax
  0020b	89 45 f8	 mov	 DWORD PTR _Ptr$[ebp], eax
$LN14@UintnToStr:
  0020e	33 c0		 xor	 eax, eax
  00210	75 e7		 jne	 SHORT $LN16@UintnToStr
$LN38@UintnToStr:

; 147  :   }
; 148  :   --Ptr;

  00212	8b 45 f8	 mov	 eax, DWORD PTR _Ptr$[ebp]
  00215	48		 dec	 eax
  00216	89 45 f8	 mov	 DWORD PTR _Ptr$[ebp], eax
$LN17@UintnToStr:

; 149  : 
; 150  :   /* reverse string */
; 151  :   while (Str < --Ptr) {

  00219	8b 45 f8	 mov	 eax, DWORD PTR _Ptr$[ebp]
  0021c	48		 dec	 eax
  0021d	89 45 f8	 mov	 DWORD PTR _Ptr$[ebp], eax
  00220	8b 45 0c	 mov	 eax, DWORD PTR _Str$[ebp]
  00223	3b 45 f8	 cmp	 eax, DWORD PTR _Ptr$[ebp]
  00226	73 23		 jae	 SHORT $LN1@UintnToStr

; 152  :     c = *Str;

  00228	8b 45 0c	 mov	 eax, DWORD PTR _Str$[ebp]
  0022b	8a 00		 mov	 al, BYTE PTR [eax]
  0022d	88 45 fe	 mov	 BYTE PTR _c$[ebp], al

; 153  :     *Str++ = *Ptr;

  00230	8b 45 0c	 mov	 eax, DWORD PTR _Str$[ebp]
  00233	8b 4d f8	 mov	 ecx, DWORD PTR _Ptr$[ebp]
  00236	8a 09		 mov	 cl, BYTE PTR [ecx]
  00238	88 08		 mov	 BYTE PTR [eax], cl
  0023a	8b 45 0c	 mov	 eax, DWORD PTR _Str$[ebp]
  0023d	40		 inc	 eax
  0023e	89 45 0c	 mov	 DWORD PTR _Str$[ebp], eax

; 154  :     *Ptr = c;

  00241	8b 45 f8	 mov	 eax, DWORD PTR _Ptr$[ebp]
  00244	8a 4d fe	 mov	 cl, BYTE PTR _c$[ebp]
  00247	88 08		 mov	 BYTE PTR [eax], cl

; 155  :   }

  00249	eb ce		 jmp	 SHORT $LN17@UintnToStr
$LN1@UintnToStr:

; 156  : }

  0024b	8b e5		 mov	 esp, ebp
  0024d	5d		 pop	 ebp
  0024e	c3		 ret	 0
_UintnToStr ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\trace\printf.c
;	COMDAT _StrToNumber
_TEXT	SEGMENT
_String$ = 8						; size = 4
_StrToNumber PROC					; COMDAT

; 49   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 50   :   UINT32 Sum;
; 51   :   char *Str;
; 52   : 
; 53   :   Str = *String;

  00004	8b 75 08	 mov	 esi, DWORD PTR _String$[ebp]
  00007	8b 16		 mov	 edx, DWORD PTR [esi]

; 54   :   if (*Str == '0') {

  00009	80 3a 30	 cmp	 BYTE PTR [edx], 48	; 00000030H
  0000c	75 01		 jne	 SHORT $LN4@StrToNumbe

; 55   :     Str++;

  0000e	42		 inc	 edx
$LN4@StrToNumbe:

; 56   :   }
; 57   :   Sum = 0;

  0000f	33 c9		 xor	 ecx, ecx

; 58   :   while (isdigit(*Str)) {

  00011	eb 10		 jmp	 SHORT $LN12@StrToNumbe
$LL2@StrToNumbe:
  00013	3c 39		 cmp	 al, 57			; 00000039H
  00015	7f 12		 jg	 SHORT $LN10@StrToNumbe

; 59   :     Sum = Sum * 10 + (*Str++ - '0');

  00017	6b c9 0a	 imul	 ecx, ecx, 10
  0001a	0f be c0	 movsx	 eax, al
  0001d	83 c1 d0	 add	 ecx, -48		; ffffffd0H
  00020	03 c8		 add	 ecx, eax
  00022	42		 inc	 edx
$LN12@StrToNumbe:

; 58   :   while (isdigit(*Str)) {

  00023	8a 02		 mov	 al, BYTE PTR [edx]
  00025	3c 30		 cmp	 al, 48			; 00000030H
  00027	7d ea		 jge	 SHORT $LL2@StrToNumbe
$LN10@StrToNumbe:

; 60   :   }
; 61   :   *String = Str;

  00029	89 16		 mov	 DWORD PTR [esi], edx

; 62   :   return Sum;

  0002b	8b c1		 mov	 eax, ecx
  0002d	5e		 pop	 esi

; 63   : }

  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
_StrToNumber ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\trace\printf.c
;	COMDAT _TraceFunction
_TEXT	SEGMENT
_control$ = 8						; size = 1
_Format$ = 12						; size = 4
_TraceFunction PROC					; COMDAT

; 330  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 331  :   va_list Marker;
; 332  :   PTR_FUNC_NO_ARG pFunc = (PTR_FUNC_NO_ARG)traceRoutines.preTrace;
; 333  : 
; 334  :   if (!(traceControls & control)) {

  00003	a0 00 00 00 00	 mov	 al, BYTE PTR _traceControls
  00008	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _traceRoutines
  0000e	84 45 08	 test	 BYTE PTR _control$[ebp], al
  00011	74 20		 je	 SHORT $LN4@TraceFunct

; 335  :     return;
; 336  :   }
; 337  :   // If ACM has a pre-trace routine, call it.
; 338  :   if (pFunc) {

  00013	85 c9		 test	 ecx, ecx
  00015	74 02		 je	 SHORT $LN3@TraceFunct

; 339  :     (*pFunc)();

  00017	ff d1		 call	 ecx
$LN3@TraceFunct:

; 340  :   }
; 341  :   va_start(Marker, Format);
; 342  :   __printf(Format, Marker);

  00019	8d 45 10	 lea	 eax, DWORD PTR _Format$[ebp+4]
  0001c	50		 push	 eax
  0001d	ff 75 0c	 push	 DWORD PTR _Format$[ebp]
  00020	e8 00 00 00 00	 call	 ___printf

; 343  :   // If ACM has a post-trace routine, call it
; 344  :   pFunc = (PTR_FUNC_NO_ARG)traceRoutines.postTrace;

  00025	a1 04 00 00 00	 mov	 eax, DWORD PTR _traceRoutines+4
  0002a	59		 pop	 ecx
  0002b	59		 pop	 ecx

; 345  :   if (pFunc) {

  0002c	85 c0		 test	 eax, eax
  0002e	74 03		 je	 SHORT $LN4@TraceFunct

; 347  :   }
; 348  :   va_end(Marker);
; 349  :   return;
; 350  : }

  00030	5d		 pop	 ebp

; 346  :     (*pFunc)();

  00031	ff e0		 jmp	 eax
$LN4@TraceFunct:

; 347  :   }
; 348  :   va_end(Marker);
; 349  :   return;
; 350  : }

  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
_TraceFunction ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\trace\printf.c
;	COMDAT _PrintBuffer
_TEXT	SEGMENT
_control$ = 8						; size = 1
_buffer$ = 12						; size = 4
_size$ = 16						; size = 4
_fmt$ = 20						; size = 4
_PrintBuffer PROC					; COMDAT

; 354  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 355  :   va_list Marker;
; 356  :   UINT32 i;
; 357  :   PTR_FUNC_NO_ARG pFunc = (PTR_FUNC_NO_ARG)traceRoutines.preTrace;
; 358  : 
; 359  :   if (!(traceControls & control)) {

  00003	a0 00 00 00 00	 mov	 al, BYTE PTR _traceControls
  00008	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _traceRoutines
  0000e	84 45 08	 test	 BYTE PTR _control$[ebp], al
  00011	74 63		 je	 SHORT $LN8@PrintBuffe

; 360  :     return;
; 361  :   }
; 362  :   // If ACM has a pre-trace routine, call it.
; 363  :   if (pFunc) {

  00013	85 c9		 test	 ecx, ecx
  00015	74 02		 je	 SHORT $LN6@PrintBuffe

; 364  :     (*pFunc)();

  00017	ff d1		 call	 ecx
$LN6@PrintBuffe:
  00019	53		 push	 ebx
  0001a	57		 push	 edi

; 365  :   }
; 366  :   va_start(Marker, fmt);
; 367  :   __printf(fmt, Marker);

  0001b	8d 45 18	 lea	 eax, DWORD PTR _fmt$[ebp+4]
  0001e	50		 push	 eax
  0001f	ff 75 14	 push	 DWORD PTR _fmt$[ebp]
  00022	e8 00 00 00 00	 call	 ___printf

; 368  :   va_end(Marker);
; 369  :   for (i = 0; i < size; ++i, ++buffer) {

  00027	33 db		 xor	 ebx, ebx
  00029	bf 00 00 00 00	 mov	 edi, OFFSET ??_C@_01EEMJAFIK@?6?$AA@IMHBAIGO@
  0002e	59		 pop	 ecx
  0002f	59		 pop	 ecx
  00030	39 5d 10	 cmp	 DWORD PTR _size$[ebp], ebx
  00033	76 2c		 jbe	 SHORT $LN3@PrintBuffe
  00035	56		 push	 esi
  00036	8b 75 0c	 mov	 esi, DWORD PTR _buffer$[ebp]
$LL4@PrintBuffe:

; 370  :     if (i && !(i % 16)) {

  00039	85 db		 test	 ebx, ebx
  0003b	74 0c		 je	 SHORT $LN7@PrintBuffe
  0003d	f6 c3 0f	 test	 bl, 15			; 0000000fH
  00040	75 07		 jne	 SHORT $LN7@PrintBuffe

; 371  :       _printf("\n");

  00042	57		 push	 edi
  00043	e8 00 00 00 00	 call	 __printf
  00048	59		 pop	 ecx
$LN7@PrintBuffe:

; 372  :     }
; 373  :     _printf("%02x ", *buffer);

  00049	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  0004c	50		 push	 eax
  0004d	68 00 00 00 00	 push	 OFFSET ??_C@_05CNDJFPDP@?$CF02x?5?$AA@IMHBAIGO@
  00052	e8 00 00 00 00	 call	 __printf
  00057	43		 inc	 ebx
  00058	46		 inc	 esi
  00059	59		 pop	 ecx
  0005a	59		 pop	 ecx
  0005b	3b 5d 10	 cmp	 ebx, DWORD PTR _size$[ebp]
  0005e	72 d9		 jb	 SHORT $LL4@PrintBuffe
  00060	5e		 pop	 esi
$LN3@PrintBuffe:

; 374  :   }
; 375  :   _printf("\n");

  00061	57		 push	 edi
  00062	e8 00 00 00 00	 call	 __printf

; 376  :   pFunc = (PTR_FUNC_NO_ARG)traceRoutines.postTrace;

  00067	a1 04 00 00 00	 mov	 eax, DWORD PTR _traceRoutines+4
  0006c	59		 pop	 ecx
  0006d	5f		 pop	 edi
  0006e	5b		 pop	 ebx

; 377  :   if (pFunc) {

  0006f	85 c0		 test	 eax, eax
  00071	74 03		 je	 SHORT $LN8@PrintBuffe

; 379  :   }
; 380  : }

  00073	5d		 pop	 ebp

; 378  :     (*pFunc)();

  00074	ff e0		 jmp	 eax
$LN8@PrintBuffe:

; 379  :   }
; 380  : }

  00076	5d		 pop	 ebp
  00077	c3		 ret	 0
_PrintBuffer ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\trace\printf.c
;	COMDAT _Printf
_TEXT	SEGMENT
_Format$ = 8						; size = 4
_Printf	PROC						; COMDAT

; 309  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 310  :   va_list Marker;
; 311  :   PTR_FUNC_NO_ARG pFunc = (PTR_FUNC_NO_ARG)traceRoutines.preTrace;

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR _traceRoutines

; 312  : 
; 313  :   // If ACM has a pre-trace routine, call it.
; 314  :   if (pFunc) {

  00008	85 c0		 test	 eax, eax
  0000a	74 02		 je	 SHORT $LN2@Printf

; 315  :     (*pFunc)();

  0000c	ff d0		 call	 eax
$LN2@Printf:

; 316  :   }
; 317  :   va_start(Marker, Format);
; 318  :   __printf(Format, Marker);

  0000e	8d 45 0c	 lea	 eax, DWORD PTR _Format$[ebp+4]
  00011	50		 push	 eax
  00012	ff 75 08	 push	 DWORD PTR _Format$[ebp]
  00015	e8 00 00 00 00	 call	 ___printf

; 319  :   // If ACM has a post-trace routine, call it
; 320  :   pFunc = (PTR_FUNC_NO_ARG)traceRoutines.postTrace;

  0001a	a1 04 00 00 00	 mov	 eax, DWORD PTR _traceRoutines+4
  0001f	59		 pop	 ecx
  00020	59		 pop	 ecx

; 321  :   if (pFunc) {

  00021	85 c0		 test	 eax, eax
  00023	74 03		 je	 SHORT $LN3@Printf

; 323  :   }
; 324  :   va_end(Marker);
; 325  :   return;
; 326  : }

  00025	5d		 pop	 ebp

; 322  :     (*pFunc)();

  00026	ff e0		 jmp	 eax
$LN3@Printf:

; 323  :   }
; 324  :   va_end(Marker);
; 325  :   return;
; 326  : }

  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
_Printf	ENDP
_TEXT	ENDS
END

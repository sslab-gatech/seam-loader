; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24245.0 

	TITLE	D:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\Core\Server\Trace\serialcom.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_SerialWriteString
PUBLIC	??_C@_0BB@LIHNHEFH@_serialPortReady?$AA@IMHBAIGO@ ;  ?? ::IMHBAIGO::`string'
EXTRN	___InPort8:PROC
EXTRN	___OutPort8:PROC
EXTRN	_Wait1ms:PROC
EXTRN	_traceRoutines:BYTE
EXTRN	_comport:DWORD
EXTRN	_accessType:BYTE
;	COMDAT ??_C@_0BB@LIHNHEFH@_serialPortReady?$AA@IMHBAIGO@
EDATA32	SEGMENT
??_C@_0BB@LIHNHEFH@_serialPortReady?$AA@IMHBAIGO@ DB '_serialPortReady', 00H ;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\server\trace\serialcom.c
;	COMDAT __serialPortReady
_TEXT	SEGMENT
_maxRetries$ = 8					; size = 1
__serialPortReady PROC					; COMDAT

; 77   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 78   : 	UINT16 retries = maxRetries;
; 79   : 
; 80   : 	if(!IS_TRACE_ENABLED) {

  00003	f6 05 0c 00 00
	00 01		 test	 BYTE PTR _traceRoutines+12, 1
  0000a	0f b6 45 08	 movzx	 eax, BYTE PTR _maxRetries$[ebp]
  0000e	56		 push	 esi
  0000f	8b f0		 mov	 esi, eax
  00011	75 04		 jne	 SHORT $LL4@serialPort
$LN22@serialPort:

; 81   : 		return 0;

  00013	32 c0		 xor	 al, al
  00015	eb 3d		 jmp	 SHORT $LN1@serialPort
$LL4@serialPort:

; 82   : 	}
; 83   : 	do {
; 84   : 	  Wait1ms();

  00017	e8 00 00 00 00	 call	 _Wait1ms

; 85   : 	  if (_serialReadStatus()) {

  0001c	e8 00 00 00 00	 call	 __serialReadStatus
  00021	85 c0		 test	 eax, eax
  00023	75 0b		 jne	 SHORT $LN3@serialPort

; 86   : 	    break;
; 87   : 	  }
; 88   : 	} while (--retries);

  00025	81 c6 ff ff 00
	00		 add	 esi, 65535		; 0000ffffH
  0002b	66 85 f6	 test	 si, si
  0002e	75 e7		 jne	 SHORT $LL4@serialPort
$LN3@serialPort:

; 89   : 
; 90   : 	if (!retries) {

  00030	66 85 f6	 test	 si, si
  00033	75 1d		 jne	 SHORT $LN10@serialPort

; 91   : 	  SET_NO_TRACE;

  00035	83 25 0c 00 00
	00 fe		 and	 DWORD PTR _traceRoutines+12, -2 ; fffffffeH
  0003c	c7 05 14 00 00
	00 5b 00 00 00	 mov	 DWORD PTR _traceRoutines+20, 91 ; 0000005bH
  00046	c7 05 18 00 00
	00 00 00 00 00	 mov	 DWORD PTR _traceRoutines+24, OFFSET ??_C@_0BB@LIHNHEFH@_serialPortReady?$AA@IMHBAIGO@

; 92   : 	  return (0);

  00050	eb c1		 jmp	 SHORT $LN22@serialPort
$LN10@serialPort:

; 93   : 	}
; 94   : 	return 1;

  00052	b0 01		 mov	 al, 1
$LN1@serialPort:
  00054	5e		 pop	 esi

; 95   : }

  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
__serialPortReady ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\server\trace\serialcom.c
;	COMDAT __serialWriteChar
_TEXT	SEGMENT
_c$ = 8							; size = 1
__serialWriteChar PROC					; COMDAT

; 66   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 67   :   if ( c == CHAR_LF ) {

  00003	80 7d 08 0a	 cmp	 BYTE PTR _c$[ebp], 10	; 0000000aH
  00007	75 08		 jne	 SHORT $LN2@serialWrit

; 68   :     // Make LF into CR LF
; 69   :     __serialWriteChar(CHAR_CR);

  00009	6a 0d		 push	 13			; 0000000dH
  0000b	e8 00 00 00 00	 call	 ___serialWriteChar
  00010	59		 pop	 ecx
$LN2@serialWrit:

; 72   : }

  00011	5d		 pop	 ebp

; 70   :   }
; 71   :   __serialWriteChar(c);

  00012	e9 00 00 00 00	 jmp	 ___serialWriteChar
__serialWriteChar ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\server\trace\serialcom.c
;	COMDAT ___serialWriteChar
_TEXT	SEGMENT
_c$ = 8							; size = 1
___serialWriteChar PROC					; COMDAT

; 53   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
$LL2@serialWrit:

; 54   :   while (!_serialReadStatus()) {

  00003	e8 00 00 00 00	 call	 __serialReadStatus
  00008	85 c0		 test	 eax, eax
  0000a	74 f7		 je	 SHORT $LL2@serialWrit

; 55   :     ;
; 56   :   }
; 57   :   if (accessType == SERIAL_IO)

  0000c	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR _accessType, 0
  00013	75 14		 jne	 SHORT $LN4@serialWrit

; 58   :     __OutPort8(comport + TRANSMIT_HOLDING, (UINT8)c);

  00015	ff 75 08	 push	 DWORD PTR _c$[ebp]
  00018	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR _comport
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ___OutPort8
  00025	59		 pop	 ecx
  00026	59		 pop	 ecx

; 61   : }

  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
$LN4@serialWrit:

; 59   :   else
; 60   :     __WriteMmioByte(comport + TRANSMIT_HOLDING, (UINT8)c);

  00029	a1 00 00 00 00	 mov	 eax, DWORD PTR _comport
  0002e	8a 4d 08	 mov	 cl, BYTE PTR _c$[ebp]
  00031	88 08		 mov	 BYTE PTR [eax], cl

; 61   : }

  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
___serialWriteChar ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\server\trace\serialcom.c
;	COMDAT __serialReadStatus
_TEXT	SEGMENT
__serialReadStatus PROC					; COMDAT

; 36   :   UINT8 sts;
; 37   :   if (accessType == SERIAL_IO)

  00000	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR _accessType, 0

; 38   :     sts = __InPort8(comport + LINE_STATUS);

  00007	a1 00 00 00 00	 mov	 eax, DWORD PTR _comport
  0000c	75 0c		 jne	 SHORT $LN2@serialRead
  0000e	83 c0 05	 add	 eax, 5
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ___InPort8
  00017	59		 pop	 ecx
  00018	eb 03		 jmp	 SHORT $LN3@serialRead
$LN2@serialRead:

; 39   :   else
; 40   :     sts = __ReadMmioByte(comport + LINE_STATUS);

  0001a	8a 40 05	 mov	 al, BYTE PTR [eax+5]
$LN3@serialRead:

; 41   :   return ((sts & TRANS_HOLDING_REG_EMPTY)? 1 : 0);

  0001d	0f b6 c0	 movzx	 eax, al
  00020	c1 e8 05	 shr	 eax, 5
  00023	83 e0 01	 and	 eax, 1

; 42   : }

  00026	c3		 ret	 0
__serialReadStatus ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\server\trace\serialcom.c
;	COMDAT _SerialWriteString
_TEXT	SEGMENT
_str$ = 8						; size = 4
_len$ = 12						; size = 4
_SerialWriteString PROC					; COMDAT

; 99   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 100  :   if (!_serialPortReady(traceRoutines.maxTimeout)) {

  00003	0f b6 05 10 00
	00 00		 movzx	 eax, BYTE PTR _traceRoutines+16
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 __serialPortReady
  00010	59		 pop	 ecx
  00011	84 c0		 test	 al, al
  00013	75 04		 jne	 SHORT $LN6@SerialWrit

; 101  :     return -1;

  00015	0c ff		 or	 al, 255			; 000000ffH

; 113  : }

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
$LN6@SerialWrit:
  00019	56		 push	 esi

; 102  :   }
; 103  :   if (len) {

  0001a	8b 75 0c	 mov	 esi, DWORD PTR _len$[ebp]
  0001d	85 f6		 test	 esi, esi
  0001f	74 17		 je	 SHORT $LN10@SerialWrit
  00021	57		 push	 edi
  00022	8b 7d 08	 mov	 edi, DWORD PTR _str$[ebp]
$LL2@SerialWrit:

; 104  :     while (len--) {
; 105  :       _serialWriteChar(*str++);

  00025	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 __serialWriteChar
  0002e	47		 inc	 edi
  0002f	59		 pop	 ecx
  00030	83 ee 01	 sub	 esi, 1
  00033	75 f0		 jne	 SHORT $LL2@SerialWrit
  00035	5f		 pop	 edi

; 106  :     }
; 107  :     return 0;

  00036	eb 15		 jmp	 SHORT $LN19@SerialWrit
$LN10@SerialWrit:

; 108  :   }
; 109  :   while (*str != '\0') {

  00038	8b 75 08	 mov	 esi, DWORD PTR _str$[ebp]
  0003b	53		 push	 ebx
  0003c	eb 08		 jmp	 SHORT $LN21@SerialWrit
$LL4@SerialWrit:

; 110  :     _serialWriteChar(*str++);

  0003e	53		 push	 ebx
  0003f	e8 00 00 00 00	 call	 __serialWriteChar
  00044	59		 pop	 ecx
  00045	46		 inc	 esi
$LN21@SerialWrit:

; 108  :   }
; 109  :   while (*str != '\0') {

  00046	8a 1e		 mov	 bl, BYTE PTR [esi]
  00048	84 db		 test	 bl, bl
  0004a	75 f2		 jne	 SHORT $LL4@SerialWrit
  0004c	5b		 pop	 ebx
$LN19@SerialWrit:

; 111  :   }
; 112  :   return 0;

  0004d	32 c0		 xor	 al, al
  0004f	5e		 pop	 esi

; 113  : }

  00050	5d		 pop	 ebp
  00051	c3		 ret	 0
_SerialWriteString ENDP
_TEXT	ENDS
END

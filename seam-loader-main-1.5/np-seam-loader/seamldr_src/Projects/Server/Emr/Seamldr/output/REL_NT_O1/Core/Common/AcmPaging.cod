; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24245.0 

	TITLE	D:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\Core\Common\AcmPaging.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_SeamldrPagingTable
EDATA32	SEGMENT
_SeamldrPagingTable DB 0a000H DUP (?)
EDATA32	ENDS
PUBLIC	_EstablishSeamldrPaging
EXTRN	_AcmEntryPoint:PROC
EXTRN	_fillMemory:PROC
EXTRN	___readMsr:PROC
EXTRN	___writeMsr:PROC
EXTRN	_AcmBase:DWORD
EXTRN	_AcmSize:DWORD
EXTRN	_SeamldrCom64Data:BYTE
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\common\acmpaging.c
;	COMDAT _IsCodeAcmPage
_TEXT	SEGMENT
_PE2BIN_Com_Data$ = 8					; size = 4
_Page$ = 12						; size = 4
_IsCodeAcmPage PROC					; COMDAT

; 59   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 60   :   // The structure of the ACM is as follows (from low addresses to high):
; 61   :   // 32-bit data and stack
; 62   :   // 32-bit code
; 63   :   // 64-bit data
; 64   :   // 64-bit code
; 65   : 
; 66   :   if (((Page >= PE2BIN_Com_Data->Code32Start) && (Page < PE2BIN_Com_Data->Data64Start)) ||

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _PE2BIN_Com_Data$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR _Page$[ebp]
  00009	3b 41 14	 cmp	 eax, DWORD PTR [ecx+20]
  0000c	72 04		 jb	 SHORT $LN4@IsCodeAcmP
  0000e	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00010	72 0a		 jb	 SHORT $LN3@IsCodeAcmP
$LN4@IsCodeAcmP:
  00012	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00015	72 09		 jb	 SHORT $LN2@IsCodeAcmP
  00017	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  0001a	73 04		 jae	 SHORT $LN2@IsCodeAcmP
$LN3@IsCodeAcmP:

; 67   :       ((Page >= PE2BIN_Com_Data->Code64Start) && (Page < PE2BIN_Com_Data->Code64End))) {
; 68   :     return TRUE;

  0001c	b0 01		 mov	 al, 1

; 72   : }

  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
$LN2@IsCodeAcmP:

; 69   :   }
; 70   : 
; 71   :   return FALSE;

  00020	32 c0		 xor	 al, al

; 72   : }

  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
_IsCodeAcmPage ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\common\acmpaging.c
;	COMDAT _Map4KPage
_TEXT	SEGMENT
_LeafPXE$ = 8						; size = 4
_PhysBase$ = 12						; size = 8
_IsWritable$ = 20					; size = 1
_IsWBMemtype$ = 24					; size = 1
_IsExecutable$ = 28					; size = 1
_Map4KPage PROC						; COMDAT

; 34   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 35   :   LeafPXE->Raw = PhysBase;

  00003	8b 55 08	 mov	 edx, DWORD PTR _LeafPXE$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	8b 45 0c	 mov	 eax, DWORD PTR _PhysBase$[ebp]
  0000b	38 4d 14	 cmp	 BYTE PTR _IsWritable$[ebp], cl
  0000e	6a 02		 push	 2
  00010	89 02		 mov	 DWORD PTR [edx], eax
  00012	8b 45 10	 mov	 eax, DWORD PTR _PhysBase$[ebp+4]
  00015	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00018	58		 pop	 eax
  00019	0f 45 c8	 cmovne	 ecx, eax

; 36   :   LeafPXE->Fields4K.P = 1;
; 37   :   LeafPXE->Fields4K.RW = (IsWritable) ? 1 : 0;
; 38   :   LeafPXE->Fields4K.A = 1;
; 39   :   LeafPXE->Fields4K.D = 1;

  0001c	8b 02		 mov	 eax, DWORD PTR [edx]
  0001e	83 e0 fd	 and	 eax, -3			; fffffffdH
  00021	0b c8		 or	 ecx, eax
  00023	83 c9 61	 or	 ecx, 97			; 00000061H

; 40   : 
; 41   :   if (!IsExecutable) {

  00026	80 7d 1c 00	 cmp	 BYTE PTR _IsExecutable$[ebp], 0
  0002a	89 0a		 mov	 DWORD PTR [edx], ecx
  0002c	75 0b		 jne	 SHORT $LN2@Map4KPage

; 42   :     LeafPXE->Raw |= BIT63;

  0002e	81 4a 04 00 00
	00 80		 or	 DWORD PTR [edx+4], -2147483648 ; 80000000H
  00035	8b c1		 mov	 eax, ecx
  00037	89 02		 mov	 DWORD PTR [edx], eax
$LN2@Map4KPage:

; 43   :   }
; 44   : 
; 45   :   if (IsWBMemtype) {

  00039	80 7d 18 00	 cmp	 BYTE PTR _IsWBMemtype$[ebp], 0
  0003d	74 08		 je	 SHORT $LN3@Map4KPage

; 46   :     // PAT0 is supposed to be WB memtype
; 47   :     LeafPXE->Fields4K.PAT = 0;
; 48   :     LeafPXE->Fields4K.PWT = 0;
; 49   :     LeafPXE->Fields4K.PCD = 0;

  0003f	81 22 67 ff ff
	ff		 and	 DWORD PTR [edx], -153	; ffffff67H

; 55   :   }
; 56   : }

  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
$LN3@Map4KPage:

; 50   :   } else {
; 51   :     // PAT7 is supposed to be UC memtype
; 52   :     LeafPXE->Fields4K.PAT = 1;
; 53   :     LeafPXE->Fields4K.PWT = 1;
; 54   :     LeafPXE->Fields4K.PCD = 1;

  00047	81 0a 98 00 00
	00		 or	 DWORD PTR [edx], 152	; 00000098H

; 55   :   }
; 56   : }

  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
_Map4KPage ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\common\acmpaging.c
;	COMDAT _MapPagingStructure
_TEXT	SEGMENT
_ParentPXE$ = 8						; size = 4
_ChildPXBase$ = 12					; size = 4
_MapPagingStructure PROC				; COMDAT

; 26   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 27   :   ParentPXE->Raw = (UINT64)(UINTPTR)ChildPXBase;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _ParentPXE$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR _ChildPXBase$[ebp]
  00009	83 61 04 00	 and	 DWORD PTR [ecx+4], 0
  0000d	89 01		 mov	 DWORD PTR [ecx], eax

; 28   :   ParentPXE->FieldsPS.P = 1;
; 29   :   ParentPXE->FieldsPS.RW = 1;
; 30   :   ParentPXE->FieldsPS.A = 1;

  0000f	83 09 23	 or	 DWORD PTR [ecx], 35	; 00000023H

; 31   : }

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
_MapPagingStructure ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\common\acmpaging.c
;	COMDAT _EstablishSeamldrPaging
_TEXT	SEGMENT
_RDX$ = -32						; size = 4
_Pd$1$ = -28						; size = 4
_LastPtIdx$1$ = -24					; size = 4
tv431 = -20						; size = 4
_RAX$ = -16						; size = 4
_PE2BIN_Com_Data$1$ = -12				; size = 4
_PdptIdx$2$ = -8					; size = 4
tv428 = -4						; size = 4
_PdIdx$1$ = -4						; size = 4
_pCom64$ = 8						; size = 4
_PtCtx$ = 12						; size = 4
_EstablishSeamldrPaging PROC				; COMDAT

; 79   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 80   :   COM_DATA *PE2BIN_Com_Data = (COM_DATA *)((UINT32)AcmEntryPoint - sizeof(COM_DATA));
; 81   : 
; 82   :   (void) pCom64; // unused
; 83   : 
; 84   :   fillMemory((UINT8 *)&SeamldrPagingTable, 0, sizeof(SEAMLDR_PAGING_TABLE_T));

  00009	68 00 a0 00 00	 push	 40960			; 0000a000H
  0000e	b8 00 00 00 00	 mov	 eax, OFFSET _AcmEntryPoint
  00013	bb 00 00 00 00	 mov	 ebx, OFFSET _SeamldrPagingTable
  00018	83 e8 18	 sub	 eax, 24			; 00000018H
  0001b	6a 00		 push	 0
  0001d	53		 push	 ebx
  0001e	89 45 f4	 mov	 DWORD PTR _PE2BIN_Com_Data$1$[ebp], eax
  00021	e8 00 00 00 00	 call	 _fillMemory

; 85   : 
; 86   :   // We will use index 0 for PML5 and PML4 because we aren't going to map linear addresses above 4GB
; 87   :   MapPagingStructure(&SeamldrPagingTable.Pml5.PT[0], &SeamldrPagingTable.Pml4);

  00026	be 00 10 00 00	 mov	 esi, OFFSET _SeamldrPagingTable+4096
  0002b	56		 push	 esi
  0002c	53		 push	 ebx
  0002d	e8 00 00 00 00	 call	 _MapPagingStructure

; 88   :   MapPagingStructure(&SeamldrPagingTable.Pml4.PT[0], &SeamldrPagingTable.Pdpt);

  00032	ba 00 20 00 00	 mov	 edx, OFFSET _SeamldrPagingTable+8192
  00037	52		 push	 edx
  00038	56		 push	 esi
  00039	e8 00 00 00 00	 call	 _MapPagingStructure

; 89   : 
; 90   :   // First indexes 0-3 in PDPT covers the whole lower 4 GB (each PD table cover 512 entries of 2MB, there are 4 PD tables)
; 91   :   MapPagingStructure(&SeamldrPagingTable.Pdpt.PT[0], &SeamldrPagingTable.Pd[0]);

  0003e	68 00 30 00 00	 push	 OFFSET _SeamldrPagingTable+12288
  00043	52		 push	 edx
  00044	e8 00 00 00 00	 call	 _MapPagingStructure

; 92   :   MapPagingStructure(&SeamldrPagingTable.Pdpt.PT[1], &SeamldrPagingTable.Pd[1]);

  00049	68 00 40 00 00	 push	 OFFSET _SeamldrPagingTable+16384
  0004e	68 08 20 00 00	 push	 OFFSET _SeamldrPagingTable+8200
  00053	e8 00 00 00 00	 call	 _MapPagingStructure

; 93   :   MapPagingStructure(&SeamldrPagingTable.Pdpt.PT[2], &SeamldrPagingTable.Pd[2]);

  00058	68 00 50 00 00	 push	 OFFSET _SeamldrPagingTable+20480
  0005d	68 10 20 00 00	 push	 OFFSET _SeamldrPagingTable+8208
  00062	e8 00 00 00 00	 call	 _MapPagingStructure

; 94   :   MapPagingStructure(&SeamldrPagingTable.Pdpt.PT[3], &SeamldrPagingTable.Pd[3]);

  00067	68 00 60 00 00	 push	 OFFSET _SeamldrPagingTable+24576
  0006c	68 18 20 00 00	 push	 OFFSET _SeamldrPagingTable+8216
  00071	e8 00 00 00 00	 call	 _MapPagingStructure

; 95   : 
; 96   :   // We will fill the entries in PD tables later, at this point they are empty and don't map anything
; 97   : 
; 98   :   // Now we need to establish 1-to-1 paging for the SEAMLDR ACM address space
; 99   :   // We need to map data/stack pages with XD (execute disabled) bit, and code pages as read-only
; 100  :   // The structure of the ACM is as follows (from low addresses to high):
; 101  :   // 32-bit data and stack
; 102  :   // 32-bit code
; 103  :   // 64-bit data
; 104  :   // 64-bit code
; 105  :   // These offsets are stored in COM_DATA
; 106  : 
; 107  :   // Only bits 30:31 are relevant for low 4GB
; 108  :   UINT32 PdptIdx = ((AcmBase >> 30) & 0x3);

  00076	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _AcmBase

; 109  :   // Mask the 9 index bits
; 110  :   UINT32 PdIdx = ((AcmBase >> 21) & 0x1FF);

  0007c	be ff 01 00 00	 mov	 esi, 511		; 000001ffH
  00081	8b c7		 mov	 eax, edi
  00083	8b d7		 mov	 edx, edi
  00085	c1 e8 1e	 shr	 eax, 30			; 0000001eH

; 111  : 
; 112  :   IA32E_PAGING_TABLE_T *Pd = &SeamldrPagingTable.Pd[PdptIdx];

  00088	8b d8		 mov	 ebx, eax
  0008a	c1 ea 15	 shr	 edx, 21			; 00000015H
  0008d	c1 e3 0c	 shl	 ebx, 12			; 0000000cH
  00090	23 d6		 and	 edx, esi
  00092	81 c3 00 30 00
	00		 add	 ebx, OFFSET _SeamldrPagingTable+12288
  00098	89 45 f8	 mov	 DWORD PTR _PdptIdx$2$[ebp], eax

; 113  : 
; 114  :   MapPagingStructure(&Pd->PT[PdIdx], &SeamldrPagingTable.Pt[0]);

  0009b	68 00 70 00 00	 push	 OFFSET _SeamldrPagingTable+28672
  000a0	89 55 fc	 mov	 DWORD PTR _PdIdx$1$[ebp], edx
  000a3	89 5d e4	 mov	 DWORD PTR _Pd$1$[ebp], ebx
  000a6	8d 04 d3	 lea	 eax, DWORD PTR [ebx+edx*8]
  000a9	50		 push	 eax
  000aa	e8 00 00 00 00	 call	 _MapPagingStructure

; 115  : 
; 116  :   UINT32 PtIdx = ((AcmBase >> 12) & 0x1FF);

  000af	8b c7		 mov	 eax, edi
  000b1	83 c4 44	 add	 esp, 68			; 00000044H
  000b4	c1 e8 0c	 shr	 eax, 12			; 0000000cH
  000b7	23 c6		 and	 eax, esi

; 117  :   UINT32 LastPtIdx = PtIdx + (rounded(AcmSize, PAGE_SIZE) / PAGE_SIZE);

  000b9	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _AcmSize
  000bf	f7 c6 ff 0f 00
	00		 test	 esi, 4095		; 00000fffH
  000c5	74 07		 je	 SHORT $LN19@EstablishS
  000c7	c1 ee 0c	 shr	 esi, 12			; 0000000cH
  000ca	46		 inc	 esi
  000cb	c1 e6 0c	 shl	 esi, 12			; 0000000cH
$LN19@EstablishS:
  000ce	c1 ee 0c	 shr	 esi, 12			; 0000000cH

; 118  :   UINT32 CurrentAcmPageToMap = AcmBase;
; 119  : 
; 120  :   IA32E_PAGING_TABLE_T *Pt = &SeamldrPagingTable.Pt[0];
; 121  : 
; 122  :   // Map the ACM 4K pages until the last index in the PT table (must be 1:1 mapping)
; 123  :   for (UINT32 i = PtIdx; i < ((LastPtIdx < 512) ? LastPtIdx : 512); i++) {

  000d1	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  000d6	03 f0		 add	 esi, eax
  000d8	3b f1		 cmp	 esi, ecx
  000da	89 75 e8	 mov	 DWORD PTR _LastPtIdx$1$[ebp], esi
  000dd	0f 42 ce	 cmovb	 ecx, esi
  000e0	3b c1		 cmp	 eax, ecx
  000e2	73 4e		 jae	 SHORT $LN3@EstablishS

; 117  :   UINT32 LastPtIdx = PtIdx + (rounded(AcmSize, PAGE_SIZE) / PAGE_SIZE);

  000e4	2b c8		 sub	 ecx, eax
  000e6	8d 1c c5 00 70
	00 00		 lea	 ebx, DWORD PTR _SeamldrPagingTable[eax*8+28672]
  000ed	89 4d ec	 mov	 DWORD PTR tv431[ebp], ecx
  000f0	8b f1		 mov	 esi, ecx
$LL4@EstablishS:

; 124  :     if (IsCodeAcmPage(PE2BIN_Com_Data, CurrentAcmPageToMap)) {

  000f2	57		 push	 edi
  000f3	ff 75 f4	 push	 DWORD PTR _PE2BIN_Com_Data$1$[ebp]
  000f6	e8 00 00 00 00	 call	 _IsCodeAcmPage
  000fb	59		 pop	 ecx
  000fc	59		 pop	 ecx
  000fd	84 c0		 test	 al, al
  000ff	74 08		 je	 SHORT $LN8@EstablishS

; 125  :       Map4KPage(&Pt->PT[i], CurrentAcmPageToMap, FALSE, TRUE, TRUE); // Not-writable, WB memtype, Executable

  00101	6a 01		 push	 1
  00103	6a 01		 push	 1
  00105	6a 00		 push	 0

; 126  :     } else {

  00107	eb 06		 jmp	 SHORT $LN28@EstablishS
$LN8@EstablishS:

; 127  :       Map4KPage(&Pt->PT[i], CurrentAcmPageToMap, TRUE, TRUE, FALSE); // Writable, WB memtype, Non-executable

  00109	6a 00		 push	 0
  0010b	6a 01		 push	 1
  0010d	6a 01		 push	 1
$LN28@EstablishS:
  0010f	6a 00		 push	 0
  00111	57		 push	 edi
  00112	53		 push	 ebx
  00113	e8 00 00 00 00	 call	 _Map4KPage
  00118	83 c4 18	 add	 esp, 24			; 00000018H

; 128  :     }
; 129  :     CurrentAcmPageToMap += PAGE_SIZE;

  0011b	81 c7 00 10 00
	00		 add	 edi, 4096		; 00001000H
  00121	83 c3 08	 add	 ebx, 8
  00124	83 ee 01	 sub	 esi, 1
  00127	75 c9		 jne	 SHORT $LL4@EstablishS
  00129	8b 75 e8	 mov	 esi, DWORD PTR _LastPtIdx$1$[ebp]
  0012c	8b 5d e4	 mov	 ebx, DWORD PTR _Pd$1$[ebp]
  0012f	8b 55 fc	 mov	 edx, DWORD PTR _PdIdx$1$[ebp]
$LN3@EstablishS:

; 130  :   }
; 131  : 
; 132  :   if (LastPtIdx > 512) {

  00132	81 fe 00 02 00
	00		 cmp	 esi, 512		; 00000200H
  00138	76 7d		 jbe	 SHORT $LN6@EstablishS

; 133  :     // In case when the Acm mapping spans over two page tables, we need to map the PtTable1 in the PD
; 134  :     // However there's also a possibility that we were on our last slot in the current PD, so we need to switch to the next one
; 135  :     if (PdIdx == 511) {

  0013a	81 fa ff 01 00
	00		 cmp	 edx, 511		; 000001ffH
  00140	75 16		 jne	 SHORT $LN11@EstablishS

; 136  :       // We won't span over the 4GB boundary in Acm, so it's ok to just +1 the PDPT index
; 137  :       PdptIdx = PdptIdx + 1;

  00142	8b 45 f8	 mov	 eax, DWORD PTR _PdptIdx$2$[ebp]
  00145	40		 inc	 eax

; 138  :       Pd = &SeamldrPagingTable.Pd[PdptIdx];

  00146	8b d8		 mov	 ebx, eax
  00148	89 45 f8	 mov	 DWORD PTR _PdptIdx$2$[ebp], eax
  0014b	c1 e3 0c	 shl	 ebx, 12			; 0000000cH
  0014e	81 c3 00 30 00
	00		 add	 ebx, OFFSET _SeamldrPagingTable+12288

; 139  :       PdIdx = 0;

  00154	33 c0		 xor	 eax, eax

; 140  :     } else {

  00156	eb 06		 jmp	 SHORT $LN12@EstablishS
$LN11@EstablishS:

; 141  :       PdIdx = PdIdx + 1;

  00158	42		 inc	 edx
  00159	89 55 fc	 mov	 DWORD PTR _PdIdx$1$[ebp], edx
  0015c	8b c2		 mov	 eax, edx
$LN12@EstablishS:

; 142  :     }
; 143  : 
; 144  :     MapPagingStructure(&Pd->PT[PdIdx], &SeamldrPagingTable.Pt[1]);

  0015e	ba 00 80 00 00	 mov	 edx, OFFSET _SeamldrPagingTable+32768
  00163	8d 04 c3	 lea	 eax, DWORD PTR [ebx+eax*8]
  00166	52		 push	 edx
  00167	50		 push	 eax
  00168	89 55 fc	 mov	 DWORD PTR tv428[ebp], edx
  0016b	e8 00 00 00 00	 call	 _MapPagingStructure
  00170	59		 pop	 ecx
  00171	59		 pop	 ecx

; 145  : 
; 146  :     Pt = &SeamldrPagingTable.Pt[1];
; 147  : 
; 148  :     PtIdx = 0;
; 149  :     LastPtIdx = LastPtIdx - 512;

  00172	81 ee 00 02 00
	00		 sub	 esi, 512		; 00000200H

; 150  : 
; 151  :     // Map the rest of the ACM 4K pages
; 152  :     for (UINT32 i = PtIdx; i < LastPtIdx; i++) {

  00178	74 3d		 je	 SHORT $LN6@EstablishS
$LL7@EstablishS:

; 153  :       if (IsCodeAcmPage(PE2BIN_Com_Data, CurrentAcmPageToMap)) {

  0017a	57		 push	 edi
  0017b	ff 75 f4	 push	 DWORD PTR _PE2BIN_Com_Data$1$[ebp]
  0017e	e8 00 00 00 00	 call	 _IsCodeAcmPage
  00183	59		 pop	 ecx
  00184	59		 pop	 ecx
  00185	84 c0		 test	 al, al
  00187	74 08		 je	 SHORT $LN13@EstablishS

; 154  :         Map4KPage(&Pt->PT[i], CurrentAcmPageToMap, FALSE, TRUE, TRUE); // Not-writable, WB memtype, Executable

  00189	6a 01		 push	 1
  0018b	6a 01		 push	 1
  0018d	6a 00		 push	 0

; 155  :       } else {

  0018f	eb 06		 jmp	 SHORT $LN29@EstablishS
$LN13@EstablishS:

; 156  :         Map4KPage(&Pt->PT[i], CurrentAcmPageToMap, TRUE, TRUE, FALSE); // Writable, WB memtype, Non-executable

  00191	6a 00		 push	 0
  00193	6a 01		 push	 1
  00195	6a 01		 push	 1
$LN29@EstablishS:
  00197	6a 00		 push	 0
  00199	57		 push	 edi
  0019a	52		 push	 edx
  0019b	e8 00 00 00 00	 call	 _Map4KPage
  001a0	8b 55 fc	 mov	 edx, DWORD PTR tv428[ebp]
  001a3	83 c4 18	 add	 esp, 24			; 00000018H
  001a6	83 c2 08	 add	 edx, 8

; 157  :       }
; 158  :       CurrentAcmPageToMap += PAGE_SIZE;

  001a9	81 c7 00 10 00
	00		 add	 edi, 4096		; 00001000H
  001af	89 55 fc	 mov	 DWORD PTR tv428[ebp], edx
  001b2	83 ee 01	 sub	 esi, 1
  001b5	75 c3		 jne	 SHORT $LL7@EstablishS
$LN6@EstablishS:

; 159  :     }
; 160  :   }
; 161  : 
; 162  :   // One of the unused PD table will be used for rest of the 4K mappings in the system (not necessary 1 to 1)
; 163  :   PdptIdx = (PdptIdx + 1) % 4;

  001b7	8b 55 f8	 mov	 edx, DWORD PTR _PdptIdx$2$[ebp]

; 164  :   Pd = &SeamldrPagingTable.Pd[PdptIdx];
; 165  : 
; 166  :   // We will use only the first index in the unused PD table for the PT Table 2
; 167  :   // And we won't touch the rest of the indexes, to prevent confusion
; 168  :   MapPagingStructure(&Pd->PT[0], &SeamldrPagingTable.Pt[2]);

  001ba	bf 00 90 00 00	 mov	 edi, OFFSET _SeamldrPagingTable+36864
  001bf	42		 inc	 edx
  001c0	83 e2 03	 and	 edx, 3
  001c3	8b c2		 mov	 eax, edx
  001c5	c1 e0 0c	 shl	 eax, 12			; 0000000cH
  001c8	05 00 30 00 00	 add	 eax, OFFSET _SeamldrPagingTable+12288
  001cd	57		 push	 edi
  001ce	50		 push	 eax
  001cf	e8 00 00 00 00	 call	 _MapPagingStructure

; 169  : 
; 170  :   // Virtual base is calculated as follows:
; 171  :   // PML5 and PML4 index is 0. PDPT index as chosen. PD index 0, PT index is 0
; 172  :   PtCtx->VirtualBaseFor4KMappings = (PdptIdx << 30);

  001d4	8b 75 0c	 mov	 esi, DWORD PTR _PtCtx$[ebp]

; 173  :   PtCtx->PtBaseFor4KMappings = (UINT64)(UINTPTR)&SeamldrPagingTable.Pt[2];
; 174  :   PtCtx->NextFreePtIdx = 0;
; 175  : 
; 176  :   // The last (third or fourth) unused PD table will be used for 2MB mapping in the system (not necessary 1 to 1)
; 177  :   // This table will cover 512 * 2MB space, which 1GB, which should be enough to map the entire SEAMRR
; 178  :   PdptIdx = (PdptIdx + 1) % 4;

  001d7	8d 4a 01	 lea	 ecx, DWORD PTR [edx+1]
  001da	8b c2		 mov	 eax, edx
  001dc	83 e1 03	 and	 ecx, 3
  001df	c1 e0 1e	 shl	 eax, 30			; 0000001eH
  001e2	33 db		 xor	 ebx, ebx
  001e4	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 179  : 
; 180  :   // Virtual base is calculated as follows:
; 181  :   // PML5 and PML4 index is 0. PDPT index as chosen. PD index 0
; 182  :   PtCtx->VirtualBaseFor2MBMappings = (PdptIdx << 30);

  001e7	8b c1		 mov	 eax, ecx
  001e9	c1 e0 1e	 shl	 eax, 30			; 0000001eH
  001ec	89 46 18	 mov	 DWORD PTR [esi+24], eax

; 183  :   PtCtx->PdBaseFor2MBMappings = (UINT64)(UINTPTR)&SeamldrPagingTable.Pd[PdptIdx];
; 184  :   PtCtx->NextFreePdIdx = 0;
; 185  : 
; 186  :   // Prior to enabling paging, the SEAMLDR should configure the IA32_PAT MSR with its reset default value 0x0007040600070406 (i.e.PAT0 = WB, PAT7 = UC).
; 187  :   writeMsr(MSR_IA32_PAT, 0x00070406UL, 0x00070406UL);

  001ef	b8 06 04 07 00	 mov	 eax, 459782		; 00070406H
  001f4	50		 push	 eax
  001f5	c1 e1 0c	 shl	 ecx, 12			; 0000000cH
  001f8	50		 push	 eax
  001f9	81 c1 00 30 00
	00		 add	 ecx, OFFSET _SeamldrPagingTable+12288
  001ff	89 5e 14	 mov	 DWORD PTR [esi+20], ebx
  00202	68 77 02 00 00	 push	 631			; 00000277H
  00207	89 3e		 mov	 DWORD PTR [esi], edi
  00209	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  0020c	89 5e 20	 mov	 DWORD PTR [esi+32], ebx
  0020f	89 5e 1c	 mov	 DWORD PTR [esi+28], ebx
  00212	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00215	89 5e 0c	 mov	 DWORD PTR [esi+12], ebx
  00218	89 5e 24	 mov	 DWORD PTR [esi+36], ebx
  0021b	e8 00 00 00 00	 call	 ___writeMsr
  00220	83 c4 14	 add	 esp, 20			; 00000014H

; 188  : 
; 189  :   // Load CR3 with the PML4/5 base - the SEAMLDR will run with either 4-level or 5-level paging, depending on the original level of the OS
; 190  :   if (SeamldrCom64Data.OriginalCR4 & CR4_LA57) {
; 191  :     __writecr3(&SeamldrPagingTable.Pml5);

  00223	b8 00 00 00 00	 mov	 eax, OFFSET _SeamldrPagingTable
  00228	f7 05 30 00 00
	00 00 10 00 00	 test	 DWORD PTR _SeamldrCom64Data+48, 4096 ; 00001000H
  00232	75 05		 jne	 SHORT $LN30@EstablishS

; 192  :   } else {
; 193  :     __writecr3(&SeamldrPagingTable.Pml4);

  00234	b8 00 10 00 00	 mov	 eax, OFFSET _SeamldrPagingTable+4096
$LN30@EstablishS:
  00239	0f 22 d8	 mov	 cr3, eax

; 194  :   }
; 195  : 
; 196  :   // Set EFER.LME to re-enable ia32-e
; 197  :   UINT32 RDX, RAX;
; 198  : 
; 199  :   readMsr(IA32_EFER_MSR, &RDX, &RAX);

  0023c	8d 45 f0	 lea	 eax, DWORD PTR _RAX$[ebp]
  0023f	bf 80 00 00 c0	 mov	 edi, -1073741696	; c0000080H
  00244	50		 push	 eax
  00245	8d 45 e0	 lea	 eax, DWORD PTR _RDX$[ebp]
  00248	50		 push	 eax
  00249	57		 push	 edi
  0024a	e8 00 00 00 00	 call	 ___readMsr

; 200  :   RAX |= (LME | N_IA32_EFER_NXE);

  0024f	8b 4d f0	 mov	 ecx, DWORD PTR _RAX$[ebp]
  00252	81 c9 00 09 00
	00		 or	 ecx, 2304		; 00000900H

; 201  :   writeMsr(IA32_EFER_MSR, RDX, RAX);

  00258	51		 push	 ecx
  00259	ff 75 e0	 push	 DWORD PTR _RDX$[ebp]
  0025c	89 4d f0	 mov	 DWORD PTR _RAX$[ebp], ecx
  0025f	57		 push	 edi
  00260	e8 00 00 00 00	 call	 ___writeMsr
  00265	83 c4 18	 add	 esp, 24			; 00000018H

; 202  : 
; 203  :   // Enable paging
; 204  :   __writecr0(__readcr0() | CR0_PG | CR0_WP);
; 205  : 
; 206  :   return PtCtx;

  00268	8b c6		 mov	 eax, esi
  0026a	0f 20 c1	 mov	 ecx, cr0
  0026d	81 c9 00 00 01
	80		 or	 ecx, -2147418112	; 80010000H
  00273	0f 22 c1	 mov	 cr0, ecx
  00276	5f		 pop	 edi
  00277	5e		 pop	 esi
  00278	5b		 pop	 ebx

; 207  : }

  00279	8b e5		 mov	 esp, ebp
  0027b	5d		 pop	 ebp
  0027c	c3		 ret	 0
_EstablishSeamldrPaging ENDP
_TEXT	ENDS
END

; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24245.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	memcpy
PUBLIC	memcpy_s
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\accessors64\memcpy64.c
;	COMDAT memcpy_s
_TEXT	SEGMENT
dest$ = 8
destSize$ = 16
src$ = 24
count$ = 32
memcpy_s PROC						; COMDAT

; 56   :   UINT64 Status = NP_SEAMLDR_PARAMS_STATUS_SUCCESS;

  00000	45 33 d2	 xor	 r10d, r10d

; 65   :   const UINT64 src_first_address = src_addr;
; 66   :   const UINT64 src_last_address = src_addr + count - 1;
; 67   : 
; 68   :   if ((destSize < count) ||
; 69   :       (dst_addr > MAX_QWORD - count - 1) ||      

  00003	49 3b d1	 cmp	 rdx, r9
  00006	72 6a		 jb	 SHORT $LN7@memcpy_s
  00008	49 8d 42 fe	 lea	 rax, QWORD PTR [r10-2]
  0000c	49 2b c1	 sub	 rax, r9
  0000f	48 3b c8	 cmp	 rcx, rax
  00012	77 5e		 ja	 SHORT $LN7@memcpy_s
  00014	49 8d 41 ff	 lea	 rax, QWORD PTR [r9-1]
  00018	49 03 c0	 add	 rax, r8
  0001b	49 3b c0	 cmp	 rax, r8
  0001e	72 52		 jb	 SHORT $LN7@memcpy_s

; 73   :       goto EXIT;
; 74   :   }
; 75   : 
; 76   :   // check if we have an overlap between source and destination
; 77   :   if (((dst_first_address > src_last_address) || (dst_last_address < src_first_address)) == FALSE)

  00020	48 3b c8	 cmp	 rcx, rax
  00023	77 0c		 ja	 SHORT $LN12@memcpy_s

; 57   :   UINT8 *d = (UINT8 *)dest;
; 58   :   UINT8 *s = (UINT8 *)src;
; 59   : 
; 60   :   UINT64 dst_addr = (UINT64)d;
; 61   :   UINT64 src_addr = (UINT64)s;
; 62   : 
; 63   :   const UINT64 dst_first_address = dst_addr;
; 64   :   const UINT64 dst_last_address = dst_addr + count - 1;

  00025	49 8d 41 ff	 lea	 rax, QWORD PTR [r9-1]
  00029	48 03 c1	 add	 rax, rcx

; 73   :       goto EXIT;
; 74   :   }
; 75   : 
; 76   :   // check if we have an overlap between source and destination
; 77   :   if (((dst_first_address > src_last_address) || (dst_last_address < src_first_address)) == FALSE)

  0002c	49 3b c0	 cmp	 rax, r8
  0002f	73 41		 jae	 SHORT $LN7@memcpy_s
$LN12@memcpy_s:
  00031	49 83 f9 08	 cmp	 r9, 8

; 78   :   {
; 79   :       Status = NP_SEAMLDR_PARAMS_STATUS_EBADPARAM;
; 80   :       goto EXIT;
; 81   :   }
; 82   :   
; 83   : #if 1
; 84   :   while (count / 8) {

  00035	72 22		 jb	 SHORT $LN13@memcpy_s
  00037	49 8b d1	 mov	 rdx, r9
  0003a	48 c1 ea 03	 shr	 rdx, 3
  0003e	48 6b c2 f8	 imul	 rax, rdx, -8
  00042	4c 03 c8	 add	 r9, rax
$LL2@memcpy_s:

; 85   :     *(UINT64 *) d = * (UINT64 *) s;

  00045	49 8b 00	 mov	 rax, QWORD PTR [r8]

; 86   :     d += 8;
; 87   :     s += 8;

  00048	49 83 c0 08	 add	 r8, 8
  0004c	48 89 01	 mov	 QWORD PTR [rcx], rax
  0004f	48 83 c1 08	 add	 rcx, 8
  00053	48 83 ea 01	 sub	 rdx, 1
  00057	75 ec		 jne	 SHORT $LL2@memcpy_s
$LN13@memcpy_s:

; 88   :     count -= 8;
; 89   :   };
; 90   : #else
; 91   :   __movsq(to, from, len / 8);
; 92   :   len %= 8;
; 93   : #endif
; 94   :   while (count--)

  00059	4d 85 c9	 test	 r9, r9
  0005c	74 1e		 je	 SHORT $EXIT$23
  0005e	4c 2b c1	 sub	 r8, rcx
$LL4@memcpy_s:

; 95   :     *d++ = *s++;

  00061	41 8a 04 08	 mov	 al, BYTE PTR [r8+rcx]
  00065	88 01		 mov	 BYTE PTR [rcx], al
  00067	48 ff c1	 inc	 rcx
  0006a	49 83 e9 01	 sub	 r9, 1
  0006e	75 f1		 jne	 SHORT $LL4@memcpy_s

; 65   :   const UINT64 src_first_address = src_addr;
; 66   :   const UINT64 src_last_address = src_addr + count - 1;
; 67   : 
; 68   :   if ((destSize < count) ||
; 69   :       (dst_addr > MAX_QWORD - count - 1) ||      

  00070	eb 0a		 jmp	 SHORT $EXIT$23
$LN7@memcpy_s:

; 70   :       (src_addr + count - 1 < src_addr))
; 71   :   {
; 72   :       Status = NP_SEAMLDR_PARAMS_STATUS_EBADPARAM;

  00072	49 ba 00 00 00
	00 00 00 00 80	 mov	 r10, -9223372036854775808 ; 8000000000000000H
$EXIT$23:

; 96   :   
; 97   :   EXIT:
; 98   :   return Status;

  0007c	49 8b c2	 mov	 rax, r10

; 99   : }

  0007f	c3		 ret	 0
memcpy_s ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\accessors64\memcpy64.c
;	COMDAT memcpy
_TEXT	SEGMENT
to$ = 8
from$ = 16
len$ = 24
memcpy	PROC						; COMDAT

; 27   :   UINT8 *d = (UINT8 *)to;

  00000	4c 8b c9	 mov	 r9, rcx
  00003	41 83 f8 08	 cmp	 r8d, 8

; 28   :   UINT8 *s = (UINT8 *)from;
; 29   : 
; 30   :   #if 1
; 31   :   while (len / 8) {

  00007	72 1f		 jb	 SHORT $LN8@memcpy

; 27   :   UINT8 *d = (UINT8 *)to;

  00009	45 8b d0	 mov	 r10d, r8d
  0000c	49 c1 ea 03	 shr	 r10, 3
$LL2@memcpy:

; 32   :     *(UINT64 *) d = * (UINT64 *) s;

  00010	48 8b 02	 mov	 rax, QWORD PTR [rdx]

; 33   :     d += 8;
; 34   :     s += 8;
; 35   :     len -= 8;

  00013	41 83 c0 f8	 add	 r8d, -8			; fffffff8H
  00017	49 89 01	 mov	 QWORD PTR [r9], rax
  0001a	48 83 c2 08	 add	 rdx, 8
  0001e	49 83 c1 08	 add	 r9, 8
  00022	49 83 ea 01	 sub	 r10, 1
  00026	75 e8		 jne	 SHORT $LL2@memcpy
$LN8@memcpy:

; 36   :   };
; 37   : #else
; 38   :   __movsq(to, from, len / 8);
; 39   :   len %= 8;
; 40   : #endif
; 41   :   while (len--)

  00028	45 85 c0	 test	 r8d, r8d
  0002b	74 13		 je	 SHORT $LN10@memcpy
  0002d	49 2b d1	 sub	 rdx, r9
$LL4@memcpy:

; 42   :     *d++ = *s++;

  00030	42 8a 04 0a	 mov	 al, BYTE PTR [rdx+r9]
  00034	41 88 01	 mov	 BYTE PTR [r9], al
  00037	49 ff c1	 inc	 r9
  0003a	41 83 c0 ff	 add	 r8d, -1			; ffffffffH
  0003e	75 f0		 jne	 SHORT $LL4@memcpy
$LN10@memcpy:

; 43   :   return to;

  00040	48 8b c1	 mov	 rax, rcx

; 44   : }

  00043	c3		 ret	 0
memcpy	ENDP
_TEXT	ENDS
END

; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24245.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	MemZeroWithMovdir64B
PUBLIC	LoadModuleCode
PUBLIC	MapModulePages
PUBLIC	SetupStacks
PUBLIC	SetupKeyholeMapping
PUBLIC	SetupDataRegion
PUBLIC	MapSysInfoTables
PUBLIC	MapModuleRegion
PUBLIC	SetupSysInfoTable
PUBLIC	ReadSeamExtendMsr
PUBLIC	RecordSeamIdentity
PUBLIC	SeamldrAcm
EXTRN	Movdir64B:PROC
EXTRN	__readMsr64:PROC
EXTRN	__writeMsr64:PROC
EXTRN	shiftLeft64:PROC
EXTRN	BitScanForward64:PROC
EXTRN	GetPhyAddrMask:PROC
EXTRN	SetupVmcs:PROC
EXTRN	memcpy_s:PROC
EXTRN	MapPhysicalRange:PROC
EXTRN	MapPage:PROC
EXTRN	InitPseamldrPtCtx:PROC
EXTRN	InterlockedCompareExchange8:PROC
EXTRN	CpuidEx:PROC
EXTRN	RdSeed16:PROC
EXTRN	RelocateImage:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	memset:PROC
EXTRN	SeamldrData:BYTE
EXTRN	__security_cookie:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$MemZeroWithMovdir64B DD imagerel $LN11
	DD	imagerel $LN11+142
	DD	imagerel $unwind$MemZeroWithMovdir64B
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$GetX2ApicId DD imagerel GetX2ApicId
	DD	imagerel GetX2ApicId+47
	DD	imagerel $unwind$GetX2ApicId
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$MapModulePages DD imagerel $LN13
	DD	imagerel $LN13+190
	DD	imagerel $unwind$MapModulePages
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$SetupStacks DD imagerel $LN14
	DD	imagerel $LN14+252
	DD	imagerel $unwind$SetupStacks
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$SetupKeyholeMapping DD imagerel $LN17
	DD	imagerel $LN17+245
	DD	imagerel $unwind$SetupKeyholeMapping
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$SetupDataRegion DD imagerel $LN13
	DD	imagerel $LN13+209
	DD	imagerel $unwind$SetupDataRegion
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$MapSysInfoTables DD imagerel $LN5
	DD	imagerel $LN5+100
	DD	imagerel $unwind$MapSysInfoTables
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$MapModuleRegion DD imagerel $LN26
	DD	imagerel $LN26+387
	DD	imagerel $unwind$MapModuleRegion
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$SetupSysInfoTable DD imagerel $LN4
	DD	imagerel $LN4+379
	DD	imagerel $unwind$SetupSysInfoTable
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$RecordSeamIdentity DD imagerel $LN4
	DD	imagerel $LN4+130
	DD	imagerel $unwind$RecordSeamIdentity
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$SeamldrAcm DD imagerel $LN49
	DD	imagerel $LN49+1673
	DD	imagerel $unwind$SeamldrAcm
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$SeamldrAcm DD 0b3419H
	DD	03c3417H
	DD	0320117H
	DD	0e00ef010H
	DD	0c00ad00cH
	DD	060077008H
	DD	05006H
	DD	imagerel __GSHandlerCheck
	DD	054H
	DD	0130H
	DD	0100H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$RecordSeamIdentity DD 032919H
	DD	0460109H
	DD	05002H
	DD	imagerel __GSHandlerCheck
	DD	0104H
	DD	0120H
	DD	0100H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$SetupSysInfoTable DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$MapModuleRegion DD 0c1d01H
	DD	0d741dH
	DD	0c641dH
	DD	0b541dH
	DD	0a341dH
	DD	0f019521dH
	DD	0d015e017H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$MapSysInfoTables DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$SetupDataRegion DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$SetupKeyholeMapping DD 0a1801H
	DD	0c6418H
	DD	0b5418H
	DD	0a3418H
	DD	0f0145218H
	DD	07010e012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$SetupStacks DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$MapModulePages DD 0a1901H
	DD	0b7419H
	DD	0a6419H
	DD	095419H
	DD	083419H
	DD	0e0155219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GetX2ApicId DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$MemZeroWithMovdir64B DD 092d19H
	DD	01b7417H
	DD	01a6417H
	DD	0193417H
	DD	0160117H
	DD	05010H
	DD	imagerel __GSHandlerCheck
	DD	044H
	DD	060H
	DD	040H
xdata	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\commonseamldr64\seamldrcore64.c
;	COMDAT SeamldrAcm
_TEXT	SEGMENT
OriginalBIOSID$1$ = 0
Rrrr$ = 8
BitScanIdx$ = 12
CPagingStructSize$1$ = 16
ia32_misc_enable_org$1$ = 24
SeamrrPtCtx$ = 32
__$ArrayPad$ = 80
pCom64$ = 464
PtCtx$ = 472
SeamldrAcm PROC						; COMDAT

; 236  : void SeamldrAcm(SEAMLDR_COM64_DATA *pCom64, PT_CTX* PtCtx) {

$LN49:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	41 54		 push	 r12
  0000a	41 55		 push	 r13
  0000c	41 56		 push	 r14
  0000e	41 57		 push	 r15
  00010	48 81 ec 90 01
	00 00		 sub	 rsp, 400		; 00000190H
  00017	48 8d ac 24 30
	01 00 00	 lea	 rbp, QWORD PTR [rsp+304]
  0001f	48 81 e5 00 ff
	ff ff		 and	 rbp, -256		; ffffffffffffff00H
  00026	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0002d	48 33 c4	 xor	 rax, rsp
  00030	48 89 45 50	 mov	 QWORD PTR __$ArrayPad$[rbp], rax
  00034	4c 8b f9	 mov	 r15, rcx
  00037	48 8b f2	 mov	 rsi, rdx

; 237  :     SEAMRR_PT_CTX SeamrrPtCtx;
; 238  :     UINT16 Rrrr;
; 239  :     UINT8  Comparand = NP_SEAMLDR_MUTEX_CLEAR;
; 240  :     UINT8  SeamldrMutexStatus;
; 241  :     UINT64 Status = NP_SEAMLDR_PARAMS_STATUS_SUCCESS;
; 242  : 	BOOL MutexAcquired = FALSE;
; 243  :     BOOL SEAMRRUnlocked = FALSE;
; 244  :     UINT64 CPagingStructSize;
; 245  :     UINT64 OriginalBIOSID;
; 246  :     UINT64 ia32_misc_enable_org;
; 247  :     SeamrrBase_u     SeamrrBaseMsr;
; 248  :     SeamrrMask_u     SeamrrMaskMsr;
; 249  :     UINT32 BitScanRes, BitScanIdx;
; 250  : 
; 251  : 
; 252  :     COMSERIALOUT("SeamldrAcm\n");
; 253  :     SIMICS_BREAKPOINT;
; 254  :     //     DEBUG ((EFI_D_INFO, ("SeamldrAcm\n Param struct PA: 0x%x", OriginalEDX));
; 255  : 
; 256  :     // SAVE BIOS ID before the first CPUID
; 257  :     OriginalBIOSID = readMsr64(MSR_IA32_BIOS_SIGN_ID);

  0003a	b9 8b 00 00 00	 mov	 ecx, 139		; 0000008bH
  0003f	45 32 ed	 xor	 r13b, r13b
  00042	45 32 f6	 xor	 r14b, r14b
  00045	e8 00 00 00 00	 call	 __readMsr64

; 258  : 
; 259  :     ia32_misc_enable_org = readMsr64(MSR_IA32_MISC_ENABLES);

  0004a	bb a0 01 00 00	 mov	 ebx, 416		; 000001a0H
  0004f	48 89 45 00	 mov	 QWORD PTR OriginalBIOSID$1$[rbp], rax
  00053	8b cb		 mov	 ecx, ebx
  00055	4c 8b e0	 mov	 r12, rax
  00058	e8 00 00 00 00	 call	 __readMsr64

; 260  :     writeMsr64(MSR_IA32_MISC_ENABLES, ia32_misc_enable_org & (~(UINT64)IA32_CR_MISC_ENABLES_BOOT_NT4_BIT));

  0005d	48 8b d0	 mov	 rdx, rax
  00060	48 89 45 18	 mov	 QWORD PTR ia32_misc_enable_org$1$[rbp], rax
  00064	48 0f ba f2 16	 btr	 rdx, 22
  00069	8b cb		 mov	 ecx, ebx
  0006b	e8 00 00 00 00	 call	 __writeMsr64

; 261  : 
; 262  : 
; 263  :     // SAVE OS XMM's
; 264  : 
; 265  :     SeamldrData.PhysAddrMask = GetPhyAddrMask();

  00070	e8 00 00 00 00	 call	 GetPhyAddrMask
  00075	48 89 05 18 00
	00 00		 mov	 QWORD PTR SeamldrData+24, rax

; 266  :     PRINT_HEX_VAL("MaximumSupportMemAddress: ", SeamldrData.PhysAddrMask);
; 267  :     SeamldrData.PSeamldrConsts = (P_SEAMLDR_CONSTS_t*)pCom64->PseamldrConstsOffset;

  0007c	49 8b 8f 82 00
	00 00		 mov	 rcx, QWORD PTR [r15+130]
  00083	48 89 0d 88 01
	00 00		 mov	 QWORD PTR SeamldrData+392, rcx

; 268  : 
; 269  :     SeamrrBaseMsr.raw = readMsr64(MSR_IA32_SEAMRR_BASE);

  0008a	b9 00 14 00 00	 mov	 ecx, 5120		; 00001400H
  0008f	e8 00 00 00 00	 call	 __readMsr64

; 270  :     SeamrrMaskMsr.raw = readMsr64(MSR_IA32_SEAMRR_MASK);

  00094	b9 01 14 00 00	 mov	 ecx, 5121		; 00001401H
  00099	48 8b f8	 mov	 rdi, rax
  0009c	e8 00 00 00 00	 call	 __readMsr64
  000a1	48 8b d8	 mov	 rbx, rax

; 271  :     //PRINT_HEX_VAL("PSeamldrConsts Location: ", SeamldrData.PSeamldrConsts);
; 272  :     PRINT_HEX_VAL("SEAMRR_BASE_MSR: ", SeamrrBaseMsr.raw);
; 273  :     PRINT_HEX_VAL("SEAMRR_MASK_MSR: ", SeamrrMaskMsr.raw);
; 274  : 
; 275  :     // Read the IA32_SEAMRR_MASK range register and if the VALID bit is not set in the IA32_SEAMRR_MASK register, then set error code to EBADRANGE
; 276  :     if (SeamrrMaskMsr.valid == 0) {

  000a4	48 0f ba e0 0b	 bt	 rax, 11
  000a9	72 0f		 jb	 SHORT $LN5@SeamldrAcm
$LN46@SeamldrAcm:

; 277  :         COMSERIALOUT("Seamrr mask not valid\n");
; 278  :         Status = NP_SEAMLDR_PARAMS_STATUS_EBADRANGE;

  000ab	48 bf 00 00 01
	00 00 00 00 80	 mov	 rdi, -9223372036854710272 ; 8000000000010000H

; 279  :         goto EXIT;

  000b5	e9 df 03 00 00	 jmp	 $EXIT$50
$LN5@SeamldrAcm:

; 280  :     }
; 281  : 
; 282  : 
; 283  :     // Start of SEAMLDR 64-bit code:
; 284  : 
; 285  :     SeamldrData.SeamrrBase = (SeamrrBaseMsr.raw & B_SEAMRR_BASE);

  000ba	48 c7 c0 00 00
	00 fe		 mov	 rax, -33554432		; fffffffffe000000H

; 286  : //    SeamldrData.SeamrrSize = ~(shiftLeft64(SeamrrMaskMsr.mask, N_SEAMRR_MASK_MASK) | SeamldrData.TdxPrivateKidMask | (~SeamldrData.MaximumSupportMemAddress)) + 1;
; 287  :     SeamldrData.SeamrrSize = 0;
; 288  :     BitScanRes = BitScanForward64(&BitScanIdx, (SeamrrMaskMsr.raw & B_SEAMRR_MASK));

  000c1	48 8d 4d 0c	 lea	 rcx, QWORD PTR BitScanIdx$[rbp]
  000c5	48 23 f8	 and	 rdi, rax
  000c8	48 8b d3	 mov	 rdx, rbx
  000cb	48 89 3d 38 00
	00 00		 mov	 QWORD PTR SeamldrData+56, rdi
  000d2	48 23 d0	 and	 rdx, rax
  000d5	33 ff		 xor	 edi, edi
  000d7	48 89 3d 40 00
	00 00		 mov	 QWORD PTR SeamldrData+64, rdi
  000de	e8 00 00 00 00	 call	 BitScanForward64

; 289  :     if (BitScanRes != 0) {

  000e3	44 8d 77 01	 lea	 r14d, QWORD PTR [rdi+1]
  000e7	85 c0		 test	 eax, eax
  000e9	74 12		 je	 SHORT $LN6@SeamldrAcm

; 290  :         SeamldrData.SeamrrSize = shiftLeft64(1, BitScanIdx);

  000eb	8b 55 0c	 mov	 edx, DWORD PTR BitScanIdx$[rbp]
  000ee	41 8b ce	 mov	 ecx, r14d
  000f1	e8 00 00 00 00	 call	 shiftLeft64
  000f6	48 89 05 40 00
	00 00		 mov	 QWORD PTR SeamldrData+64, rax
$LN6@SeamldrAcm:

; 291  :     }
; 292  : 
; 293  :     PRINT_HEX_VAL("Seamrr size: ", SeamldrData.SeamrrSize);
; 294  : 
; 295  : #ifdef _SEAMRR_MASK_WA_
; 296  :     // The SEAMLDR now needs to unlock the SEAMRR range so that it can read and write the memory contents of this range. 
; 297  :     // The SEAMLDR does that by clearing the VALID bit in the IA32_SEAMRR_MASK register. 
; 298  :     
; 299  :     // SEAM range unlocking:
; 300  :     writeMsr64(MSR_BIOS_DONE, BiosDone & ~0x1); // clear the ENABLE_IA_UNTRUSTED bit (0)
; 301  :     COMSERIALOUT("Cleared BIOS_DONE\n");
; 302  :     SeamldrData.SeamrrMask.raw &= ~SeamldrData.TdxPrivateKidMask;
; 303  : #endif
; 304  :     SeamrrMaskMsr.valid = 0;

  000fd	48 0f ba f3 0b	 btr	 rbx, 11

; 305  : 
; 306  :     PRINT_HEX_VAL("Writing seamrr mask - ", SeamrrMaskMsr.raw);
; 307  :     writeMsr64(MSR_IA32_SEAMRR_MASK, SeamrrMaskMsr.raw);

  00102	b9 01 14 00 00	 mov	 ecx, 5121		; 00001401H
  00107	48 8b d3	 mov	 rdx, rbx
  0010a	e8 00 00 00 00	 call	 __writeMsr64

; 308  : 
; 309  : 	// If the SEAMRR is successfully unlocked, then set the SEAMRR_UNLOCKED flag to 1.
; 310  : 	SEAMRRUnlocked = TRUE;
; 311  : 
; 312  :     // Map the SysInfoTable as a single 4KB page with UC memtype
; 313  :     SeamldrData.PSysInfoTable = (P_SYS_INFO_TABLE_t*)MapPhysicalRange(PtCtx, SeamldrData.SeamrrBase + SeamldrData.SeamrrSize - PAGE4K, PAGE4K, PAGE_WRITABLE, PAGE_4K, PAGE_UC_MEMTYPE);

  0010f	48 8b 05 40 00
	00 00		 mov	 rax, QWORD PTR SeamldrData+64
  00116	45 8b ce	 mov	 r9d, r14d
  00119	48 8b 15 38 00
	00 00		 mov	 rdx, QWORD PTR SeamldrData+56
  00120	48 05 00 f0 ff
	ff		 add	 rax, -4096		; fffffffffffff000H
  00126	48 03 d0	 add	 rdx, rax
  00129	89 7c 24 28	 mov	 DWORD PTR [rsp+40], edi
  0012d	41 b8 00 10 00
	00		 mov	 r8d, 4096		; 00001000H
  00133	89 7c 24 20	 mov	 DWORD PTR [rsp+32], edi
  00137	48 8b ce	 mov	 rcx, rsi
  0013a	e8 00 00 00 00	 call	 MapPhysicalRange
  0013f	48 89 05 48 00
	00 00		 mov	 QWORD PTR SeamldrData+72, rax

; 314  : 
; 315  :     PRINT_HEX_VAL("Mapped PSysInfoTable to virtual addr: ", (UINT64)SeamldrData.PSysInfoTable);
; 316  :     PRINT_HEX_VAL("SeamldrData.SysInfoTable->PSeamldrRange.Size: 0x", SeamldrData.PSysInfoTable->PSeamldrRange.Size);
; 317  :     PRINT_HEX_VAL("SeamldrData.PSeamldrConsts->CCodeRgnSize: 0x", SeamldrData.PSeamldrConsts->CCodeRgnSize);
; 318  :     PRINT_HEX_VAL("SeamldrData.PSeamldrConsts->CDataStackSize: 0x", SeamldrData.PSeamldrConsts->CDataStackSize);
; 319  :     PRINT_HEX_VAL("SeamldrData.PSeamldrConsts->CDataRgnSize: 0x", SeamldrData.PSeamldrConsts->CDataRgnSize);
; 320  :     //PRINT_HEX_VAL("pCom64: ", pCom64);
; 321  :     //for (UINT32 i = 0; i < sizeof(SEAMLDR_COM64_DATA)/8; i++) {
; 322  :     //    PRINT_HEX_VAL("pCom64 data: ", *((UINT64*)pCom64 + i));
; 323  :     //}
; 324  : 
; 325  :     if ((UINT64)SeamldrData.PSysInfoTable == BAD_MAPPING) {

  00146	48 83 f8 ff	 cmp	 rax, -1
  0014a	75 0f		 jne	 SHORT $LN7@SeamldrAcm
$LN47@SeamldrAcm:

; 326  :         COMSERIALOUT("Can't map the Sysinfo table, not enough page table entries\n");
; 327  :         Status = NP_SEAMLDR_PARAMS_STATUS_ENOMEM;

  0014c	48 bf 02 00 01
	00 00 00 00 80	 mov	 rdi, -9223372036854710270 ; 8000000000010002H

; 328  :         goto EXIT;

  00156	e9 3e 03 00 00	 jmp	 $EXIT$50
$LN7@SeamldrAcm:

; 329  :     }
; 330  : 
; 331  :     // Verify that all sockets in the platform have identical family and model numbers by comparing bits 31:4 of first entry 
; 332  :     // in SYS_INFO_TABLE.SOCKET_CPUID_TABLE to all valid entries in the table.
; 333  :     // The stepping numbers can be different.If this check fails then set error code to EBADPLATF
; 334  : 
; 335  :     // System info table is in the first 4k of the SEAMRR
; 336  :     
; 337  :     if (SeamldrData.SeamrrSize > _1GB) {

  0015b	4c 8b 05 40 00
	00 00		 mov	 r8, QWORD PTR SeamldrData+64
  00162	49 81 f8 00 00
	00 40		 cmp	 r8, 1073741824		; 40000000H
  00169	0f 87 3c ff ff
	ff		 ja	 $LN46@SeamldrAcm

; 338  :         PRINT_HEX_VAL("Seamrr range too big: ", SeamldrData.SeamrrSize);
; 339  :         Status = NP_SEAMLDR_PARAMS_STATUS_EBADRANGE;
; 340  :         goto EXIT;
; 341  :     }
; 342  : 
; 343  :     // Map the SEAMRR with 2MB pages
; 344  :     SeamldrData.SeamrrVa = MapPhysicalRange(PtCtx, SeamldrData.SeamrrBase, SeamldrData.SeamrrSize, PAGE_WRITABLE, PAGE_2M, PAGE_WB_MEMTYPE);

  0016f	48 8b 15 38 00
	00 00		 mov	 rdx, QWORD PTR SeamldrData+56
  00176	45 8b ce	 mov	 r9d, r14d
  00179	44 89 74 24 28	 mov	 DWORD PTR [rsp+40], r14d
  0017e	48 8b ce	 mov	 rcx, rsi
  00181	44 89 74 24 20	 mov	 DWORD PTR [rsp+32], r14d
  00186	e8 00 00 00 00	 call	 MapPhysicalRange
  0018b	48 89 05 00 00
	00 00		 mov	 QWORD PTR SeamldrData, rax
  00192	48 8b c8	 mov	 rcx, rax

; 345  : 
; 346  :     if (SeamldrData.SeamrrVa == BAD_MAPPING) {

  00195	48 83 f8 ff	 cmp	 rax, -1
  00199	74 b1		 je	 SHORT $LN47@SeamldrAcm

; 347  :         COMSERIALOUT("Can't map the SEAMRR region, not enough page table entries\n");
; 348  :         Status = NP_SEAMLDR_PARAMS_STATUS_ENOMEM;
; 349  :         goto EXIT;
; 350  :     }
; 351  :     //    DEBUG ((EFI_D_INFO, "Seamrr VA: 0x%llx", SeamldrData.SeamrrVa));
; 352  :     SeamldrData.SeamrrVaLimit = SeamldrData.SeamrrVa + SeamldrData.SeamrrSize;

  0019b	48 03 0d 40 00
	00 00		 add	 rcx, QWORD PTR SeamldrData+64

; 353  : 
; 354  :     if ((SeamldrData.PSysInfoTable->TotNumSockets > SYS_INFO_TABLE_SOCKET_CPUID_TABLE_SIZE) ||

  001a2	48 8b 15 48 00
	00 00		 mov	 rdx, QWORD PTR SeamldrData+72
  001a9	48 89 0d 08 00
	00 00		 mov	 QWORD PTR SeamldrData+8, rcx
  001b0	44 8b 4a 0c	 mov	 r9d, DWORD PTR [rdx+12]
  001b4	41 8d 41 ff	 lea	 eax, DWORD PTR [r9-1]
  001b8	83 f8 07	 cmp	 eax, 7
  001bb	0f 87 b9 04 00
	00		 ja	 $LN11@SeamldrAcm

; 358  :         goto EXIT;
; 359  :     }
; 360  : 
; 361  :     for (UINT8 Idx = 1; Idx < SeamldrData.PSysInfoTable->TotNumSockets; Idx++) {

  001c1	45 8a c6	 mov	 r8b, r14b
  001c4	45 3b ce	 cmp	 r9d, r14d
  001c7	76 29		 jbe	 SHORT $LN3@SeamldrAcm
  001c9	44 8b 52 10	 mov	 r10d, DWORD PTR [rdx+16]
  001cd	41 bb f0 ff ff
	ff		 mov	 r11d, -16		; fffffff0H
  001d3	45 23 d3	 and	 r10d, r11d
$LL4@SeamldrAcm:

; 362  :         if ((SeamldrData.PSysInfoTable->SocketCpuidTable[0] & CPUID_FM_MASK) != (SeamldrData.PSysInfoTable->SocketCpuidTable[Idx] & CPUID_FM_MASK)) {

  001d6	41 0f b6 c0	 movzx	 eax, r8b
  001da	8b 4c 82 10	 mov	 ecx, DWORD PTR [rdx+rax*4+16]
  001de	41 23 cb	 and	 ecx, r11d
  001e1	44 3b d1	 cmp	 r10d, ecx
  001e4	75 36		 jne	 SHORT $LN32@SeamldrAcm

; 358  :         goto EXIT;
; 359  :     }
; 360  : 
; 361  :     for (UINT8 Idx = 1; Idx < SeamldrData.PSysInfoTable->TotNumSockets; Idx++) {

  001e6	45 02 c6	 add	 r8b, r14b
  001e9	41 0f b6 c0	 movzx	 eax, r8b
  001ed	41 3b c1	 cmp	 eax, r9d
  001f0	72 e4		 jb	 SHORT $LL4@SeamldrAcm
$LN3@SeamldrAcm:

; 366  :         }
; 367  :     }
; 368  : 
; 369  :     if (SeamldrData.PSysInfoTable->Version != P_SYS_INFO_TABLE_VERSION) {

  001f2	48 39 3a	 cmp	 QWORD PTR [rdx], rdi
  001f5	75 25		 jne	 SHORT $LN32@SeamldrAcm

; 370  :         PRINT_HEX_VAL("P_SYS_INFO_TABLE version mismatch, got version \n", SeamldrData.PSysInfoTable->Version);
; 371  :         Status = NP_SEAMLDR_PARAMS_STATUS_EBADPLATF;
; 372  :         goto EXIT;
; 373  :     }
; 374  : 
; 375  : 
; 376  :     COMSERIALOUT("Acquiring SEAMRR lock\n");
; 377  : 
; 378  :     // Acquire exclusive access to the SEAMRR by atomically setting the NP_SEAMLDR_MUTEX of the SYS_INFO_TABLE 
; 379  :     // in the SEAMRR using a locked CMPXCHG8B 
; 380  :     SeamldrMutexStatus = InterlockedCompareExchange8((volatile INT8 *)&SeamldrData.PSysInfoTable->NpSeamldrMutex, NP_SEAMLDR_MUTEX_ACQUIRED, Comparand);

  001f7	48 8d 8a 00 08
	00 00		 lea	 rcx, QWORD PTR [rdx+2048]
  001fe	45 33 c0	 xor	 r8d, r8d
  00201	41 8a d6	 mov	 dl, r14b
  00204	e8 00 00 00 00	 call	 InterlockedCompareExchange8

; 381  :     if (SeamldrMutexStatus != Comparand) {

  00209	84 c0		 test	 al, al
  0020b	74 1e		 je	 SHORT $LN14@SeamldrAcm

; 382  :         COMSERIALOUT("SeamldrMutexStatus is not correct\n");
; 383  :         Status = NP_SEAMLDR_PARAMS_STATUS_ELDRINPROG;

  0020d	48 bf 02 00 00
	00 00 00 00 80	 mov	 rdi, -9223372036854775806 ; 8000000000000002H

; 384  :         goto EXIT;

  00217	e9 7d 02 00 00	 jmp	 $EXIT$50
$LN32@SeamldrAcm:

; 363  :             COMSERIALOUT("Socket CPUID table not valid\n");
; 364  :             Status = NP_SEAMLDR_PARAMS_STATUS_EBADPLATF;

  0021c	48 bf 01 00 01
	00 00 00 00 80	 mov	 rdi, -9223372036854710271 ; 8000000000010001H

; 365  :             goto EXIT;

  00226	e9 6e 02 00 00	 jmp	 $EXIT$50
$LN14@SeamldrAcm:

; 385  :     }
; 386  : 
; 387  : 	// If the compare succeeds, then the SeamldrMutexStatus moves to LOAD_IN_PROGRESS and set a flag - SET_LOAD_IN_PROGRESS to 1 - 
; 388  : 	// to indicate that this instance of the SEAMLDR moved the SeamldrMutexStatus field to LOAD_IN_PROGRESS.
; 389  : 	MutexAcquired = TRUE;
; 390  : 
; 391  :     if ((SeamldrData.PSysInfoTable->AcmX2ApicIdValid == SYS_INFO_TABLE_X2APICID_VALID) && (SeamldrData.PSysInfoTable->AcmX2ApicId != GetX2ApicId())) {

  0022b	48 8b 05 48 00
	00 00		 mov	 rax, QWORD PTR SeamldrData+72
  00232	45 8a ee	 mov	 r13b, r14b
  00235	44 39 b0 64 08
	00 00		 cmp	 DWORD PTR [rax+2148], r14d
  0023c	75 23		 jne	 SHORT $LN15@SeamldrAcm
  0023e	e8 00 00 00 00	 call	 GetX2ApicId
  00243	48 8b 0d 48 00
	00 00		 mov	 rcx, QWORD PTR SeamldrData+72
  0024a	39 81 60 08 00
	00		 cmp	 DWORD PTR [rcx+2144], eax
  00250	74 0f		 je	 SHORT $LN15@SeamldrAcm
$LN17@SeamldrAcm:

; 392  :         COMSERIALOUT("AcmX2ApicId error\n");
; 393  :         Status = NP_SEAMLDR_PARAMS_STATUS_EMODBUSY;

  00252	48 bf 01 00 00
	00 00 00 00 80	 mov	 rdi, -9223372036854775807 ; 8000000000000001H

; 394  :         goto EXIT;

  0025c	e9 38 02 00 00	 jmp	 $EXIT$50
$LN15@SeamldrAcm:

; 395  :     }
; 396  : 
; 397  :     ReadSeamExtendMsr((UINT64) &SeamldrData.SeamExtend);

  00261	48 8d 0d 00 01
	00 00		 lea	 rcx, OFFSET FLAT:SeamldrData+256
  00268	e8 00 00 00 00	 call	 ReadSeamExtendMsr

; 398  :     if ((SeamldrData.SeamExtend.PSeamldrReady != 0) || (SeamldrData.SeamExtend.SeamReady != 0)) {

  0026d	40 38 3d 82 01
	00 00		 cmp	 BYTE PTR SeamldrData+386, dil
  00274	75 dc		 jne	 SHORT $LN17@SeamldrAcm
  00276	40 38 3d 80 01
	00 00		 cmp	 BYTE PTR SeamldrData+384, dil
  0027d	75 d3		 jne	 SHORT $LN17@SeamldrAcm

; 399  :         COMSERIALOUT("Error: P Seamldr hasn't shut down properly\n");
; 400  :         Status = NP_SEAMLDR_PARAMS_STATUS_EMODBUSY;
; 401  :         goto EXIT;
; 402  :     }
; 403  :     
; 404  :     if (!RdSeed16(&Rrrr)) {

  0027f	48 8d 4d 08	 lea	 rcx, QWORD PTR Rrrr$[rbp]
  00283	e8 00 00 00 00	 call	 RdSeed16
  00288	85 c0		 test	 eax, eax
  0028a	75 0f		 jne	 SHORT $LN18@SeamldrAcm

; 405  :         Status = NP_SEAMLDR_PARAMS_STATUS_EUNSPECERR;

  0028c	48 bf 03 00 01
	00 00 00 00 80	 mov	 rdi, -9223372036854710269 ; 8000000000010003H

; 406  :         COMSERIALOUT("RDSEED failed\n");
; 407  :         goto EXIT;

  00296	e9 fe 01 00 00	 jmp	 $EXIT$50
$LN18@SeamldrAcm:

; 408  :     }
; 409  : 
; 410  :     SeamldrData.AslrRand = (((UINT64)(Rrrr & ASLR_MASK)) << 32);

  0029b	0f b7 45 08	 movzx	 eax, WORD PTR Rrrr$[rbp]
  0029f	25 fc 7f 00 00	 and	 eax, 32764		; 00007ffcH

; 411  :     PRINT_HEX_VAL("AslrRand ", SeamldrData.AslrRand);
; 412  : #if (defined(BULLSEYE_BUILD) && (BULLSEYE_BUILD==1))
; 413  :     SeamldrData.AslrRand = 0;
; 414  : #endif
; 415  : 
; 416  :     CPagingStructSize = PAGING_STRUCTURE_SIZE(SeamldrData.PSeamldrConsts->CDataRgnSize) + PAGING_STRUCTURE_SIZE(SeamldrData.PSeamldrConsts->CCodeRgnSize) +

  002a4	4c 8b 25 40 00
	00 00		 mov	 r12, QWORD PTR SeamldrData+64
  002ab	48 c1 e0 20	 shl	 rax, 32			; 00000020H
  002af	49 8b fc	 mov	 rdi, r12
  002b2	48 89 05 10 00
	00 00		 mov	 QWORD PTR SeamldrData+16, rax
  002b9	48 8b 05 48 00
	00 00		 mov	 rax, QWORD PTR SeamldrData+72
  002c0	48 2b 78 38	 sub	 rdi, QWORD PTR [rax+56]
  002c4	48 8b 05 88 01
	00 00		 mov	 rax, QWORD PTR SeamldrData+392
  002cb	48 8b 30	 mov	 rsi, QWORD PTR [rax]
  002ce	48 8b 50 20	 mov	 rdx, QWORD PTR [rax+32]
  002d2	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  002d6	4c 8b 50 08	 mov	 r10, QWORD PTR [rax+8]
  002da	4c 8b 58 10	 mov	 r11, QWORD PTR [rax+16]
  002de	4c 8d 86 00 10
	00 00		 lea	 r8, QWORD PTR [rsi+4096]
  002e5	49 8b c2	 mov	 rax, r10
  002e8	48 c1 e8 1e	 shr	 rax, 30
  002ec	4c 8d 0c c5 ff
	0f 00 00	 lea	 r9, QWORD PTR [rax*8+4095]
  002f4	49 8b c2	 mov	 rax, r10
  002f7	48 c1 e8 15	 shr	 rax, 21
  002fb	49 c1 e9 0c	 shr	 r9, 12
  002ff	48 8d 04 c5 ff
	0f 00 00	 lea	 rax, QWORD PTR [rax*8+4095]
  00307	48 c1 e8 0c	 shr	 rax, 12
  0030b	4c 03 c8	 add	 r9, rax
  0030e	49 8b c2	 mov	 rax, r10
  00311	48 c1 e8 0c	 shr	 rax, 12
  00315	48 8d 04 c5 ff
	0f 00 00	 lea	 rax, QWORD PTR [rax*8+4095]
  0031d	48 c1 e8 0c	 shr	 rax, 12
  00321	4c 03 c8	 add	 r9, rax
  00324	49 8b c3	 mov	 rax, r11
  00327	48 c1 e8 1e	 shr	 rax, 30
  0032b	48 8d 04 c5 ff
	0f 00 00	 lea	 rax, QWORD PTR [rax*8+4095]
  00333	48 c1 e8 0c	 shr	 rax, 12
  00337	4c 03 c8	 add	 r9, rax
  0033a	49 8b c3	 mov	 rax, r11
  0033d	48 c1 e8 15	 shr	 rax, 21
  00341	48 8d 04 c5 ff
	0f 00 00	 lea	 rax, QWORD PTR [rax*8+4095]
  00349	48 c1 e8 0c	 shr	 rax, 12
  0034d	4c 03 c8	 add	 r9, rax
  00350	49 8b c3	 mov	 rax, r11
  00353	48 c1 e8 0c	 shr	 rax, 12
  00357	48 8d 04 c5 ff
	0f 00 00	 lea	 rax, QWORD PTR [rax*8+4095]
  0035f	48 c1 e8 0c	 shr	 rax, 12
  00363	4c 03 c8	 add	 r9, rax
  00366	48 8b c1	 mov	 rax, rcx
  00369	48 c1 e8 1e	 shr	 rax, 30
  0036d	48 8d 04 c5 ff
	0f 00 00	 lea	 rax, QWORD PTR [rax*8+4095]
  00375	48 c1 e8 0c	 shr	 rax, 12
  00379	4c 03 c8	 add	 r9, rax
  0037c	48 8b c1	 mov	 rax, rcx
  0037f	48 c1 e8 15	 shr	 rax, 21
  00383	48 c1 e9 0c	 shr	 rcx, 12
  00387	48 8d 04 c5 ff
	0f 00 00	 lea	 rax, QWORD PTR [rax*8+4095]
  0038f	48 c1 e8 0c	 shr	 rax, 12
  00393	4c 03 c8	 add	 r9, rax
  00396	48 8d 04 cd ff
	0f 00 00	 lea	 rax, QWORD PTR [rcx*8+4095]
  0039e	48 c1 e8 0c	 shr	 rax, 12
  003a2	4c 03 c8	 add	 r9, rax
  003a5	48 8b c2	 mov	 rax, rdx
  003a8	48 c1 e8 1e	 shr	 rax, 30
  003ac	48 8d 04 c5 ff
	0f 00 00	 lea	 rax, QWORD PTR [rax*8+4095]
  003b4	48 c1 e8 0c	 shr	 rax, 12
  003b8	4c 03 c8	 add	 r9, rax
  003bb	48 8b c2	 mov	 rax, rdx
  003be	48 c1 e8 15	 shr	 rax, 21
  003c2	48 c1 ea 0c	 shr	 rdx, 12
  003c6	48 8d 04 c5 ff
	0f 00 00	 lea	 rax, QWORD PTR [rax*8+4095]
  003ce	48 c1 e8 0c	 shr	 rax, 12
  003d2	4c 03 c8	 add	 r9, rax
  003d5	48 8d 04 d5 ff
	0f 00 00	 lea	 rax, QWORD PTR [rdx*8+4095]
  003dd	48 c1 e8 0c	 shr	 rax, 12
  003e1	4c 03 c8	 add	 r9, rax
  003e4	49 8b c0	 mov	 rax, r8
  003e7	48 c1 e8 1e	 shr	 rax, 30
  003eb	48 8d 04 c5 ff
	0f 00 00	 lea	 rax, QWORD PTR [rax*8+4095]
  003f3	48 c1 e8 0c	 shr	 rax, 12
  003f7	4c 03 c8	 add	 r9, rax
  003fa	49 8b c0	 mov	 rax, r8
  003fd	48 c1 e8 15	 shr	 rax, 21
  00401	48 8d 04 c5 ff
	0f 00 00	 lea	 rax, QWORD PTR [rax*8+4095]
  00409	48 c1 e8 0c	 shr	 rax, 12
  0040d	4c 03 c8	 add	 r9, rax
  00410	49 c1 e8 0c	 shr	 r8, 12
  00414	4a 8d 04 c5 ff
	0f 00 00	 lea	 rax, QWORD PTR [r8*8+4095]
  0041c	48 c1 e8 0c	 shr	 rax, 12
  00420	4c 03 c8	 add	 r9, rax
  00423	48 8b c7	 mov	 rax, rdi
  00426	48 c1 e8 1e	 shr	 rax, 30
  0042a	48 8d 04 c5 ff
	0f 00 00	 lea	 rax, QWORD PTR [rax*8+4095]
  00432	48 c1 e8 0c	 shr	 rax, 12
  00436	4c 03 c8	 add	 r9, rax
  00439	48 8b c7	 mov	 rax, rdi
  0043c	48 c1 e8 15	 shr	 rax, 21
  00440	48 c1 ef 0c	 shr	 rdi, 12
  00444	48 8d 04 c5 ff
	0f 00 00	 lea	 rax, QWORD PTR [rax*8+4095]
  0044c	48 c1 e8 0c	 shr	 rax, 12
  00450	48 8d 0c fd ff
	0f 00 00	 lea	 rcx, QWORD PTR [rdi*8+4095]
  00458	4c 03 c8	 add	 r9, rax
  0045b	48 c1 e9 0c	 shr	 rcx, 12
  0045f	48 83 c1 02	 add	 rcx, 2

; 417  :         PAGING_STRUCTURE_SIZE(SeamldrData.PSeamldrConsts->CDataStackSize + P_SEAMLDR_SHADOW_STACK_SIZE) + PAGING_STRUCTURE_SIZE(SeamldrData.PSeamldrConsts->CKeyholeRgnSize) +
; 418  :         PAGING_STRUCTURE_SIZE(SeamldrData.PSeamldrConsts->CKeyholeEditRgnSize) + PAGING_STRUCTURE_SIZE(C_P_SYS_INFO_TABLE_SIZE) + 
; 419  :         PAGING_STRUCTURE_SIZE(SeamldrData.SeamrrSize - SeamldrData.PSysInfoTable->PSeamldrRange.Size) + _4KB;
; 420  :     
; 421  : 
; 422  :     if (SeamldrData.PSysInfoTable->PSeamldrRange.Size < SeamldrData.PSeamldrConsts->CCodeRgnSize + SeamldrData.PSeamldrConsts->CDataStackSize + P_SEAMLDR_SHADOW_STACK_SIZE +

  00463	49 8d 83 00 40
	00 00		 lea	 rax, QWORD PTR [r11+16384]
  0046a	49 03 c2	 add	 rax, r10
  0046d	49 03 c9	 add	 rcx, r9
  00470	48 c1 e1 0c	 shl	 rcx, 12
  00474	48 03 c6	 add	 rax, rsi
  00477	48 03 c1	 add	 rax, rcx
  0047a	48 89 4d 10	 mov	 QWORD PTR CPagingStructSize$1$[rbp], rcx
  0047e	48 8b 0d 48 00
	00 00		 mov	 rcx, QWORD PTR SeamldrData+72
  00485	48 39 41 38	 cmp	 QWORD PTR [rcx+56], rax
  00489	73 7f		 jae	 SHORT $LN19@SeamldrAcm

; 423  :         + C_VMCS_REGION_SIZE + C_P_SYS_INFO_TABLE_SIZE + SeamldrData.PSeamldrConsts->CDataRgnSize + CPagingStructSize) {
; 424  :         COMSERIALOUT("Pseamldr Range too small\n");
; 425  :         Status = NP_SEAMLDR_PARAMS_STATUS_ENOMEM;

  0048b	48 bf 02 00 01
	00 00 00 00 80	 mov	 rdi, -9223372036854710270 ; 8000000000010002H
$LN44@SeamldrAcm:
  00495	4c 8b 65 00	 mov	 r12, QWORD PTR OriginalBIOSID$1$[rbp]
$EXIT$50:

; 506  : 
; 507  : EXIT:
; 508  :     pCom64->RetVal = Status;
; 509  :     writeMsr64(MSR_IA32_MISC_ENABLES, ia32_misc_enable_org);

  00499	48 8b 55 18	 mov	 rdx, QWORD PTR ia32_misc_enable_org$1$[rbp]
  0049d	b9 a0 01 00 00	 mov	 ecx, 416		; 000001a0H
  004a2	49 89 7f 66	 mov	 QWORD PTR [r15+102], rdi
  004a6	e8 00 00 00 00	 call	 __writeMsr64

; 510  :     if (SEAMRRUnlocked) {

  004ab	45 84 f6	 test	 r14b, r14b
  004ae	74 26		 je	 SHORT $LN28@SeamldrAcm

; 511  :         if (MutexAcquired) {

  004b0	45 84 ed	 test	 r13b, r13b
  004b3	74 0f		 je	 SHORT $LN29@SeamldrAcm

; 512  :             SeamldrData.PSysInfoTable->NpSeamldrMutex = NP_SEAMLDR_MUTEX_CLEAR;

  004b5	48 8b 05 48 00
	00 00		 mov	 rax, QWORD PTR SeamldrData+72
  004bc	48 83 a0 00 08
	00 00 00	 and	 QWORD PTR [rax+2048], 0
$LN29@SeamldrAcm:

; 513  :         }
; 514  : 
; 515  : 
; 516  :         // SEAM range relocking:
; 517  :         SeamrrMaskMsr.valid = 1;

  004c4	48 0f ba eb 0b	 bts	 rbx, 11

; 518  :         writeMsr64(MSR_IA32_SEAMRR_MASK, SeamrrMaskMsr.raw);

  004c9	b9 01 14 00 00	 mov	 ecx, 5121		; 00001401H
  004ce	48 8b d3	 mov	 rdx, rbx
  004d1	e8 00 00 00 00	 call	 __writeMsr64
$LN28@SeamldrAcm:

; 519  : #ifdef _SEAMRR_MASK_WA_
; 520  :         writeMsr64(MSR_BIOS_DONE, BiosDone); // restore the ENABLE_IA_UNTRUSTED bit
; 521  : #endif
; 522  :     }
; 523  : 
; 524  : 
; 525  :     // RESTORE BIOS ID after the last CPUID
; 526  :     writeMsr64(MSR_IA32_BIOS_SIGN_ID, OriginalBIOSID);

  004d6	49 8b d4	 mov	 rdx, r12
  004d9	b9 8b 00 00 00	 mov	 ecx, 139		; 0000008bH
  004de	e8 00 00 00 00	 call	 __writeMsr64

; 527  : 
; 528  :     PRINT_HEX_VAL("Exitingseamldr\nStatus: 0x", Status);
; 529  :     SIMICS_BREAKPOINT;
; 530  : //    DEBUG ((EFI_D_INFO, ("Exit 64 bit code\n"));
; 531  : }

  004e3	48 8b 4d 50	 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  004e7	48 33 cc	 xor	 rcx, rsp
  004ea	e8 00 00 00 00	 call	 __security_check_cookie
  004ef	48 8b 9c 24 e0
	01 00 00	 mov	 rbx, QWORD PTR [rsp+480]
  004f7	48 81 c4 90 01
	00 00		 add	 rsp, 400		; 00000190H
  004fe	41 5f		 pop	 r15
  00500	41 5e		 pop	 r14
  00502	41 5d		 pop	 r13
  00504	41 5c		 pop	 r12
  00506	5f		 pop	 rdi
  00507	5e		 pop	 rsi
  00508	5d		 pop	 rbp
  00509	c3		 ret	 0
$LN19@SeamldrAcm:

; 426  :         goto EXIT;
; 427  :     }
; 428  :     PRINT_HEX_VAL("SeamRR VA: 0x", SeamldrData.SeamrrVa);
; 429  :     PRINT_HEX_VAL("SeamRR Size: 0x", SeamldrData.SeamrrSize);
; 430  :     
; 431  :     MemZeroWithMovdir64B((UINT8*)(SeamldrData.SeamrrVa + SeamldrData.PSysInfoTable->PSeamldrRange.Base - SeamldrData.SeamrrBase), (SeamldrData.SeamrrBase + SeamldrData.SeamrrSize -

  0050a	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  0050e	48 8b 05 38 00
	00 00		 mov	 rax, QWORD PTR SeamldrData+56
  00515	4c 2b e1	 sub	 r12, rcx
  00518	48 2b c8	 sub	 rcx, rax
  0051b	48 03 0d 00 00
	00 00		 add	 rcx, QWORD PTR SeamldrData
  00522	48 8d 90 00 f0
	ff ff		 lea	 rdx, QWORD PTR [rax-4096]
  00529	49 03 d4	 add	 rdx, r12
  0052c	e8 00 00 00 00	 call	 MemZeroWithMovdir64B

; 432  :         SeamldrData.PSysInfoTable->PSeamldrRange.Base - C_P_SYS_INFO_TABLE_SIZE));
; 433  :     MemZeroWithMovdir64B((UINT8*)(SeamldrData.SeamrrVa + SeamldrData.SeamrrSize - _2KB), _2KB);

  00531	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR SeamldrData
  00538	ba 00 08 00 00	 mov	 edx, 2048		; 00000800H
  0053d	48 8b 0d 40 00
	00 00		 mov	 rcx, QWORD PTR SeamldrData+64
  00544	48 05 00 f8 ff
	ff		 add	 rax, -2048		; fffffffffffff800H
  0054a	48 03 c8	 add	 rcx, rax
  0054d	e8 00 00 00 00	 call	 MemZeroWithMovdir64B

; 434  : 
; 435  :     COMSERIALOUT("Load  P-Seamld code\n");
; 436  :     SIMICS_BREAKPOINT;
; 437  : 
; 438  :     // After copying(or as part of copying) into the SEAMRR, measure the copied image using SHA384.
; 439  :     // Specifically, the measurement must not be done on the module image outside SEAMRR.
; 440  :     Status = LoadModuleCode((UINT8*) pCom64->PseamldrOffset, pCom64->PseamldrSize);

  00552	41 8b 57 76	 mov	 edx, DWORD PTR [r15+118]
  00556	49 8b 4f 7a	 mov	 rcx, QWORD PTR [r15+122]
  0055a	e8 00 00 00 00	 call	 LoadModuleCode
  0055f	48 8b f8	 mov	 rdi, rax

; 441  :     if (Status != NP_SEAMLDR_PARAMS_STATUS_SUCCESS) {

  00562	48 85 c0	 test	 rax, rax
  00565	0f 85 2a ff ff
	ff		 jne	 $LN44@SeamldrAcm

; 442  :         COMSERIALOUT("Loading P-Seamldr code failed\n");
; 443  :         goto EXIT;
; 444  :     }
; 445  :     
; 446  :     InitPseamldrPtCtx(&SeamrrPtCtx, SeamldrData.SeamrrVa, SeamldrData.SeamrrBase, SeamldrData.SeamrrSize, SeamldrData.PSysInfoTable->PSeamldrRange.Base, CPagingStructSize);

  0056b	48 8b 45 10	 mov	 rax, QWORD PTR CPagingStructSize$1$[rbp]
  0056f	4c 8b 0d 40 00
	00 00		 mov	 r9, QWORD PTR SeamldrData+64
  00576	4c 8b 05 38 00
	00 00		 mov	 r8, QWORD PTR SeamldrData+56
  0057d	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR SeamldrData
  00584	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00589	48 8b 05 48 00
	00 00		 mov	 rax, QWORD PTR SeamldrData+72
  00590	48 8b 48 30	 mov	 rcx, QWORD PTR [rax+48]
  00594	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00599	48 8d 4d 20	 lea	 rcx, QWORD PTR SeamrrPtCtx$[rbp]
  0059d	e8 00 00 00 00	 call	 InitPseamldrPtCtx

; 447  : 
; 448  :     Status = RelocateImage(SeamldrData.SeamrrVaLimit - (SeamldrData.PSeamldrConsts->CCodeRgnSize + C_P_SYS_INFO_TABLE_SIZE), C_CODE_RGN_BASE | SeamldrData.AslrRand);

  005a2	48 8b 15 10 00
	00 00		 mov	 rdx, QWORD PTR SeamldrData+16
  005a9	48 b8 00 00 00
	00 00 80 ff ff	 mov	 rax, -140737488355328	; ffff800000000000H
  005b3	48 8b 0d 08 00
	00 00		 mov	 rcx, QWORD PTR SeamldrData+8
  005ba	48 0b d0	 or	 rdx, rax
  005bd	48 8b 05 88 01
	00 00		 mov	 rax, QWORD PTR SeamldrData+392
  005c4	48 2b 48 08	 sub	 rcx, QWORD PTR [rax+8]
  005c8	48 81 e9 00 10
	00 00		 sub	 rcx, 4096		; 00001000H
  005cf	e8 00 00 00 00	 call	 RelocateImage
  005d4	48 8b f8	 mov	 rdi, rax

; 449  :     if (Status != NP_SEAMLDR_PARAMS_STATUS_SUCCESS) {

  005d7	48 85 c0	 test	 rax, rax
  005da	0f 85 b5 fe ff
	ff		 jne	 $LN44@SeamldrAcm

; 450  :         COMSERIALOUT("Failed to relocate P-Seamldr\n");
; 451  :         goto EXIT;
; 452  :     };
; 453  : 
; 454  :     COMSERIALOUT("Map P-Seamldr pages\n");
; 455  :     Status = MapModulePages(&SeamrrPtCtx, pCom64->PseamldrSize);

  005e0	41 8b 57 76	 mov	 edx, DWORD PTR [r15+118]
  005e4	48 8d 4d 20	 lea	 rcx, QWORD PTR SeamrrPtCtx$[rbp]
  005e8	e8 00 00 00 00	 call	 MapModulePages
  005ed	48 8b f8	 mov	 rdi, rax

; 456  :     if (Status != NP_SEAMLDR_PARAMS_STATUS_SUCCESS) {

  005f0	48 85 c0	 test	 rax, rax
  005f3	0f 85 9c fe ff
	ff		 jne	 $LN44@SeamldrAcm

; 457  :         COMSERIALOUT("Failed to map module pages\n");
; 458  :         goto EXIT;
; 459  :     };
; 460  : 
; 461  :     COMSERIALOUT("Setup stacks\n");
; 462  :     Status = SetupStacks(&SeamrrPtCtx);

  005f9	48 8d 4d 20	 lea	 rcx, QWORD PTR SeamrrPtCtx$[rbp]
  005fd	e8 00 00 00 00	 call	 SetupStacks
  00602	48 8b f8	 mov	 rdi, rax

; 463  :     if (Status != NP_SEAMLDR_PARAMS_STATUS_SUCCESS) {

  00605	48 85 c0	 test	 rax, rax
  00608	0f 85 87 fe ff
	ff		 jne	 $LN44@SeamldrAcm

; 464  :         COMSERIALOUT("Failed to setup stacks\n");
; 465  :         goto EXIT;
; 466  :     };
; 467  :     COMSERIALOUT("Setup keyhole\n");
; 468  :     //    DEBUG ((EFI_D_INFO, ("Setup keyhole\n"));
; 469  :     Status = SetupKeyholeMapping(&SeamrrPtCtx);

  0060e	48 8d 4d 20	 lea	 rcx, QWORD PTR SeamrrPtCtx$[rbp]
  00612	e8 00 00 00 00	 call	 SetupKeyholeMapping
  00617	48 8b f8	 mov	 rdi, rax

; 470  :     if (Status != NP_SEAMLDR_PARAMS_STATUS_SUCCESS) {

  0061a	48 85 c0	 test	 rax, rax
  0061d	0f 85 72 fe ff
	ff		 jne	 $LN44@SeamldrAcm

; 471  :         COMSERIALOUT("Failed to setup keyholes\n");
; 472  :         goto EXIT;
; 473  :     };
; 474  : 
; 475  :     COMSERIALOUT("Setup Data Region\n");
; 476  :     Status = SetupDataRegion(&SeamrrPtCtx);

  00623	48 8d 4d 20	 lea	 rcx, QWORD PTR SeamrrPtCtx$[rbp]
  00627	e8 00 00 00 00	 call	 SetupDataRegion
  0062c	48 8b f8	 mov	 rdi, rax

; 477  :     if (Status != NP_SEAMLDR_PARAMS_STATUS_SUCCESS) {

  0062f	48 85 c0	 test	 rax, rax
  00632	0f 85 5d fe ff
	ff		 jne	 $LN44@SeamldrAcm

; 478  :         COMSERIALOUT("Failed to setup data region\n");
; 479  :         goto EXIT;
; 480  :     };
; 481  : 
; 482  :     // map system information tables
; 483  :     COMSERIALOUT("Map SysInfoTable\n");
; 484  :     Status = MapSysInfoTables(&SeamrrPtCtx);

  00638	48 8d 4d 20	 lea	 rcx, QWORD PTR SeamrrPtCtx$[rbp]
  0063c	e8 00 00 00 00	 call	 MapSysInfoTables
  00641	48 8b f8	 mov	 rdi, rax

; 485  :     if (Status != NP_SEAMLDR_PARAMS_STATUS_SUCCESS) {

  00644	48 85 c0	 test	 rax, rax
  00647	0f 85 48 fe ff
	ff		 jne	 $LN44@SeamldrAcm

; 486  :         goto EXIT;
; 487  :     }
; 488  : 
; 489  :     COMSERIALOUT("Setup Module Region\n");
; 490  :     Status = MapModuleRegion(&SeamrrPtCtx);

  0064d	48 8d 4d 20	 lea	 rcx, QWORD PTR SeamrrPtCtx$[rbp]
  00651	e8 00 00 00 00	 call	 MapModuleRegion
  00656	48 8b f8	 mov	 rdi, rax

; 491  :     if (Status != NP_SEAMLDR_PARAMS_STATUS_SUCCESS) {

  00659	48 85 c0	 test	 rax, rax
  0065c	0f 85 33 fe ff
	ff		 jne	 $LN44@SeamldrAcm

; 492  :         COMSERIALOUT("Failed to map Module Region!\n");
; 493  :         goto EXIT;
; 494  :     }
; 495  : 
; 496  : 
; 497  :     COMSERIALOUT("Setup PSysinfo table\n");
; 498  :     SetupSysInfoTable();

  00662	e8 00 00 00 00	 call	 SetupSysInfoTable

; 499  : 
; 500  :     COMSERIALOUT("Setup VMCS\n");
; 501  :     SetupVmcs(SeamrrPtCtx.PtBaseAddrPa);

  00667	48 8b 4d 28	 mov	 rcx, QWORD PTR SeamrrPtCtx$[rbp+8]
  0066b	e8 00 00 00 00	 call	 SetupVmcs

; 502  : 
; 503  :     COMSERIALOUT("Record Seam identity\n");
; 504  :     SIMICS_BREAKPOINT;
; 505  :     RecordSeamIdentity();

  00670	e8 00 00 00 00	 call	 RecordSeamIdentity
  00675	e9 1b fe ff ff	 jmp	 $LN44@SeamldrAcm
$LN11@SeamldrAcm:

; 355  :         (SeamldrData.PSysInfoTable->TotNumSockets == 0)){
; 356  :         PRINT_HEX_VAL("Invalid number of sockets: \n", SeamldrData.PSysInfoTable->TotNumSockets);
; 357  :         Status = NP_SEAMLDR_PARAMS_STATUS_EBADPARAM;

  0067a	48 bf 00 00 00
	00 00 00 00 80	 mov	 rdi, -9223372036854775808 ; 8000000000000000H
  00684	e9 10 fe ff ff	 jmp	 $EXIT$50
SeamldrAcm ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\commonseamldr64\seamldrcore64.c
;	COMDAT RecordSeamIdentity
_TEXT	SEGMENT
SeamExtend$ = 0
__$ArrayPad$ = 256
RecordSeamIdentity PROC					; COMDAT

; 226  : void RecordSeamIdentity() {

$LN4:
  00000	40 55		 push	 rbp
  00002	48 81 ec 30 02
	00 00		 sub	 rsp, 560		; 00000230H
  00009	48 8d ac 24 20
	01 00 00	 lea	 rbp, QWORD PTR [rsp+288]
  00011	48 81 e5 00 ff
	ff ff		 and	 rbp, -256		; ffffffffffffff00H
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 85 00 01
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax
  00029	33 d2		 xor	 edx, edx
  0002b	48 8d 4d 00	 lea	 rcx, QWORD PTR SeamExtend$[rbp]
  0002f	41 b8 88 00 00
	00		 mov	 r8d, 136		; 00000088H
  00035	e8 00 00 00 00	 call	 memset

; 227  :     __declspec(align(256)) SEAM_EXTEND_t SeamExtend = { 0 };
; 228  : 
; 229  :     SeamExtend.SeamReady =  SEAM_EXTEND_SEAM_READY_VAL;
; 230  :     SeamExtend.SeamUnderDebug = (readMsr64(MSR_SGX_DEBUG_MODE) & BIT1) >> 1;

  0003a	b9 03 05 00 00	 mov	 ecx, 1283		; 00000503H
  0003f	c6 85 80 00 00
	00 00		 mov	 BYTE PTR SeamExtend$[rbp+128], 0
  00046	e8 00 00 00 00	 call	 __readMsr64
  0004b	d0 e8		 shr	 al, 1

; 231  :     SeamExtend.PSeamldrReady = SP_SEAMLDR_PLAG_READY;
; 232  :     writeMsr64(MSR_IA32_SEAMEXTEND, (UINT64) &SeamExtend);

  0004d	48 8d 55 00	 lea	 rdx, QWORD PTR SeamExtend$[rbp]
  00051	24 01		 and	 al, 1
  00053	c6 85 82 00 00
	00 01		 mov	 BYTE PTR SeamExtend$[rbp+130], 1
  0005a	b9 02 14 00 00	 mov	 ecx, 5122		; 00001402H
  0005f	88 85 81 00 00
	00		 mov	 BYTE PTR SeamExtend$[rbp+129], al
  00065	e8 00 00 00 00	 call	 __writeMsr64

; 233  : }

  0006a	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  00071	48 33 cc	 xor	 rcx, rsp
  00074	e8 00 00 00 00	 call	 __security_check_cookie
  00079	48 81 c4 30 02
	00 00		 add	 rsp, 560		; 00000230H
  00080	5d		 pop	 rbp
  00081	c3		 ret	 0
RecordSeamIdentity ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\commonseamldr64\seamldrcore64.c
;	COMDAT ReadSeamExtendMsr
_TEXT	SEGMENT
SeamExtendAddr$ = 8
ReadSeamExtendMsr PROC					; COMDAT

; 223  :     writeMsr64(MSR_IA32_SEAMEXTEND, SeamExtendAddr | 0x1);

  00000	48 83 c9 01	 or	 rcx, 1
  00004	48 8b d1	 mov	 rdx, rcx
  00007	b9 02 14 00 00	 mov	 ecx, 5122		; 00001402H
  0000c	e9 00 00 00 00	 jmp	 __writeMsr64
ReadSeamExtendMsr ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\commonseamldr64\seamldrcore64.c
;	COMDAT SetupSysInfoTable
_TEXT	SEGMENT
SetupSysInfoTable PROC					; COMDAT

; 202  : void SetupSysInfoTable() {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 203  :     SeamldrData.PSysInfoTable->CodeRgn.Base = C_CODE_RGN_BASE | SeamldrData.AslrRand;

  00004	48 8b 0d 10 00
	00 00		 mov	 rcx, QWORD PTR SeamldrData+16
  0000b	48 b8 00 00 00
	00 00 80 ff ff	 mov	 rax, -140737488355328	; ffff800000000000H
  00015	48 0b c8	 or	 rcx, rax
  00018	48 8b 05 48 00
	00 00		 mov	 rax, QWORD PTR SeamldrData+72
  0001f	48 89 88 08 08
	00 00		 mov	 QWORD PTR [rax+2056], rcx

; 204  :     SeamldrData.PSysInfoTable->CodeRgn.Size = SeamldrData.PSeamldrConsts->CCodeRgnSize;

  00026	48 8b 05 88 01
	00 00		 mov	 rax, QWORD PTR SeamldrData+392
  0002d	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00031	48 8b 05 48 00
	00 00		 mov	 rax, QWORD PTR SeamldrData+72
  00038	48 89 88 10 08
	00 00		 mov	 QWORD PTR [rax+2064], rcx

; 205  :     SeamldrData.PSysInfoTable->DataRgn.Base = C_DATA_RGN_BASE | SeamldrData.AslrRand;

  0003f	48 b8 00 00 00
	00 03 80 ff ff	 mov	 rax, -140724603453440	; ffff800300000000H
  00049	48 8b 0d 10 00
	00 00		 mov	 rcx, QWORD PTR SeamldrData+16
  00050	48 0b c8	 or	 rcx, rax
  00053	48 8b 05 48 00
	00 00		 mov	 rax, QWORD PTR SeamldrData+72
  0005a	48 89 88 18 08
	00 00		 mov	 QWORD PTR [rax+2072], rcx

; 206  :     SeamldrData.PSysInfoTable->DataRgn.Size = SeamldrData.PSeamldrConsts->CDataRgnSize;

  00061	48 8b 05 88 01
	00 00		 mov	 rax, QWORD PTR SeamldrData+392
  00068	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  0006c	48 8b 05 48 00
	00 00		 mov	 rax, QWORD PTR SeamldrData+72
  00073	48 89 88 20 08
	00 00		 mov	 QWORD PTR [rax+2080], rcx

; 207  :     SeamldrData.PSysInfoTable->StackRgn.Base = C_STACK_RGN_BASE | SeamldrData.AslrRand;

  0007a	48 b8 00 00 00
	00 01 80 ff ff	 mov	 rax, -140733193388032	; ffff800100000000H
  00084	48 8b 0d 10 00
	00 00		 mov	 rcx, QWORD PTR SeamldrData+16
  0008b	48 0b c8	 or	 rcx, rax
  0008e	48 8b 05 48 00
	00 00		 mov	 rax, QWORD PTR SeamldrData+72
  00095	48 89 88 28 08
	00 00		 mov	 QWORD PTR [rax+2088], rcx

; 208  :     SeamldrData.PSysInfoTable->StackRgn.Size = SeamldrData.PSeamldrConsts->CDataStackSize + P_SEAMLDR_SHADOW_STACK_SIZE;

  0009c	48 8b 05 88 01
	00 00		 mov	 rax, QWORD PTR SeamldrData+392
  000a3	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000a6	48 8b 05 48 00
	00 00		 mov	 rax, QWORD PTR SeamldrData+72
  000ad	48 81 c1 00 10
	00 00		 add	 rcx, 4096		; 00001000H
  000b4	48 89 88 30 08
	00 00		 mov	 QWORD PTR [rax+2096], rcx

; 209  :     SeamldrData.PSysInfoTable->KeyholeRgn.Base = C_KEYHOLE_RGN_BASE | SeamldrData.AslrRand;

  000bb	48 b8 00 00 00
	00 02 80 ff ff	 mov	 rax, -140728898420736	; ffff800200000000H
  000c5	48 8b 0d 10 00
	00 00		 mov	 rcx, QWORD PTR SeamldrData+16
  000cc	48 0b c8	 or	 rcx, rax
  000cf	48 8b 05 48 00
	00 00		 mov	 rax, QWORD PTR SeamldrData+72
  000d6	48 89 88 38 08
	00 00		 mov	 QWORD PTR [rax+2104], rcx

; 210  :     SeamldrData.PSysInfoTable->KeyholeRgn.Size = SeamldrData.PSeamldrConsts->CKeyholeRgnSize;

  000dd	48 8b 05 88 01
	00 00		 mov	 rax, QWORD PTR SeamldrData+392
  000e4	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  000e8	48 8b 05 48 00
	00 00		 mov	 rax, QWORD PTR SeamldrData+72
  000ef	48 89 88 40 08
	00 00		 mov	 QWORD PTR [rax+2112], rcx

; 211  :     SeamldrData.PSysInfoTable->KeyholeEditRgn.Base = C_KEYHOLE_EDIT_REGION_BASE | SeamldrData.AslrRand;

  000f6	48 b8 00 00 00
	00 01 00 00 00	 mov	 rax, 4294967296		; 0000000100000000H
  00100	48 8b 0d 10 00
	00 00		 mov	 rcx, QWORD PTR SeamldrData+16
  00107	48 0b c8	 or	 rcx, rax
  0010a	48 8b 05 48 00
	00 00		 mov	 rax, QWORD PTR SeamldrData+72
  00111	48 89 88 48 08
	00 00		 mov	 QWORD PTR [rax+2120], rcx

; 212  :     SeamldrData.PSysInfoTable->KeyholeEditRgn.Size = SeamldrData.PSeamldrConsts->CKeyholeEditRgnSize;

  00118	48 8b 05 88 01
	00 00		 mov	 rax, QWORD PTR SeamldrData+392
  0011f	48 8b 48 20	 mov	 rcx, QWORD PTR [rax+32]
  00123	48 8b 05 48 00
	00 00		 mov	 rax, QWORD PTR SeamldrData+72
  0012a	48 89 88 50 08
	00 00		 mov	 QWORD PTR [rax+2128], rcx

; 213  :     SeamldrData.PSysInfoTable->ModuleRgnBase = C_MODULE_RGN_BASE | SeamldrData.AslrRand;

  00131	48 b8 00 00 00
	00 02 00 00 00	 mov	 rax, 8589934592		; 0000000200000000H
  0013b	48 8b 0d 10 00
	00 00		 mov	 rcx, QWORD PTR SeamldrData+16
  00142	48 0b c8	 or	 rcx, rax
  00145	48 8b 05 48 00
	00 00		 mov	 rax, QWORD PTR SeamldrData+72
  0014c	48 89 88 58 08
	00 00		 mov	 QWORD PTR [rax+2136], rcx

; 214  :     SeamldrData.PSysInfoTable->AcmX2ApicId = GetX2ApicId();

  00153	e8 00 00 00 00	 call	 GetX2ApicId
  00158	48 8b 0d 48 00
	00 00		 mov	 rcx, QWORD PTR SeamldrData+72
  0015f	89 81 60 08 00
	00		 mov	 DWORD PTR [rcx+2144], eax

; 215  :     SeamldrData.PSysInfoTable->AcmX2ApicIdValid = SYS_INFO_TABLE_X2APICID_VALID;

  00165	48 8b 05 48 00
	00 00		 mov	 rax, QWORD PTR SeamldrData+72
  0016c	c7 80 64 08 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+2148], 1

; 216  : }

  00176	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0017a	c3		 ret	 0
SetupSysInfoTable ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\commonseamldr64\seamldrcore64.c
;	COMDAT MapModuleRegion
_TEXT	SEGMENT
SeamrrPtCtx$ = 80
MapModuleRegion PROC					; COMDAT

; 170  : UINT64 MapModuleRegion(SEAMRR_PT_CTX* SeamrrPtCtx) {

$LN26:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000f	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  00013	41 55		 push	 r13
  00015	41 56		 push	 r14
  00017	41 57		 push	 r15
  00019	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 171  :     UINT64 CurLinAddr = C_MODULE_RGN_BASE | SeamldrData.AslrRand;

  0001d	48 8b 3d 10 00
	00 00		 mov	 rdi, QWORD PTR SeamldrData+16
  00024	48 b8 00 00 00
	00 02 00 00 00	 mov	 rax, 8589934592		; 0000000200000000H

; 172  :     UINT64 CurPhysAddr = SeamldrData.SeamrrBase;
; 173  :     UINT32 Idx;
; 174  :     UINT64 SeamrrSize = SeamldrData.SeamrrSize;
; 175  :     UINT64 EndOf2MbMappingPhysAddr;
; 176  :     
; 177  :     for (Idx = 0; Idx < (SeamrrSize - SeamldrData.PSysInfoTable->PSeamldrRange.Size) / PAGE2M; Idx++) {

  0002e	4c 8b 05 48 00
	00 00		 mov	 r8, QWORD PTR SeamldrData+72
  00035	48 0b f8	 or	 rdi, rax
  00038	4c 8b 35 40 00
	00 00		 mov	 r14, QWORD PTR SeamldrData+64
  0003f	33 ed		 xor	 ebp, ebp
  00041	48 8b 15 38 00
	00 00		 mov	 rdx, QWORD PTR SeamldrData+56
  00048	49 8b c6	 mov	 rax, r14
  0004b	4c 8b f9	 mov	 r15, rcx
  0004e	48 8b da	 mov	 rbx, rdx
  00051	49 2b 40 38	 sub	 rax, QWORD PTR [r8+56]
  00055	49 b9 63 00 00
	00 00 00 00 80	 mov	 r9, -9223372036854775709 ; 8000000000000063H
  0005f	48 a9 00 00 e0
	ff		 test	 rax, -2097152		; ffffffffffe00000H
  00065	76 6c		 jbe	 SHORT $LN3@MapModuleR

; 171  :     UINT64 CurLinAddr = C_MODULE_RGN_BASE | SeamldrData.AslrRand;

  00067	48 8d b2 00 00
	20 00		 lea	 rsi, QWORD PTR [rdx+2097152]
  0006e	41 bd 00 00 20
	00		 mov	 r13d, 2097152		; 00200000H
$LL4@MapModuleR:

; 178  :         if (CurPhysAddr + PAGE2M > SeamldrData.PSysInfoTable->PSeamldrRange.Base) {

  00074	49 3b 70 30	 cmp	 rsi, QWORD PTR [r8+48]
  00078	77 52		 ja	 SHORT $LN24@MapModuleR

; 179  :             break;
; 180  :         }
; 181  :         if (MapPage(SeamrrPtCtx, CurLinAddr, CurPhysAddr, IA32_PG_P | IA32_PG_RW | IA32_PG_A | IA32_PG_D | IA32_PG_NX, PAGE_2M, FALSE) == NULL) {

  0007a	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  0007f	4c 8b c3	 mov	 r8, rbx
  00082	48 8b d7	 mov	 rdx, rdi
  00085	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  0008d	49 8b cf	 mov	 rcx, r15
  00090	e8 00 00 00 00	 call	 MapPage
  00095	48 85 c0	 test	 rax, rax
  00098	0f 84 d9 00 00
	00		 je	 $LN16@MapModuleR

; 172  :     UINT64 CurPhysAddr = SeamldrData.SeamrrBase;
; 173  :     UINT32 Idx;
; 174  :     UINT64 SeamrrSize = SeamldrData.SeamrrSize;
; 175  :     UINT64 EndOf2MbMappingPhysAddr;
; 176  :     
; 177  :     for (Idx = 0; Idx < (SeamrrSize - SeamldrData.PSysInfoTable->PSeamldrRange.Size) / PAGE2M; Idx++) {

  0009e	4c 8b 05 48 00
	00 00		 mov	 r8, QWORD PTR SeamldrData+72
  000a5	ff c5		 inc	 ebp
  000a7	49 8b ce	 mov	 rcx, r14
  000aa	8b c5		 mov	 eax, ebp

; 183  :         }
; 184  :         CurLinAddr += PAGE2M;

  000ac	49 03 fd	 add	 rdi, r13

; 185  :         CurPhysAddr += PAGE2M;

  000af	49 03 dd	 add	 rbx, r13
  000b2	49 03 f5	 add	 rsi, r13
  000b5	49 b9 63 00 00
	00 00 00 00 80	 mov	 r9, -9223372036854775709 ; 8000000000000063H
  000bf	49 2b 48 38	 sub	 rcx, QWORD PTR [r8+56]
  000c3	48 c1 e9 15	 shr	 rcx, 21
  000c7	48 3b c1	 cmp	 rax, rcx
  000ca	72 a8		 jb	 SHORT $LL4@MapModuleR
$LN24@MapModuleR:

; 182  :             return NP_SEAMLDR_PARAMS_STATUS_ENOMEM;

  000cc	48 8b 15 38 00
	00 00		 mov	 rdx, QWORD PTR SeamldrData+56
$LN3@MapModuleR:

; 186  :     }
; 187  :     
; 188  :     if (CurPhysAddr < SeamldrData.SeamrrBase + SeamldrData.SeamrrSize - SeamldrData.PSysInfoTable->PSeamldrRange.Size) {

  000d3	48 8b 0d 40 00
	00 00		 mov	 rcx, QWORD PTR SeamldrData+64
  000da	49 2b 48 38	 sub	 rcx, QWORD PTR [r8+56]
  000de	48 8d 04 11	 lea	 rax, QWORD PTR [rcx+rdx]
  000e2	48 3b d8	 cmp	 rbx, rax
  000e5	73 6f		 jae	 SHORT $LN6@MapModuleR

; 189  :         EndOf2MbMappingPhysAddr = CurPhysAddr;
; 190  :         for (Idx = 0; Idx < (SeamldrData.SeamrrBase + SeamldrData.SeamrrSize - SeamldrData.PSysInfoTable->PSeamldrRange.Size - EndOf2MbMappingPhysAddr) / PAGE4K; Idx++) {

  000e7	48 2b cb	 sub	 rcx, rbx
  000ea	33 ed		 xor	 ebp, ebp
  000ec	48 03 ca	 add	 rcx, rdx
  000ef	48 f7 c1 00 f0
	ff ff		 test	 rcx, -4096		; fffffffffffff000H
  000f6	76 5e		 jbe	 SHORT $LN6@MapModuleR
  000f8	48 8b f3	 mov	 rsi, rbx
  000fb	48 2b f7	 sub	 rsi, rdi
$LL7@MapModuleR:
  000fe	4c 8d 04 3e	 lea	 r8, QWORD PTR [rsi+rdi]

; 191  :             if (MapPage(SeamrrPtCtx, CurLinAddr, CurPhysAddr, IA32_PG_P | IA32_PG_RW | IA32_PG_A | IA32_PG_D | IA32_PG_NX, PAGE_4K, FALSE) == NULL) {

  00102	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  00107	83 64 24 20 00	 and	 DWORD PTR [rsp+32], 0
  0010c	48 8b d7	 mov	 rdx, rdi
  0010f	49 8b cf	 mov	 rcx, r15
  00112	e8 00 00 00 00	 call	 MapPage
  00117	48 85 c0	 test	 rax, rax
  0011a	74 5b		 je	 SHORT $LN16@MapModuleR

; 189  :         EndOf2MbMappingPhysAddr = CurPhysAddr;
; 190  :         for (Idx = 0; Idx < (SeamldrData.SeamrrBase + SeamldrData.SeamrrSize - SeamldrData.PSysInfoTable->PSeamldrRange.Size - EndOf2MbMappingPhysAddr) / PAGE4K; Idx++) {

  0011c	48 8b 05 48 00
	00 00		 mov	 rax, QWORD PTR SeamldrData+72
  00123	ff c5		 inc	 ebp
  00125	48 8b 0d 40 00
	00 00		 mov	 rcx, QWORD PTR SeamldrData+64

; 192  :                 return NP_SEAMLDR_PARAMS_STATUS_ENOMEM;
; 193  :             }
; 194  :             CurLinAddr += PAGE4K;

  0012c	48 81 c7 00 10
	00 00		 add	 rdi, 4096		; 00001000H
  00133	49 b9 63 00 00
	00 00 00 00 80	 mov	 r9, -9223372036854775709 ; 8000000000000063H
  0013d	48 2b 48 38	 sub	 rcx, QWORD PTR [rax+56]
  00141	48 2b cb	 sub	 rcx, rbx
  00144	8b c5		 mov	 eax, ebp
  00146	48 03 0d 38 00
	00 00		 add	 rcx, QWORD PTR SeamldrData+56
  0014d	48 c1 e9 0c	 shr	 rcx, 12
  00151	48 3b c1	 cmp	 rax, rcx
  00154	72 a8		 jb	 SHORT $LL7@MapModuleR
$LN6@MapModuleR:

; 195  :             CurPhysAddr += PAGE4K;
; 196  :         }
; 197  :     }
; 198  : 
; 199  :     return NP_SEAMLDR_PARAMS_STATUS_SUCCESS;

  00156	33 c0		 xor	 eax, eax
$LN1@MapModuleR:

; 200  : }

  00158	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0015d	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  00162	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  00167	48 8b 7c 24 68	 mov	 rdi, QWORD PTR [rsp+104]
  0016c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00170	41 5f		 pop	 r15
  00172	41 5e		 pop	 r14
  00174	41 5d		 pop	 r13
  00176	c3		 ret	 0
$LN16@MapModuleR:

; 182  :             return NP_SEAMLDR_PARAMS_STATUS_ENOMEM;

  00177	48 b8 02 00 01
	00 00 00 00 80	 mov	 rax, -9223372036854710270 ; 8000000000010002H
  00181	eb d5		 jmp	 SHORT $LN1@MapModuleR
MapModuleRegion ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\commonseamldr64\seamldrcore64.c
;	COMDAT MapSysInfoTables
_TEXT	SEGMENT
SeamrrPtCtx$ = 64
MapSysInfoTables PROC					; COMDAT

; 154  : UINT64 MapSysInfoTables(SEAMRR_PT_CTX* SeamrrPtCtx) {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 155  :     UINT64 Status = NP_SEAMLDR_PARAMS_STATUS_SUCCESS;    
; 156  :     UINT64 CurPhysAddress = SeamldrData.SeamrrBase + SeamldrData.SeamrrSize - PAGE4K;

  00006	48 8b 05 40 00
	00 00		 mov	 rax, QWORD PTR SeamldrData+64
  0000d	33 db		 xor	 ebx, ebx
  0000f	4c 8b 05 38 00
	00 00		 mov	 r8, QWORD PTR SeamldrData+56
  00016	48 05 00 f0 ff
	ff		 add	 rax, -4096		; fffffffffffff000H

; 157  :     UINT64 CurLinAddress = C_SYS_INFO_TABLE_BASE | SeamldrData.AslrRand;

  0001c	48 8b 15 10 00
	00 00		 mov	 rdx, QWORD PTR SeamldrData+16
  00023	4c 03 c0	 add	 r8, rax
  00026	48 b8 00 00 ff
	ff 03 80 ff ff	 mov	 rax, -140720308551680	; ffff8003ffff0000H

; 158  : 
; 159  :     if (MapPage(SeamrrPtCtx, CurLinAddress, CurPhysAddress, IA32_PG_P | IA32_PG_A | IA32_PG_NX, PAGE_4K, FALSE) == NULL) {

  00030	88 5c 24 28	 mov	 BYTE PTR [rsp+40], bl
  00034	48 0b d0	 or	 rdx, rax
  00037	89 5c 24 20	 mov	 DWORD PTR [rsp+32], ebx
  0003b	49 b9 21 00 00
	00 00 00 00 80	 mov	 r9, -9223372036854775775 ; 8000000000000021H
  00045	e8 00 00 00 00	 call	 MapPage
  0004a	48 85 c0	 test	 rax, rax
  0004d	48 b9 02 00 01
	00 00 00 00 80	 mov	 rcx, -9223372036854710270 ; 8000000000010002H
$EXIT$6:
  00057	48 0f 44 d9	 cmove	 rbx, rcx

; 160  :         Status = NP_SEAMLDR_PARAMS_STATUS_ENOMEM;
; 161  :         COMSERIALOUT("Failed to map sysinfo table!\n");
; 162  :         goto EXIT;
; 163  :     }
; 164  : 
; 165  : 
; 166  : EXIT:
; 167  :     return Status;

  0005b	48 8b c3	 mov	 rax, rbx

; 168  : }

  0005e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00062	5b		 pop	 rbx
  00063	c3		 ret	 0
MapSysInfoTables ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\commonseamldr64\seamldrcore64.c
;	COMDAT SetupDataRegion
_TEXT	SEGMENT
SeamrrPtCtx$ = 64
SetupDataRegion PROC					; COMDAT

; 138  : UINT64 SetupDataRegion(SEAMRR_PT_CTX *SeamrrPtCtx) {

$LN13:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 139  :     UINT64 CurLinAddr = C_DATA_RGN_BASE | SeamldrData.AslrRand;     

  00014	48 8b 1d 10 00
	00 00		 mov	 rbx, QWORD PTR SeamldrData+16
  0001b	48 b8 00 00 00
	00 03 80 ff ff	 mov	 rax, -140724603453440	; ffff800300000000H

; 140  :     UINT64 CurPhysAddr = SeamldrData.SeamrrBase + SeamldrData.SeamrrSize - (_4KB + SeamldrData.PSeamldrConsts->CCodeRgnSize + SeamldrData.PSeamldrConsts->CDataStackSize + C_P_SYS_INFO_TABLE_SIZE + SeamldrData.PSeamldrConsts->CDataRgnSize);

  00025	48 8b 15 40 00
	00 00		 mov	 rdx, QWORD PTR SeamldrData+64
  0002c	48 0b d8	 or	 rbx, rax
  0002f	48 8b 05 88 01
	00 00		 mov	 rax, QWORD PTR SeamldrData+392

; 141  :     UINT32 Idx;
; 142  : 
; 143  :     for (Idx = 0; Idx < SeamldrData.PSeamldrConsts->CDataRgnSize / SEAMRR_PAGE_SIZE; Idx++) {

  00036	33 ff		 xor	 edi, edi
  00038	48 8b 35 38 00
	00 00		 mov	 rsi, QWORD PTR SeamldrData+56
  0003f	48 8b e9	 mov	 rbp, rcx
  00042	48 81 c6 00 e0
	ff ff		 add	 rsi, -8192		; ffffffffffffe000H
  00049	48 2b 50 08	 sub	 rdx, QWORD PTR [rax+8]
  0004d	48 2b 50 10	 sub	 rdx, QWORD PTR [rax+16]
  00051	48 2b 10	 sub	 rdx, QWORD PTR [rax]
  00054	48 03 f2	 add	 rsi, rdx
  00057	48 f7 40 10 00
	f0 ff ff	 test	 QWORD PTR [rax+16], -4096 ; fffffffffffff000H
  0005f	76 4d		 jbe	 SHORT $LN3@SetupDataR
$LL4@SetupDataR:

; 144  :         if (MapPage(SeamrrPtCtx, CurLinAddr, CurPhysAddr, IA32_PG_P | IA32_PG_RW | IA32_PG_A | IA32_PG_D | IA32_PG_NX, PAGE_4K, FALSE) == NULL) {

  00061	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  00066	49 b9 63 00 00
	00 00 00 00 80	 mov	 r9, -9223372036854775709 ; 8000000000000063H
  00070	83 64 24 20 00	 and	 DWORD PTR [rsp+32], 0
  00075	4c 8b c6	 mov	 r8, rsi
  00078	48 8b d3	 mov	 rdx, rbx
  0007b	48 8b cd	 mov	 rcx, rbp
  0007e	e8 00 00 00 00	 call	 MapPage
  00083	48 85 c0	 test	 rax, rax
  00086	74 3d		 je	 SHORT $LN8@SetupDataR

; 141  :     UINT32 Idx;
; 142  : 
; 143  :     for (Idx = 0; Idx < SeamldrData.PSeamldrConsts->CDataRgnSize / SEAMRR_PAGE_SIZE; Idx++) {

  00088	48 8b 05 88 01
	00 00		 mov	 rax, QWORD PTR SeamldrData+392
  0008f	ff c7		 inc	 edi

; 146  :         }          
; 147  :         CurLinAddr += SEAMRR_PAGE_SIZE;

  00091	48 81 c3 00 10
	00 00		 add	 rbx, 4096		; 00001000H

; 148  :         CurPhysAddr += SEAMRR_PAGE_SIZE;

  00098	48 81 c6 00 10
	00 00		 add	 rsi, 4096		; 00001000H
  0009f	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  000a3	48 c1 e9 0c	 shr	 rcx, 12
  000a7	8b c7		 mov	 eax, edi
  000a9	48 3b c1	 cmp	 rax, rcx
  000ac	72 b3		 jb	 SHORT $LL4@SetupDataR
$LN3@SetupDataR:

; 149  :     }
; 150  : 
; 151  :     return NP_SEAMLDR_PARAMS_STATUS_SUCCESS;

  000ae	33 c0		 xor	 eax, eax
$LN1@SetupDataR:

; 152  : }

  000b0	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000b5	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000ba	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  000bf	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000c3	5f		 pop	 rdi
  000c4	c3		 ret	 0
$LN8@SetupDataR:

; 145  :             return NP_SEAMLDR_PARAMS_STATUS_ENOMEM;

  000c5	48 b8 02 00 01
	00 00 00 00 80	 mov	 rax, -9223372036854710270 ; 8000000000010002H
  000cf	eb df		 jmp	 SHORT $LN1@SetupDataR
SetupDataRegion ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\commonseamldr64\seamldrcore64.c
;	COMDAT SetupKeyholeMapping
_TEXT	SEGMENT
SeamrrPtCtx$ = 80
SetupKeyholeMapping PROC				; COMDAT

; 110  : UINT64 SetupKeyholeMapping(SEAMRR_PT_CTX *SeamrrPtCtx) {

$LN17:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	41 56		 push	 r14
  00012	41 57		 push	 r15
  00014	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 111  :     UINT64 CurLinAddr = C_KEYHOLE_RGN_BASE | SeamldrData.AslrRand;

  00018	48 8b 1d 10 00
	00 00		 mov	 rbx, QWORD PTR SeamldrData+16
  0001f	48 b8 00 00 00
	00 02 80 ff ff	 mov	 rax, -140728898420736	; ffff800200000000H
  00029	48 8b f3	 mov	 rsi, rbx

; 112  :     UINT64 PrevMappedPtPa = (UINT64)-1;

  0002c	49 83 ce ff	 or	 r14, -1
  00030	48 0b f0	 or	 rsi, rax

; 113  :     UINT64 CurMappedPtPa = (UINT64)NULL;
; 114  :     UINT64 CurEditRgnLinAddr = C_KEYHOLE_EDIT_REGION_BASE | SeamldrData.AslrRand;
; 115  :     UINT32 Idx;
; 116  : 
; 117  :       
; 118  :     for (Idx = 0; Idx < SeamldrData.PSeamldrConsts->CKeyholeRgnSize / SEAMRR_PAGE_SIZE; Idx++) {

  00033	33 ed		 xor	 ebp, ebp
  00035	48 b8 00 00 00
	00 01 00 00 00	 mov	 rax, 4294967296		; 0000000100000000H
  0003f	4c 8b f9	 mov	 r15, rcx
  00042	48 0b d8	 or	 rbx, rax
  00045	48 8b 05 88 01
	00 00		 mov	 rax, QWORD PTR SeamldrData+392
  0004c	48 f7 40 18 00
	f0 ff ff	 test	 QWORD PTR [rax+24], -4096 ; fffffffffffff000H
  00054	76 78		 jbe	 SHORT $LN3@SetupKeyho
$LL4@SetupKeyho:

; 119  :         CurMappedPtPa = (UINT64)MapPage(SeamrrPtCtx, CurLinAddr, 0, 0, PAGE_4K, TRUE);

  00056	c6 44 24 28 01	 mov	 BYTE PTR [rsp+40], 1
  0005b	45 33 c9	 xor	 r9d, r9d
  0005e	83 64 24 20 00	 and	 DWORD PTR [rsp+32], 0
  00063	45 33 c0	 xor	 r8d, r8d
  00066	48 8b d6	 mov	 rdx, rsi
  00069	49 8b cf	 mov	 rcx, r15
  0006c	e8 00 00 00 00	 call	 MapPage
  00071	48 8b f8	 mov	 rdi, rax

; 120  :         if (CurMappedPtPa == (UINT64) NULL) {

  00074	48 85 c0	 test	 rax, rax
  00077	74 70		 je	 SHORT $LN10@SetupKeyho

; 122  :         }
; 123  :         if (CurMappedPtPa != PrevMappedPtPa) {

  00079	49 3b c6	 cmp	 rax, r14
  0007c	74 31		 je	 SHORT $LN6@SetupKeyho

; 124  :             if (MapPage(SeamrrPtCtx, CurEditRgnLinAddr, CurMappedPtPa,
; 125  :                 IA32_PG_P | IA32_PG_RW | IA32_PG_U | IA32_PG_A | IA32_PG_D | IA32_PG_NX, PAGE_4K, FALSE) == NULL) {

  0007e	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  00083	49 b9 67 00 00
	00 00 00 00 80	 mov	 r9, -9223372036854775705 ; 8000000000000067H
  0008d	83 64 24 20 00	 and	 DWORD PTR [rsp+32], 0
  00092	4c 8b c0	 mov	 r8, rax
  00095	48 8b d3	 mov	 rdx, rbx
  00098	49 8b cf	 mov	 rcx, r15
  0009b	e8 00 00 00 00	 call	 MapPage
  000a0	48 85 c0	 test	 rax, rax
  000a3	74 44		 je	 SHORT $LN10@SetupKeyho

; 126  :                 return NP_SEAMLDR_PARAMS_STATUS_ENOMEM;
; 127  :             }
; 128  : 
; 129  :             PrevMappedPtPa = CurMappedPtPa;

  000a5	4c 8b f7	 mov	 r14, rdi

; 130  :             CurEditRgnLinAddr += SEAMRR_PAGE_SIZE;

  000a8	48 81 c3 00 10
	00 00		 add	 rbx, 4096		; 00001000H
$LN6@SetupKeyho:

; 113  :     UINT64 CurMappedPtPa = (UINT64)NULL;
; 114  :     UINT64 CurEditRgnLinAddr = C_KEYHOLE_EDIT_REGION_BASE | SeamldrData.AslrRand;
; 115  :     UINT32 Idx;
; 116  : 
; 117  :       
; 118  :     for (Idx = 0; Idx < SeamldrData.PSeamldrConsts->CKeyholeRgnSize / SEAMRR_PAGE_SIZE; Idx++) {

  000af	48 8b 05 88 01
	00 00		 mov	 rax, QWORD PTR SeamldrData+392
  000b6	ff c5		 inc	 ebp

; 131  :         }
; 132  :         CurLinAddr += SEAMRR_PAGE_SIZE;

  000b8	48 81 c6 00 10
	00 00		 add	 rsi, 4096		; 00001000H
  000bf	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  000c3	48 c1 e9 0c	 shr	 rcx, 12
  000c7	8b c5		 mov	 eax, ebp
  000c9	48 3b c1	 cmp	 rax, rcx
  000cc	72 88		 jb	 SHORT $LL4@SetupKeyho
$LN3@SetupKeyho:

; 133  :     }
; 134  : 
; 135  :     return NP_SEAMLDR_PARAMS_STATUS_SUCCESS;

  000ce	33 c0		 xor	 eax, eax
$LN1@SetupKeyho:

; 136  : }

  000d0	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  000d5	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  000da	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  000df	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000e3	41 5f		 pop	 r15
  000e5	41 5e		 pop	 r14
  000e7	5f		 pop	 rdi
  000e8	c3		 ret	 0
$LN10@SetupKeyho:

; 121  :             return NP_SEAMLDR_PARAMS_STATUS_ENOMEM;

  000e9	48 b8 02 00 01
	00 00 00 00 80	 mov	 rax, -9223372036854710270 ; 8000000000010002H
  000f3	eb db		 jmp	 SHORT $LN1@SetupKeyho
SetupKeyholeMapping ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\commonseamldr64\seamldrcore64.c
;	COMDAT SetupStacks
_TEXT	SEGMENT
SeamrrPtCtx$ = 64
SetupStacks PROC					; COMDAT

; 87   : UINT64 SetupStacks(SEAMRR_PT_CTX *SeamrrPtCtx) {

$LN14:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 88   :     UINT32 StkPageIdx;
; 89   :     UINT64 CurLinAddr = C_STACK_RGN_BASE | SeamldrData.AslrRand;
; 90   :     UINT64 CurPhysAddr;
; 91   :     
; 92   :     CurPhysAddr = SeamldrData.SeamrrBase + SeamldrData.SeamrrSize - C_P_SYS_INFO_TABLE_SIZE - (SeamldrData.PSeamldrConsts->CCodeRgnSize) - (SeamldrData.PSeamldrConsts->CDataStackSize) - P_SEAMLDR_SHADOW_STACK_SIZE;

  00014	4c 8b 05 88 01
	00 00		 mov	 r8, QWORD PTR SeamldrData+392
  0001b	48 b8 00 00 00
	00 01 80 ff ff	 mov	 rax, -140733193388032	; ffff800100000000H
  00025	48 8b 15 40 00
	00 00		 mov	 rdx, QWORD PTR SeamldrData+64

; 93   : 
; 94   :     for (StkPageIdx = 0; StkPageIdx < (UINT32)SeamldrData.PSeamldrConsts->CDataStackSize / SEAMRR_PAGE_SIZE; StkPageIdx++) {

  0002c	33 f6		 xor	 esi, esi
  0002e	48 8b 3d 38 00
	00 00		 mov	 rdi, QWORD PTR SeamldrData+56
  00035	48 8b e9	 mov	 rbp, rcx
  00038	48 8b 1d 10 00
	00 00		 mov	 rbx, QWORD PTR SeamldrData+16
  0003f	48 81 c7 00 e0
	ff ff		 add	 rdi, -8192		; ffffffffffffe000H
  00046	49 2b 50 08	 sub	 rdx, QWORD PTR [r8+8]
  0004a	48 0b d8	 or	 rbx, rax
  0004d	49 2b 10	 sub	 rdx, QWORD PTR [r8]
  00050	48 03 fa	 add	 rdi, rdx
  00053	41 f7 00 00 f0
	ff ff		 test	 DWORD PTR [r8], -4096	; fffff000H
  0005a	76 47		 jbe	 SHORT $LN3@SetupStack
$LL4@SetupStack:

; 95   :         if (MapPage(SeamrrPtCtx, CurLinAddr, CurPhysAddr, IA32_PG_RW | IA32_PG_A | IA32_PG_D | IA32_PG_NX | IA32_PG_P, PAGE_4K, FALSE) == NULL) {

  0005c	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  00061	49 b9 63 00 00
	00 00 00 00 80	 mov	 r9, -9223372036854775709 ; 8000000000000063H
  0006b	83 64 24 20 00	 and	 DWORD PTR [rsp+32], 0
  00070	4c 8b c7	 mov	 r8, rdi
  00073	48 8b d3	 mov	 rdx, rbx
  00076	48 8b cd	 mov	 rcx, rbp
  00079	e8 00 00 00 00	 call	 MapPage
  0007e	48 85 c0	 test	 rax, rax
  00081	74 6d		 je	 SHORT $LN9@SetupStack

; 97   :         }
; 98   :         CurLinAddr += SEAMRR_PAGE_SIZE;

  00083	48 8b 05 88 01
	00 00		 mov	 rax, QWORD PTR SeamldrData+392
  0008a	48 81 c3 00 10
	00 00		 add	 rbx, 4096		; 00001000H

; 99   :         CurPhysAddr += SEAMRR_PAGE_SIZE;

  00091	48 81 c7 00 10
	00 00		 add	 rdi, 4096		; 00001000H
  00098	ff c6		 inc	 esi
  0009a	8b 08		 mov	 ecx, DWORD PTR [rax]
  0009c	c1 e9 0c	 shr	 ecx, 12
  0009f	3b f1		 cmp	 esi, ecx
  000a1	72 b9		 jb	 SHORT $LL4@SetupStack
$LN3@SetupStack:

; 100  :     }
; 101  :     // shadow stack page
; 102  :     if (MapPage(SeamrrPtCtx, CurLinAddr, CurPhysAddr, IA32_PG_A | IA32_PG_D | IA32_PG_NX | IA32_PG_P, PAGE_4K, FALSE) == NULL) {

  000a3	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  000a8	49 b9 61 00 00
	00 00 00 00 80	 mov	 r9, -9223372036854775711 ; 8000000000000061H
  000b2	83 64 24 20 00	 and	 DWORD PTR [rsp+32], 0
  000b7	4c 8b c7	 mov	 r8, rdi
  000ba	48 8b d3	 mov	 rdx, rbx
  000bd	48 8b cd	 mov	 rcx, rbp
  000c0	e8 00 00 00 00	 call	 MapPage
  000c5	48 f7 d8	 neg	 rax
  000c8	48 b9 02 00 01
	00 00 00 00 80	 mov	 rcx, -9223372036854710270 ; 8000000000010002H
  000d2	48 1b c0	 sbb	 rax, rax
  000d5	48 f7 d0	 not	 rax
  000d8	48 23 c1	 and	 rax, rcx
$LN6@SetupStack:

; 103  :         return NP_SEAMLDR_PARAMS_STATUS_ENOMEM;
; 104  :     }
; 105  :     
; 106  :     return NP_SEAMLDR_PARAMS_STATUS_SUCCESS;
; 107  : }

  000db	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000e0	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000e5	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  000ea	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000ee	5f		 pop	 rdi
  000ef	c3		 ret	 0
$LN9@SetupStack:

; 96   :             return NP_SEAMLDR_PARAMS_STATUS_ENOMEM;

  000f0	48 b8 02 00 01
	00 00 00 00 80	 mov	 rax, -9223372036854710270 ; 8000000000010002H
  000fa	eb df		 jmp	 SHORT $LN6@SetupStack
SetupStacks ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\commonseamldr64\seamldrcore64.c
;	COMDAT MapModulePages
_TEXT	SEGMENT
SeamrrPtCtx$ = 64
ModuleSize$ = 72
MapModulePages PROC					; COMDAT

; 69   : UINT64 MapModulePages(SEAMRR_PT_CTX * SeamrrPtCtx, UINT32 ModuleSize) {

$LN13:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000f	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  00013	41 56		 push	 r14
  00015	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 70   :     UINT64 CurCodeLinearAddr = C_CODE_RGN_BASE | SeamldrData.AslrRand;

  00019	48 8b 1d 10 00
	00 00		 mov	 rbx, QWORD PTR SeamldrData+16
  00020	48 b8 00 00 00
	00 00 80 ff ff	 mov	 rax, -140737488355328	; ffff800000000000H

; 71   :     UINT64 CurCodePhysicalAddr;
; 72   :     uint32_t Idx;
; 73   :         
; 74   :     CurCodePhysicalAddr = SeamldrData.SeamrrBase + SeamldrData.SeamrrSize - (SeamldrData.PSeamldrConsts->CCodeRgnSize + C_P_SYS_INFO_TABLE_SIZE);

  0002a	4c 8b 05 40 00
	00 00		 mov	 r8, QWORD PTR SeamldrData+64
  00031	48 0b d8	 or	 rbx, rax
  00034	48 8b 05 88 01
	00 00		 mov	 rax, QWORD PTR SeamldrData+392
  0003b	8b ea		 mov	 ebp, edx
  0003d	48 8b 35 38 00
	00 00		 mov	 rsi, QWORD PTR SeamldrData+56

; 75   :     
; 76   :     for (Idx = 0; Idx < ModuleSize / MOD_PAGE_SIZE; Idx++) {

  00044	33 ff		 xor	 edi, edi
  00046	48 81 c6 00 f0
	ff ff		 add	 rsi, -4096		; fffffffffffff000H
  0004d	c1 ed 0c	 shr	 ebp, 12
  00050	4c 8b f1	 mov	 r14, rcx
  00053	4c 2b 40 08	 sub	 r8, QWORD PTR [rax+8]
  00057	49 03 f0	 add	 rsi, r8
  0005a	85 ed		 test	 ebp, ebp
  0005c	74 37		 je	 SHORT $LN3@MapModuleP
$LL4@MapModuleP:

; 77   :         if (MapPage(SeamrrPtCtx, CurCodeLinearAddr, CurCodePhysicalAddr, IA32_PG_A | IA32_PG_P, PAGE_4K, FALSE) == NULL) {

  0005e	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  00063	41 b9 21 00 00
	00		 mov	 r9d, 33			; 00000021H
  00069	83 64 24 20 00	 and	 DWORD PTR [rsp+32], 0
  0006e	4c 8b c6	 mov	 r8, rsi
  00071	48 8b d3	 mov	 rdx, rbx
  00074	49 8b ce	 mov	 rcx, r14
  00077	e8 00 00 00 00	 call	 MapPage
  0007c	48 85 c0	 test	 rax, rax
  0007f	74 31		 je	 SHORT $LN8@MapModuleP

; 80   :         }
; 81   :         CurCodeLinearAddr += SEAMRR_PAGE_SIZE;

  00081	48 81 c3 00 10
	00 00		 add	 rbx, 4096		; 00001000H

; 82   :         CurCodePhysicalAddr += SEAMRR_PAGE_SIZE;

  00088	48 81 c6 00 10
	00 00		 add	 rsi, 4096		; 00001000H
  0008f	ff c7		 inc	 edi
  00091	3b fd		 cmp	 edi, ebp
  00093	72 c9		 jb	 SHORT $LL4@MapModuleP
$LN3@MapModuleP:

; 83   :     }    
; 84   :     return NP_SEAMLDR_PARAMS_STATUS_SUCCESS;

  00095	33 c0		 xor	 eax, eax
$LN1@MapModuleP:

; 85   : }

  00097	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0009c	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000a1	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  000a6	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  000ab	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000af	41 5e		 pop	 r14
  000b1	c3		 ret	 0
$LN8@MapModuleP:

; 78   : 
; 79   :             return NP_SEAMLDR_PARAMS_STATUS_ENOMEM;

  000b2	48 b8 02 00 01
	00 00 00 00 80	 mov	 rax, -9223372036854710270 ; 8000000000010002H
  000bc	eb d9		 jmp	 SHORT $LN1@MapModuleP
MapModulePages ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\commonseamldr64\seamldrcore64.c
;	COMDAT LoadModuleCode
_TEXT	SEGMENT
Module$ = 8
ModuleSize$ = 16
LoadModuleCode PROC					; COMDAT

; 62   :     UINT64 Status = NP_SEAMLDR_PARAMS_STATUS_SUCCESS;
; 63   : 
; 64   :     Status = memcpy_s((void *)(SeamldrData.SeamrrVaLimit - (SeamldrData.PSeamldrConsts->CCodeRgnSize + C_P_SYS_INFO_TABLE_SIZE)), SeamldrData.PSeamldrConsts->CCodeRgnSize, Module, ModuleSize);

  00000	48 8b 05 88 01
	00 00		 mov	 rax, QWORD PTR SeamldrData+392
  00007	4c 8b c1	 mov	 r8, rcx

; 65   : 
; 66   :     return Status;

  0000a	48 8b 0d 08 00
	00 00		 mov	 rcx, QWORD PTR SeamldrData+8
  00011	44 8b ca	 mov	 r9d, edx
  00014	48 2b 48 08	 sub	 rcx, QWORD PTR [rax+8]
  00018	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0001c	48 81 e9 00 10
	00 00		 sub	 rcx, 4096		; 00001000H
  00023	e9 00 00 00 00	 jmp	 memcpy_s
LoadModuleCode ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\commonseamldr64\seamldrcore64.c
;	COMDAT GetX2ApicId
_TEXT	SEGMENT
CpuidEdx$ = 64
GetX2ApicId PROC					; COMDAT

; 53   : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 54   :     UINT32 CpuidEdx;
; 55   : 
; 56   :     CpuidEx(CPUID_V2_EXTENDED_TOPOLOGY, CPUID_EXTENDED_TOPOLOGY_LEVEL_TYPE_SMT, NULL, NULL, NULL, &CpuidEdx);

  00004	45 33 c9	 xor	 r9d, r9d
  00007	48 8d 44 24 40	 lea	 rax, QWORD PTR CpuidEdx$[rsp]
  0000c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00011	45 33 c0	 xor	 r8d, r8d
  00014	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  0001a	41 8d 51 01	 lea	 edx, QWORD PTR [r9+1]
  0001e	8d 4a 1e	 lea	 ecx, QWORD PTR [rdx+30]
  00021	e8 00 00 00 00	 call	 CpuidEx

; 57   : 
; 58   :     return CpuidEdx;

  00026	8b 44 24 40	 mov	 eax, DWORD PTR CpuidEdx$[rsp]

; 59   : }

  0002a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0002e	c3		 ret	 0
GetX2ApicId ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\commonseamldr64\seamldrcore64.c
;	COMDAT MemZeroWithMovdir64B
_TEXT	SEGMENT
ZeroBlock$ = 0
__$ArrayPad$ = 64
dst$ = 192
size$ = 200
MemZeroWithMovdir64B PROC				; COMDAT

; 39   : void MemZeroWithMovdir64B(UINT8* dst, UINT64 size) {

$LN11:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 10	 mov	 QWORD PTR [rax+16], rbx
  00007	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000b	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  0000f	55		 push	 rbp
  00010	48 81 ec b0 00
	00 00		 sub	 rsp, 176		; 000000b0H
  00017	48 8d 68 a8	 lea	 rbp, QWORD PTR [rax-88]
  0001b	48 83 e5 c0	 and	 rbp, -64		; ffffffffffffffc0H
  0001f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00026	48 33 c4	 xor	 rax, rsp
  00029	48 89 45 40	 mov	 QWORD PTR __$ArrayPad$[rbp], rax
  0002d	48 8b f2	 mov	 rsi, rdx
  00030	48 8b f9	 mov	 rdi, rcx
  00033	33 d2		 xor	 edx, edx
  00035	48 8d 4d 00	 lea	 rcx, QWORD PTR ZeroBlock$[rbp]
  00039	44 8d 42 40	 lea	 r8d, QWORD PTR [rdx+64]
  0003d	e8 00 00 00 00	 call	 memset

; 40   :     __declspec(align(MOVDIR64B_BLOCK_SIZE)) UINT8 ZeroBlock[MOVDIR64B_BLOCK_SIZE] = { 0 };
; 41   :     UINT64 NumOfBlocks = size / MOVDIR64B_BLOCK_SIZE;

  00042	48 c1 ee 06	 shr	 rsi, 6

; 42   : 
; 43   :     for (UINT32 Idx = 0; Idx < NumOfBlocks; Idx++) {

  00046	33 db		 xor	 ebx, ebx
  00048	48 85 f6	 test	 rsi, rsi
  0004b	74 19		 je	 SHORT $LN3@MemZeroWit
$LL4@MemZeroWit:

; 44   :         Movdir64B(ZeroBlock, dst);

  0004d	48 8b d7	 mov	 rdx, rdi
  00050	48 8d 4d 00	 lea	 rcx, QWORD PTR ZeroBlock$[rbp]
  00054	e8 00 00 00 00	 call	 Movdir64B
  00059	ff c3		 inc	 ebx

; 45   :         dst += MOVDIR64B_BLOCK_SIZE;

  0005b	48 83 c7 40	 add	 rdi, 64			; 00000040H
  0005f	8b c3		 mov	 eax, ebx
  00061	48 3b c6	 cmp	 rax, rsi
  00064	72 e7		 jb	 SHORT $LL4@MemZeroWit
$LN3@MemZeroWit:

; 46   :     }
; 47   :         
; 48   : 
; 49   :     _mm_sfence();

  00066	0f ae f8	 sfence

; 50   : }

  00069	48 8b 4d 40	 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  0006d	48 33 cc	 xor	 rcx, rsp
  00070	e8 00 00 00 00	 call	 __security_check_cookie
  00075	4c 8d 9c 24 b0
	00 00 00	 lea	 r11, QWORD PTR [rsp+176]
  0007d	49 8b 5b 18	 mov	 rbx, QWORD PTR [r11+24]
  00081	49 8b 73 20	 mov	 rsi, QWORD PTR [r11+32]
  00085	49 8b 7b 28	 mov	 rdi, QWORD PTR [r11+40]
  00089	49 8b e3	 mov	 rsp, r11
  0008c	5d		 pop	 rbp
  0008d	c3		 ret	 0
MemZeroWithMovdir64B ENDP
_TEXT	ENDS
END

; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24245.0 

	TITLE	D:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\Core\Common\MemFill.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_fillMemory
PUBLIC	_fillMemoryChkBoundsWithFunc
EXTRN	___ErrorHandler:PROC
EXTRN	_perform_ebp_checks:PROC
EXTRN	_memcpy:PROC
EXTRN	_ErrCtx:BYTE
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\common\memfill.c
;	COMDAT _coreFillMemory
_TEXT	SEGMENT
_start_addr$ = 8					; size = 4
_val$ = 12						; size = 4
_len$ = 16						; size = 4
_coreFillMemory PROC					; COMDAT

; 36   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 37   :   UINT32 i = 0;
; 38   : 
; 39   :   for (i = 0; i < len / 4; i++) {

  00004	8b 5d 10	 mov	 ebx, DWORD PTR _len$[ebp]
  00007	56		 push	 esi
  00008	8b f3		 mov	 esi, ebx
  0000a	c1 ee 02	 shr	 esi, 2
  0000d	85 f6		 test	 esi, esi
  0000f	74 13		 je	 SHORT $LN21@coreFillMe
  00011	8b 55 08	 mov	 edx, DWORD PTR _start_addr$[ebp]
  00014	8b ce		 mov	 ecx, esi
  00016	8b 45 0c	 mov	 eax, DWORD PTR _val$[ebp]
  00019	57		 push	 edi
  0001a	8b fa		 mov	 edi, edx
  0001c	f3 ab		 rep stosd
  0001e	8d 04 b2	 lea	 eax, DWORD PTR [edx+esi*4]
  00021	5f		 pop	 edi
  00022	eb 03		 jmp	 SHORT $LN13@coreFillMe
$LN21@coreFillMe:
  00024	8b 45 08	 mov	 eax, DWORD PTR _start_addr$[ebp]
$LN13@coreFillMe:

; 40   :     *((UINT32 *)start_addr) = val;
; 41   :     start_addr += 4;
; 42   :   }
; 43   : 
; 44   :   UINT8 *pattern = (UINT8 *)&val;
; 45   : 
; 46   :   for (i = 0; i < (len % 4); i++) {

  00027	83 e3 03	 and	 ebx, 3
  0002a	76 0e		 jbe	 SHORT $LN15@coreFillMe
  0002c	53		 push	 ebx
  0002d	8d 4d 0c	 lea	 ecx, DWORD PTR _val$[ebp]
  00030	51		 push	 ecx
  00031	50		 push	 eax
  00032	e8 00 00 00 00	 call	 _memcpy
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN15@coreFillMe:
  0003a	5e		 pop	 esi
  0003b	5b		 pop	 ebx

; 47   :     *(start_addr + i) = *(pattern + i);
; 48   :   }
; 49   :   return;
; 50   : }

  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
_coreFillMemory ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\common\memfill.c
;	COMDAT _fillMemoryChkBoundsWithFunc
_TEXT	SEGMENT
__to$ = 8						; size = 4
_val$ = 12						; size = 4
_len$ = 16						; size = 4
_maxBound$ = 20						; size = 4
_kind$ = 24						; size = 4
_pFunc$ = 28						; size = 4
_fillMemoryChkBoundsWithFunc PROC			; COMDAT

; 117  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 118  :   UINT32 maxlen;
; 119  :   UINT8 *to = (UINT8 *)_to;
; 120  : 
; 121  :   if (kind == MAX_ADDR_BOUND) {

  00003	83 7d 18 ff	 cmp	 DWORD PTR _kind$[ebp], -1
  00007	56		 push	 esi
  00008	8b 75 10	 mov	 esi, DWORD PTR _len$[ebp]
  0000b	75 12		 jne	 SHORT $LN2@fillMemory

; 122  :     //
; 123  :     // Destination must be less then bound address
; 124  :     //
; 125  :     if ((UINT32) to > maxBound) {

  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __to$[ebp]
  00010	8b 45 14	 mov	 eax, DWORD PTR _maxBound$[ebp]
  00013	3b c8		 cmp	 ecx, eax
  00015	76 04		 jbe	 SHORT $LN4@fillMemory
$LN8@fillMemory:

; 126  :       return 0;

  00017	33 c0		 xor	 eax, eax
  00019	eb 21		 jmp	 SHORT $LN1@fillMemory
$LN4@fillMemory:

; 127  :     }
; 128  :     //
; 129  :     // maximum len to copy is difference between max address and
; 130  :     // destination.
; 131  :     //
; 132  :     maxlen = maxBound - (UINT32) to;

  0001b	2b c1		 sub	 eax, ecx

; 133  :   } else {

  0001d	eb 0c		 jmp	 SHORT $LN3@fillMemory
$LN2@fillMemory:

; 134  :     if (len > maxBound) {

  0001f	3b 75 14	 cmp	 esi, DWORD PTR _maxBound$[ebp]
  00022	77 f3		 ja	 SHORT $LN8@fillMemory

; 135  :       return 0;
; 136  :     }
; 137  :     //
; 138  :     // If len is set as bound, we cannot wrap around.
; 139  :     //
; 140  :     maxlen = 0xFFFFFFFF - (UINT32) to;

  00024	8b 4d 08	 mov	 ecx, DWORD PTR __to$[ebp]
  00027	8b c1		 mov	 eax, ecx
  00029	f7 d0		 not	 eax
$LN3@fillMemory:

; 141  :   }
; 142  : 
; 143  :   //
; 144  :   // abort if over length.
; 145  :   //
; 146  :   if (len > maxlen) {

  0002b	3b f0		 cmp	 esi, eax
  0002d	77 e8		 ja	 SHORT $LN8@fillMemory

; 147  :     return 0;
; 148  :   }
; 149  : 
; 150  :   (*pFunc)(to, val, len);

  0002f	56		 push	 esi
  00030	ff 75 0c	 push	 DWORD PTR _val$[ebp]
  00033	51		 push	 ecx
  00034	ff 55 1c	 call	 DWORD PTR _pFunc$[ebp]
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH

; 151  :   return len;

  0003a	8b c6		 mov	 eax, esi
$LN1@fillMemory:
  0003c	5e		 pop	 esi

; 152  : }

  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
_fillMemoryChkBoundsWithFunc ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\common\memfill.c
;	COMDAT _fillMemory
_TEXT	SEGMENT
_start_addr$ = 8					; size = 4
_val$ = 12						; size = 4
_len$ = 16						; size = 4
_fillMemory PROC					; COMDAT

; 68   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 69   :   INT32 Ret;
; 70   : 
; 71   :   Ret = HOOK(perform_ebp_checks((UINT32)start_addr, (UINT32)len));

  00003	ff 75 10	 push	 DWORD PTR _len$[ebp]
  00006	ff 75 08	 push	 DWORD PTR _start_addr$[ebp]
  00009	e8 00 00 00 00	 call	 _perform_ebp_checks
  0000e	59		 pop	 ecx
  0000f	59		 pop	 ecx

; 72   : 
; 73   :   switch (Ret) {

  00010	8b c8		 mov	 ecx, eax
  00012	83 e9 00	 sub	 ecx, 0
  00015	74 15		 je	 SHORT $LN5@fillMemory
  00017	83 e9 01	 sub	 ecx, 1
  0001a	74 10		 je	 SHORT $LN5@fillMemory

; 74   :   case  STACK_TARGET:
; 75   :     break;
; 76   :   case  NOT_STACK_TARGET:
; 77   :     break;
; 78   :   default:
; 79   :     TRACE("Safe fill operation: Stack target, stack frame error -%c.\n", MAX_DWORD - Ret + 1);
; 80   :     ERROR_HANDLER_FULL(CLASS_MISC_CONFIG, ERR_STACK_FRAME, Ret);

  0001c	6a 0b		 push	 11			; 0000000bH
  0001e	6a 08		 push	 8
  00020	a3 08 00 00 00	 mov	 DWORD PTR _ErrCtx+8, eax
  00025	e8 00 00 00 00	 call	 ___ErrorHandler
  0002a	59		 pop	 ecx
  0002b	59		 pop	 ecx
$LN5@fillMemory:

; 84   : }

  0002c	5d		 pop	 ebp

; 81   :   }
; 82   : 
; 83   :   coreFillMemory(start_addr, val, len);

  0002d	e9 00 00 00 00	 jmp	 _coreFillMemory
_fillMemory ENDP
_TEXT	ENDS
END

; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24245.0 

	TITLE	D:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\Core\Common\CoreTime.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	___Wait10us
PUBLIC	_WaitFixedTime
PUBLIC	_TinyWaitRegisterValue
PUBLIC	_BaseWaitMsrValue
PUBLIC	___WaitRegisterBitSet
PUBLIC	___WaitRegisterBitClear
PUBLIC	_Wait1ms
PUBLIC	___Wait1ms
EXTRN	___readMsr64:PROC
EXTRN	_readTsc64:PROC
EXTRN	_calibrateTsc64:PROC
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\common\coretime.c
;	COMDAT ___Wait1ms
_TEXT	SEGMENT
___Wait1ms PROC						; COMDAT

; 240  : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi

; 241  :   UINT32 Idx, Prev, New;
; 242  : 
; 243  :   for (Idx = 0; Idx < 11; Idx++) {

  00003	6a 0b		 push	 11			; 0000000bH
  00005	5e		 pop	 esi
  00006	bb 00 00 04 00	 mov	 ebx, 262144		; 00040000H
$LL4@Wait1ms:

; 244  :     Prev = BIT18 & (UINT32) readTsc64();

  0000b	e8 00 00 00 00	 call	 _readTsc64
  00010	8b f8		 mov	 edi, eax
  00012	23 fb		 and	 edi, ebx
$LL7@Wait1ms:

; 245  : 
; 246  :     do {
; 247  :       New = BIT18 & (UINT32) readTsc64();

  00014	e8 00 00 00 00	 call	 _readTsc64
  00019	23 c3		 and	 eax, ebx

; 248  :     } while (Prev == New);

  0001b	3b f8		 cmp	 edi, eax
  0001d	74 f5		 je	 SHORT $LL7@Wait1ms

; 241  :   UINT32 Idx, Prev, New;
; 242  : 
; 243  :   for (Idx = 0; Idx < 11; Idx++) {

  0001f	83 ee 01	 sub	 esi, 1
  00022	75 e7		 jne	 SHORT $LL4@Wait1ms

; 249  :   }
; 250  : }

  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	c3		 ret	 0
___Wait1ms ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\common\coretime.c
;	COMDAT _Wait1ms
_TEXT	SEGMENT
_Wait1ms PROC						; COMDAT

; 265  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi

; 266  :   UINT64 Now, Then, TscClkPerMsec;
; 267  : 
; 268  : #if (SIMICS_BLD == 1)
; 269  :   TscClkPerMsec = 0x15 * 133330;
; 270  : #else
; 271  :   TscClkPerMsec = calibrateTsc64();

  00007	e8 00 00 00 00	 call	 _calibrateTsc64
  0000c	8b f0		 mov	 esi, eax
  0000e	8b fa		 mov	 edi, edx

; 272  : #endif
; 273  : 
; 274  :   Now = readTsc64();

  00010	e8 00 00 00 00	 call	 _readTsc64
  00015	8b d8		 mov	 ebx, eax
  00017	8b c2		 mov	 eax, edx

; 275  :   Then = Now + TscClkPerMsec;

  00019	03 de		 add	 ebx, esi
  0001b	13 c7		 adc	 eax, edi
  0001d	8b f0		 mov	 esi, eax
$LL4@Wait1ms:

; 276  : 
; 277  :   do {
; 278  :     Now = readTsc64();

  0001f	e8 00 00 00 00	 call	 _readTsc64

; 279  :   } while (Now < Then);

  00024	3b d6		 cmp	 edx, esi
  00026	72 f7		 jb	 SHORT $LL4@Wait1ms
  00028	77 04		 ja	 SHORT $LN9@Wait1ms
  0002a	3b c3		 cmp	 eax, ebx
  0002c	72 f1		 jb	 SHORT $LL4@Wait1ms
$LN9@Wait1ms:
  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx

; 280  : }

  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
_Wait1ms ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\common\coretime.c
;	COMDAT ___WaitRegisterBitClear
_TEXT	SEGMENT
_Reg$ = 8						; size = 4
_Mask$ = 12						; size = 4
___WaitRegisterBitClear PROC				; COMDAT

; 200  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 201  :   return TinyWaitRegisterValue(

  00003	6a 64		 push	 100			; 00000064H
  00005	6a 00		 push	 0
  00007	6a 00		 push	 0
  00009	ff 75 0c	 push	 DWORD PTR _Mask$[ebp]
  0000c	6a 04		 push	 4
  0000e	ff 75 08	 push	 DWORD PTR _Reg$[ebp]
  00011	e8 00 00 00 00	 call	 _TinyWaitRegisterValue
  00016	83 c4 18	 add	 esp, 24			; 00000018H

; 202  :     Reg,
; 203  :     4,
; 204  :     Mask,
; 205  :     EQUAL,
; 206  :     0,
; 207  :     100
; 208  :     );
; 209  : }

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
___WaitRegisterBitClear ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\common\coretime.c
;	COMDAT ___WaitRegisterBitSet
_TEXT	SEGMENT
_Reg$ = 8						; size = 4
_Mask$ = 12						; size = 4
___WaitRegisterBitSet PROC				; COMDAT

; 169  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 170  :   return TinyWaitRegisterValue(

  00003	6a 64		 push	 100			; 00000064H
  00005	ff 75 0c	 push	 DWORD PTR _Mask$[ebp]
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _Mask$[ebp]
  0000d	6a 04		 push	 4
  0000f	ff 75 08	 push	 DWORD PTR _Reg$[ebp]
  00012	e8 00 00 00 00	 call	 _TinyWaitRegisterValue
  00017	83 c4 18	 add	 esp, 24			; 00000018H

; 171  :     Reg,
; 172  :     4,
; 173  :     Mask,
; 174  :     EQUAL,
; 175  :     Mask,
; 176  :     100
; 177  :     );
; 178  : }

  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
___WaitRegisterBitSet ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\common\coretime.c
;	COMDAT _BaseWaitMsrValue
_TEXT	SEGMENT
_MsrAddr$ = 8						; size = 4
_Mask$ = 12						; size = 8
_Cond$ = 20						; size = 4
_ExpVal$ = 24						; size = 8
_Timeout$ = 32						; size = 4
_Step$ = 36						; size = 4
_BaseWaitMsrValue PROC					; COMDAT

; 131  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 132  :   UINT64 Current;
; 133  :   UINT32 Idx;
; 134  : 
; 135  :   for (Idx = 0; Idx < Timeout; Idx++) {

  00004	33 f6		 xor	 esi, esi
  00006	39 75 20	 cmp	 DWORD PTR _Timeout$[ebp], esi
  00009	76 47		 jbe	 SHORT $LN17@BaseWaitMs
$LL4@BaseWaitMs:

; 136  :     Current = Mask & __readMsr64(MsrAddr);

  0000b	ff 75 08	 push	 DWORD PTR _MsrAddr$[ebp]
  0000e	e8 00 00 00 00	 call	 ___readMsr64
  00013	23 45 0c	 and	 eax, DWORD PTR _Mask$[ebp]
  00016	23 55 10	 and	 edx, DWORD PTR _Mask$[ebp+4]

; 137  : 
; 138  :     if ((Cond == EQUAL) && (Current == ExpVal)) {

  00019	83 7d 14 00	 cmp	 DWORD PTR _Cond$[ebp], 0
  0001d	59		 pop	 ecx
  0001e	75 0a		 jne	 SHORT $LN18@BaseWaitMs
  00020	3b 45 18	 cmp	 eax, DWORD PTR _ExpVal$[ebp]
  00023	75 05		 jne	 SHORT $LN18@BaseWaitMs
  00025	3b 55 1c	 cmp	 edx, DWORD PTR _ExpVal$[ebp+4]
  00028	74 2e		 je	 SHORT $LN12@BaseWaitMs
$LN18@BaseWaitMs:

; 140  :     } else if ((Cond == NOT_EQUAL) && (Current != ExpVal)) {

  0002a	83 7d 14 01	 cmp	 DWORD PTR _Cond$[ebp], 1
  0002e	75 0a		 jne	 SHORT $LN7@BaseWaitMs
  00030	3b 45 18	 cmp	 eax, DWORD PTR _ExpVal$[ebp]
  00033	75 23		 jne	 SHORT $LN12@BaseWaitMs
  00035	3b 55 1c	 cmp	 edx, DWORD PTR _ExpVal$[ebp+4]
  00038	75 1e		 jne	 SHORT $LN12@BaseWaitMs
$LN7@BaseWaitMs:

; 141  :       return 0;
; 142  :     }
; 143  : 
; 144  :     (Step == In1MSEC) ? Wait1ms() : __Wait10us();

  0003a	83 7d 24 01	 cmp	 DWORD PTR _Step$[ebp], 1
  0003e	75 07		 jne	 SHORT $LN9@BaseWaitMs
  00040	e8 00 00 00 00	 call	 _Wait1ms
  00045	eb 05		 jmp	 SHORT $LN2@BaseWaitMs
$LN9@BaseWaitMs:
  00047	e8 00 00 00 00	 call	 ___Wait10us
$LN2@BaseWaitMs:

; 132  :   UINT64 Current;
; 133  :   UINT32 Idx;
; 134  : 
; 135  :   for (Idx = 0; Idx < Timeout; Idx++) {

  0004c	46		 inc	 esi
  0004d	3b 75 20	 cmp	 esi, DWORD PTR _Timeout$[ebp]
  00050	72 b9		 jb	 SHORT $LL4@BaseWaitMs
$LN17@BaseWaitMs:

; 145  :   }
; 146  :   return 1;

  00052	33 c0		 xor	 eax, eax
  00054	40		 inc	 eax
$LN1@BaseWaitMs:
  00055	5e		 pop	 esi

; 147  : }

  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
$LN12@BaseWaitMs:

; 139  :       return 0;

  00058	33 c0		 xor	 eax, eax
  0005a	eb f9		 jmp	 SHORT $LN1@BaseWaitMs
_BaseWaitMsrValue ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\common\coretime.c
;	COMDAT _TinyWaitRegisterValue
_TEXT	SEGMENT
_RegAddr$ = 8						; size = 4
_Width$ = 12						; size = 4
_Mask$ = 16						; size = 4
_Cond$ = 20						; size = 4
_ExpVal$ = 24						; size = 4
_Timeout$ = 28						; size = 4
_TinyWaitRegisterValue PROC				; COMDAT

; 84   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 85   :   UINT32 Current, Idx;
; 86   : 
; 87   :   for (Idx = 0; Idx < Timeout; Idx++) {

  00004	33 f6		 xor	 esi, esi
  00006	57		 push	 edi
  00007	39 75 1c	 cmp	 DWORD PTR _Timeout$[ebp], esi
  0000a	76 3f		 jbe	 SHORT $LN19@TinyWaitRe
  0000c	8b 7d 08	 mov	 edi, DWORD PTR _RegAddr$[ebp]
$LL4@TinyWaitRe:

; 88   :     Current = Mask &

  0000f	83 7d 0c 01	 cmp	 DWORD PTR _Width$[ebp], 1
  00013	75 05		 jne	 SHORT $LN11@TinyWaitRe
  00015	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00018	eb 0d		 jmp	 SHORT $LN10@TinyWaitRe
$LN11@TinyWaitRe:
  0001a	83 7d 0c 02	 cmp	 DWORD PTR _Width$[ebp], 2
  0001e	75 05		 jne	 SHORT $LN9@TinyWaitRe
  00020	0f b7 07	 movzx	 eax, WORD PTR [edi]
  00023	eb 02		 jmp	 SHORT $LN10@TinyWaitRe
$LN9@TinyWaitRe:
  00025	8b 07		 mov	 eax, DWORD PTR [edi]
$LN10@TinyWaitRe:
  00027	23 45 10	 and	 eax, DWORD PTR _Mask$[ebp]

; 89   :               ((UINT32) ((Width == 1) ?
; 90   :                          __ReadMmioByte(RegAddr) :
; 91   :                          ((Width == 2) ?  __ReadMmioWord(RegAddr) : __ReadMmioDword(RegAddr))));
; 92   : 
; 93   :     if ((Cond == EQUAL) && (Current == ExpVal)) {

  0002a	83 7d 14 00	 cmp	 DWORD PTR _Cond$[ebp], 0
  0002e	75 05		 jne	 SHORT $LN5@TinyWaitRe
  00030	3b 45 18	 cmp	 eax, DWORD PTR _ExpVal$[ebp]
  00033	74 1d		 je	 SHORT $LN14@TinyWaitRe
$LN5@TinyWaitRe:

; 95   :     } else if ((Cond == NOT_EQUAL) && (Current != ExpVal)) {

  00035	83 7d 14 01	 cmp	 DWORD PTR _Cond$[ebp], 1
  00039	75 05		 jne	 SHORT $LN7@TinyWaitRe
  0003b	3b 45 18	 cmp	 eax, DWORD PTR _ExpVal$[ebp]
  0003e	75 12		 jne	 SHORT $LN14@TinyWaitRe
$LN7@TinyWaitRe:

; 96   :       return 0;
; 97   :     }
; 98   : 
; 99   :     __Wait10us();

  00040	e8 00 00 00 00	 call	 ___Wait10us
  00045	46		 inc	 esi
  00046	3b 75 1c	 cmp	 esi, DWORD PTR _Timeout$[ebp]
  00049	72 c4		 jb	 SHORT $LL4@TinyWaitRe
$LN19@TinyWaitRe:

; 100  :   }
; 101  :   return 1;

  0004b	33 c0		 xor	 eax, eax
  0004d	40		 inc	 eax
$LN1@TinyWaitRe:
  0004e	5f		 pop	 edi
  0004f	5e		 pop	 esi

; 102  : }

  00050	5d		 pop	 ebp
  00051	c3		 ret	 0
$LN14@TinyWaitRe:

; 94   :       return 0;

  00052	33 c0		 xor	 eax, eax
  00054	eb f8		 jmp	 SHORT $LN1@TinyWaitRe
_TinyWaitRegisterValue ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\common\coretime.c
;	COMDAT _WaitFixedTime
_TEXT	SEGMENT
_Time$ = 8						; size = 4
_WaitFixedTime PROC					; COMDAT

; 295  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 296  :   UINT32 Idx;
; 297  : 
; 298  :   for (Idx = 0; Idx < Time; Idx++) {

  00004	8b 75 08	 mov	 esi, DWORD PTR _Time$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 0a		 je	 SHORT $LN3@WaitFixedT
$LL4@WaitFixedT:

; 299  :     Wait1ms();

  0000b	e8 00 00 00 00	 call	 _Wait1ms
  00010	83 ee 01	 sub	 esi, 1
  00013	75 f6		 jne	 SHORT $LL4@WaitFixedT
$LN3@WaitFixedT:
  00015	5e		 pop	 esi

; 300  :   }
; 301  : }

  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
_WaitFixedTime ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\common\coretime.c
;	COMDAT ___Wait10us
_TEXT	SEGMENT
___Wait10us PROC					; COMDAT

; 44   : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi

; 45   :   UINT32 Idx, Prev, New;
; 46   : 
; 47   :   for (Idx = 0; Idx < 7; Idx++) {

  00003	6a 07		 push	 7
  00005	5e		 pop	 esi
  00006	bb 00 10 00 00	 mov	 ebx, 4096		; 00001000H
$LL4@Wait10us:

; 48   :     Prev = BIT12 & (UINT32) readTsc64();

  0000b	e8 00 00 00 00	 call	 _readTsc64
  00010	8b f8		 mov	 edi, eax
  00012	23 fb		 and	 edi, ebx
$LL7@Wait10us:

; 49   : 
; 50   :     do {
; 51   :       New = BIT12 & (UINT32) readTsc64();

  00014	e8 00 00 00 00	 call	 _readTsc64
  00019	23 c3		 and	 eax, ebx

; 52   :     } while (Prev == New);

  0001b	3b f8		 cmp	 edi, eax
  0001d	74 f5		 je	 SHORT $LL7@Wait10us

; 45   :   UINT32 Idx, Prev, New;
; 46   : 
; 47   :   for (Idx = 0; Idx < 7; Idx++) {

  0001f	83 ee 01	 sub	 esi, 1
  00022	75 e7		 jne	 SHORT $LL4@Wait10us

; 53   :   }
; 54   : }

  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	c3		 ret	 0
___Wait10us ENDP
_TEXT	ENDS
END

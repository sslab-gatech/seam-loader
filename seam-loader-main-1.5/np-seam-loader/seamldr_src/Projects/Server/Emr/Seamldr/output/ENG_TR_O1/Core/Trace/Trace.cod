; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24245.0 

	TITLE	D:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\Core\Trace\Trace.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_nib
PUBLIC	_traceRoutines
EXTRN	_ComSerialOut:PROC
EDATA32	SEGMENT
_nib	DB	030H
	DB	031H
	DB	032H
	DB	033H
	DB	034H
	DB	035H
	DB	036H
	DB	037H
	DB	038H
	DB	039H
	DB	041H
	DB	042H
	DB	043H
	DB	044H
	DB	045H
	DB	046H
_traceRoutines DD 00H
	DD	00H
	DD	FLAT:_ComSerialOut
	DD	01H
	DD	02H
	ORG $+8
EDATA32	ENDS
PUBLIC	_TraceWriteString
PUBLIC	_Trace
PUBLIC	_TraceProgress
PUBLIC	_TraceValue
PUBLIC	__Trace
PUBLIC	_HexDump
PUBLIC	_NumToStr
PUBLIC	_PchUartSerialOut
PUBLIC	_NumToStr8
PUBLIC	___Trace
PUBLIC	??_C@_01FGNFDNOH@?$CF?$AA@IMHBAIGO@		;  ?? ::IMHBAIGO::`string'
PUBLIC	??_C@_0BJ@BAFGNCAE@ACM?5PROGRESS?5MARK?5?$DN?5?$CFhx?6?$AA@IMHBAIGO@ ;  ?? ::IMHBAIGO::`string'
PUBLIC	??_C@_0M@OFODFNCD@CODE?5?$DN?5?$CFhx?6?$AA@IMHBAIGO@ ;  ?? ::IMHBAIGO::`string'
PUBLIC	??_C@_0L@NHBJHPNH@CODE?5?$DN?5?$CFx?6?$AA@IMHBAIGO@ ;  ?? ::IMHBAIGO::`string'
PUBLIC	??_C@_0M@GKIBMKHE@CODE?5?$DN?5?$CFlx?6?$AA@IMHBAIGO@ ;  ?? ::IMHBAIGO::`string'
PUBLIC	??_C@_0N@CFODKAJD@CODE?5?$DN?5?$CFllx?6?$AA@IMHBAIGO@ ;  ?? ::IMHBAIGO::`string'
PUBLIC	??_C@_02KHLKFPFD@?$HM?6?$AA@IMHBAIGO@		;  ?? ::IMHBAIGO::`string'
PUBLIC	??_C@_07CAOHCKHM@?5?$CFlx?5?$HM?5?$AA@IMHBAIGO@	;  ?? ::IMHBAIGO::`string'
PUBLIC	??_C@_04BAIGKDA@?$CFhx?5?$AA@IMHBAIGO@		;  ?? ::IMHBAIGO::`string'
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@IMHBAIGO@		;  ?? ::IMHBAIGO::`string'
EXTRN	_copyMemory:PROC
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@IMHBAIGO@
EDATA32	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@IMHBAIGO@ DB 0aH, 00H		;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT ??_C@_04BAIGKDA@?$CFhx?5?$AA@IMHBAIGO@
EDATA32	SEGMENT
??_C@_04BAIGKDA@?$CFhx?5?$AA@IMHBAIGO@ DB '%hx ', 00H	;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT ??_C@_07CAOHCKHM@?5?$CFlx?5?$HM?5?$AA@IMHBAIGO@
EDATA32	SEGMENT
??_C@_07CAOHCKHM@?5?$CFlx?5?$HM?5?$AA@IMHBAIGO@ DB ' %lx | ', 00H ;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT ??_C@_02KHLKFPFD@?$HM?6?$AA@IMHBAIGO@
EDATA32	SEGMENT
??_C@_02KHLKFPFD@?$HM?6?$AA@IMHBAIGO@ DB '|', 0aH, 00H	;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT ??_C@_0N@CFODKAJD@CODE?5?$DN?5?$CFllx?6?$AA@IMHBAIGO@
EDATA32	SEGMENT
??_C@_0N@CFODKAJD@CODE?5?$DN?5?$CFllx?6?$AA@IMHBAIGO@ DB 'CODE = %llx', 0aH
	DB	00H						;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT ??_C@_0M@GKIBMKHE@CODE?5?$DN?5?$CFlx?6?$AA@IMHBAIGO@
EDATA32	SEGMENT
??_C@_0M@GKIBMKHE@CODE?5?$DN?5?$CFlx?6?$AA@IMHBAIGO@ DB 'CODE = %lx', 0aH
	DB	00H						;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT ??_C@_0L@NHBJHPNH@CODE?5?$DN?5?$CFx?6?$AA@IMHBAIGO@
EDATA32	SEGMENT
??_C@_0L@NHBJHPNH@CODE?5?$DN?5?$CFx?6?$AA@IMHBAIGO@ DB 'CODE = %x', 0aH, 00H ;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT ??_C@_0M@OFODFNCD@CODE?5?$DN?5?$CFhx?6?$AA@IMHBAIGO@
EDATA32	SEGMENT
??_C@_0M@OFODFNCD@CODE?5?$DN?5?$CFhx?6?$AA@IMHBAIGO@ DB 'CODE = %hx', 0aH
	DB	00H						;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT ??_C@_0BJ@BAFGNCAE@ACM?5PROGRESS?5MARK?5?$DN?5?$CFhx?6?$AA@IMHBAIGO@
EDATA32	SEGMENT
??_C@_0BJ@BAFGNCAE@ACM?5PROGRESS?5MARK?5?$DN?5?$CFhx?6?$AA@IMHBAIGO@ DB 'A'
	DB	'CM PROGRESS MARK = %hx', 0aH, 00H		;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT ??_C@_01FGNFDNOH@?$CF?$AA@IMHBAIGO@
EDATA32	SEGMENT
??_C@_01FGNFDNOH@?$CF?$AA@IMHBAIGO@ DB '%', 00H		;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\trace\trace.c
;	COMDAT ___Trace
_TEXT	SEGMENT
_tmp$ = -376						; size = 256
_val$ = -120						; size = 97
_arg$ = -20						; size = 8
_arg$2$ = -12						; size = 4
_arg$1$ = -12						; size = 4
tv517 = -8						; size = 4
tv516 = -4						; size = 4
_Fmt$ = 8						; size = 4
_argptr$ = 12						; size = 4
___Trace PROC						; COMDAT

; 133  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 78 01 00
	00		 sub	 esp, 376		; 00000178H

; 134  :   UINT64 arg;
; 135  :   UINT32 i;
; 136  :   UINT8 val[97]; // digest256 + 0 terminator
; 137  :   char *pThis;
; 138  :   char *pNext;
; 139  :   char tmp[256];
; 140  : 
; 141  :   if (!IS_TRACE_ENABLED) {

  00009	f6 05 0c 00 00
	00 01		 test	 BYTE PTR _traceRoutines+12, 1
  00010	0f 84 02 02 00
	00		 je	 $LN34@Trace

; 142  :     return;
; 143  :   }
; 144  : 
; 145  :   pThis = Fmt;

  00016	8b 45 0c	 mov	 eax, DWORD PTR _argptr$[ebp]
  00019	56		 push	 esi
  0001a	8b 75 08	 mov	 esi, DWORD PTR _Fmt$[ebp]
  0001d	57		 push	 edi
  0001e	8d 78 fc	 lea	 edi, DWORD PTR [eax-4]
  00021	83 c0 f8	 add	 eax, -8			; fffffff8H
  00024	89 45 fc	 mov	 DWORD PTR tv516[ebp], eax
  00027	53		 push	 ebx
$LL2@Trace:

; 146  : 
; 147  :   for (;;) {
; 148  :     for (i = 0; pThis[i] != 0; i++) {

  00028	33 db		 xor	 ebx, ebx
  0002a	38 1e		 cmp	 BYTE PTR [esi], bl
  0002c	74 0d		 je	 SHORT $LN55@Trace
$LL7@Trace:

; 149  :       if (pThis[i] == '%') {

  0002e	80 3c 33 25	 cmp	 BYTE PTR [ebx+esi], 37	; 00000025H
  00032	74 07		 je	 SHORT $LN55@Trace

; 146  : 
; 147  :   for (;;) {
; 148  :     for (i = 0; pThis[i] != 0; i++) {

  00034	43		 inc	 ebx
  00035	80 3c 33 00	 cmp	 BYTE PTR [ebx+esi], 0
  00039	75 f3		 jne	 SHORT $LL7@Trace
$LN55@Trace:

; 150  :         break;
; 151  :       }
; 152  :     }
; 153  :     //
; 154  :     // No format - just out the string.
; 155  :     //
; 156  :     if (pThis[i] == 0) {

  0003b	80 3c 33 00	 cmp	 BYTE PTR [ebx+esi], 0
  0003f	0f 84 c6 01 00
	00		 je	 $LN42@Trace

; 158  :       return;
; 159  :     }
; 160  : 
; 161  :     //
; 162  :     // Found format specifier. Copy and out string so far
; 163  :     // If format string is too long, trancate and exit.
; 164  :     //
; 165  : 
; 166  :     if (i > sizeof(tmp) - sizeof("%llx")) {

  00045	81 fb fb 00 00
	00		 cmp	 ebx, 251		; 000000fbH
  0004b	0f 87 b6 01 00
	00		 ja	 $LN43@Trace

; 168  :       TraceWriteString(pThis, 0);
; 169  :       return;
; 170  :     }
; 171  : 
; 172  :     //
; 173  :     // Copy and out string so far
; 174  :     //
; 175  :     //copyData(tmp, pThis, i); // causes corruption in serial log
; 176  :     copyMemory(tmp, pThis, i);

  00051	53		 push	 ebx
  00052	8d 85 88 fe ff
	ff		 lea	 eax, DWORD PTR _tmp$[ebp]
  00058	56		 push	 esi
  00059	50		 push	 eax
  0005a	e8 00 00 00 00	 call	 _copyMemory

; 177  :     tmp[i] = 0;
; 178  :     TraceWriteString(tmp, 0);

  0005f	8d 85 88 fe ff
	ff		 lea	 eax, DWORD PTR _tmp$[ebp]
  00065	c6 84 1d 88 fe
	ff ff 00	 mov	 BYTE PTR _tmp$[ebp+ebx], 0
  0006d	6a 00		 push	 0
  0006f	50		 push	 eax
  00070	e8 00 00 00 00	 call	 _TraceWriteString

; 179  : 
; 180  :     pNext = pThis + i + 1;

  00075	03 f3		 add	 esi, ebx
  00077	83 c4 14	 add	 esp, 20			; 00000014H

; 181  :     //
; 182  :     // Analize format token
; 183  :     //
; 184  :     if (pNext[0] == '%') {

  0007a	8a 46 01	 mov	 al, BYTE PTR [esi+1]
  0007d	3c 25		 cmp	 al, 37			; 00000025H
  0007f	75 0f		 jne	 SHORT $LN18@Trace

; 185  :       //
; 186  :       // %% format
; 187  :       //
; 188  :       pThis = pNext + 1;
; 189  :       TraceWriteString("%", 0);

  00081	6a 00		 push	 0
  00083	83 c6 02	 add	 esi, 2
  00086	68 00 00 00 00	 push	 OFFSET ??_C@_01FGNFDNOH@?$CF?$AA@IMHBAIGO@
  0008b	e9 6b 01 00 00	 jmp	 $LN60@Trace
$LN18@Trace:

; 190  :     } else if ((pNext[0] == 'c')) {

  00090	3c 63		 cmp	 al, 99			; 00000063H
  00092	75 11		 jne	 SHORT $LN20@Trace

; 191  :       //
; 192  :       // %c format
; 193  :       //
; 194  :       arg = va_arg(argptr, UINT8);

  00094	83 c7 04	 add	 edi, 4

; 195  :       pThis = pNext + 1;
; 196  :       val[0] = (char) arg;
; 197  :       val[1] = 0;

  00097	c6 45 89 00	 mov	 BYTE PTR _val$[ebp+1], 0
  0009b	8a 07		 mov	 al, BYTE PTR [edi]
  0009d	88 45 88	 mov	 BYTE PTR _val$[ebp], al

; 198  :       TraceWriteString(val, 0);

  000a0	e9 49 01 00 00	 jmp	 $LN62@Trace
$LN20@Trace:

; 199  :     } else if ((pNext[0] == 'h') && (pNext[1] == 'x')) {

  000a5	3c 68		 cmp	 al, 104			; 00000068H
  000a7	75 1a		 jne	 SHORT $LN22@Trace
  000a9	80 7e 02 78	 cmp	 BYTE PTR [esi+2], 120	; 00000078H
  000ad	75 14		 jne	 SHORT $LN22@Trace

; 200  :       //
; 201  :       // %hx format
; 202  :       //
; 203  :       arg = va_arg(argptr, UINT8);

  000af	83 45 fc 04	 add	 DWORD PTR tv516[ebp], 4
  000b3	83 c7 04	 add	 edi, 4

; 204  :       pThis = pNext + 2;

  000b6	83 c6 03	 add	 esi, 3

; 205  :       NumToStr(val, 1, arg);

  000b9	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  000bc	99		 cdq
  000bd	52		 push	 edx
  000be	50		 push	 eax
  000bf	6a 01		 push	 1

; 206  :       TraceWriteString(val, 0);

  000c1	eb 57		 jmp	 SHORT $LN61@Trace
$LN22@Trace:

; 207  :     } else if ((pNext[0] == 'x')) {

  000c3	3c 78		 cmp	 al, 120			; 00000078H
  000c5	75 14		 jne	 SHORT $LN24@Trace

; 208  :       //
; 209  :       // %x format
; 210  :       //
; 211  :       arg = va_arg(argptr, UINT16);

  000c7	83 45 fc 04	 add	 DWORD PTR tv516[ebp], 4
  000cb	83 c7 04	 add	 edi, 4

; 212  :       pThis = pNext + 1;

  000ce	83 c6 02	 add	 esi, 2

; 213  :       NumToStr(val, 2, arg);

  000d1	0f b7 07	 movzx	 eax, WORD PTR [edi]
  000d4	99		 cdq
  000d5	52		 push	 edx
  000d6	50		 push	 eax
  000d7	6a 02		 push	 2

; 214  :       TraceWriteString(val, 0);

  000d9	eb 3f		 jmp	 SHORT $LN61@Trace
$LN24@Trace:

; 215  :     } else if ((pNext[0] == 'l') && (pNext[1] == 'x')) {

  000db	3c 6c		 cmp	 al, 108			; 0000006cH
  000dd	75 57		 jne	 SHORT $LN28@Trace
  000df	8a 4e 02	 mov	 cl, BYTE PTR [esi+2]
  000e2	80 f9 78	 cmp	 cl, 120			; 00000078H
  000e5	75 12		 jne	 SHORT $LN26@Trace

; 216  :       //
; 217  :       // %lx format
; 218  :       //
; 219  :       arg = va_arg(argptr, UINT32);

  000e7	83 45 fc 04	 add	 DWORD PTR tv516[ebp], 4
  000eb	83 c7 04	 add	 edi, 4

; 220  :       pThis = pNext + 2;
; 221  :       NumToStr(val, 4, arg);

  000ee	6a 00		 push	 0
  000f0	83 c6 03	 add	 esi, 3
  000f3	ff 37		 push	 DWORD PTR [edi]
  000f5	6a 04		 push	 4

; 222  :       TraceWriteString(val, 0);

  000f7	eb 21		 jmp	 SHORT $LN61@Trace
$LN26@Trace:

; 223  :     } else if ((pNext[0] == 'l') && (pNext[1] == 'l') && (pNext[2] == 'x')) {

  000f9	80 f9 6c	 cmp	 cl, 108			; 0000006cH
  000fc	75 38		 jne	 SHORT $LN28@Trace
  000fe	80 7e 03 78	 cmp	 BYTE PTR [esi+3], 120	; 00000078H
  00102	75 32		 jne	 SHORT $LN28@Trace

; 224  :       //
; 225  :       // %llx format
; 226  :       //
; 227  :       arg = va_arg(argptr, UINT64);

  00104	8b 45 fc	 mov	 eax, DWORD PTR tv516[ebp]
  00107	83 c7 08	 add	 edi, 8
  0010a	83 c0 08	 add	 eax, 8

; 228  :       pThis = pNext + 3;

  0010d	83 c6 04	 add	 esi, 4
  00110	89 45 fc	 mov	 DWORD PTR tv516[ebp], eax

; 229  :       NumToStr(val, 8, arg);

  00113	ff 70 04	 push	 DWORD PTR [eax+4]
  00116	ff 30		 push	 DWORD PTR [eax]
  00118	6a 08		 push	 8
$LN61@Trace:
  0011a	8d 45 88	 lea	 eax, DWORD PTR _val$[ebp]
  0011d	50		 push	 eax
  0011e	e8 00 00 00 00	 call	 _NumToStr

; 230  :       TraceWriteString(val, 0);

  00123	8d 45 88	 lea	 eax, DWORD PTR _val$[ebp]
  00126	6a 00		 push	 0
  00128	50		 push	 eax
  00129	e8 00 00 00 00	 call	 _TraceWriteString
  0012e	83 c4 18	 add	 esp, 24			; 00000018H
  00131	e9 f2 fe ff ff	 jmp	 $LL2@Trace
$LN28@Trace:

; 231  :     } else if ((pNext[0] == 'd') && (pNext[1] == '1') && (pNext[2] == 'x')) {

  00136	3c 64		 cmp	 al, 100			; 00000064H
  00138	0f 85 a9 00 00
	00		 jne	 $LN32@Trace
  0013e	8a 4e 02	 mov	 cl, BYTE PTR [esi+2]
  00141	80 f9 31	 cmp	 cl, 49			; 00000031H
  00144	75 4c		 jne	 SHORT $LN30@Trace
  00146	80 7e 03 78	 cmp	 BYTE PTR [esi+3], 120	; 00000078H
  0014a	75 46		 jne	 SHORT $LN30@Trace

; 232  :       //
; 233  :       // %d1x format
; 234  :       //
; 235  :       arg = va_arg(argptr, UINT32);

  0014c	83 45 fc 04	 add	 DWORD PTR tv516[ebp], 4
  00150	83 c7 04	 add	 edi, 4
  00153	83 65 f0 00	 and	 DWORD PTR _arg$[ebp+4], 0

; 236  :       pThis = pNext + 3;

  00157	83 c6 04	 add	 esi, 4
  0015a	89 7d f8	 mov	 DWORD PTR tv517[ebp], edi

; 237  :       for (i = 0; i < 20; i++) {

  0015d	33 db		 xor	 ebx, ebx
  0015f	89 75 08	 mov	 DWORD PTR _Fmt$[ebp], esi
  00162	8b 07		 mov	 eax, DWORD PTR [edi]
  00164	8d 7d 88	 lea	 edi, DWORD PTR _val$[ebp]
  00167	89 45 f4	 mov	 DWORD PTR _arg$1$[ebp], eax
  0016a	8b f0		 mov	 esi, eax
$LL10@Trace:

; 238  :         NumToStr8(val + i * 3, *((UINT8 *) arg + i));

  0016c	0f b6 04 1e	 movzx	 eax, BYTE PTR [esi+ebx]
  00170	50		 push	 eax
  00171	57		 push	 edi
  00172	e8 00 00 00 00	 call	 _NumToStr8

; 239  :         *(val + i * 3 - 1) = 0x20;

  00177	c6 47 ff 20	 mov	 BYTE PTR [edi-1], 32	; 00000020H
  0017b	43		 inc	 ebx
  0017c	59		 pop	 ecx
  0017d	83 c7 03	 add	 edi, 3
  00180	59		 pop	 ecx
  00181	83 fb 14	 cmp	 ebx, 20			; 00000014H
  00184	72 e6		 jb	 SHORT $LL10@Trace

; 240  :       }
; 241  :       *(val + 61) = 0;

  00186	8b 75 08	 mov	 esi, DWORD PTR _Fmt$[ebp]
  00189	8b 7d f8	 mov	 edi, DWORD PTR tv517[ebp]
  0018c	c6 45 c5 00	 mov	 BYTE PTR _val$[ebp+61], 0

; 242  :       TraceWriteString(val, 0);

  00190	eb 63		 jmp	 SHORT $LN59@Trace
$LN30@Trace:

; 243  :     } else if ((pNext[0] == 'd') && (pNext[1] == '2') && (pNext[2] == 'x')) {

  00192	80 f9 32	 cmp	 cl, 50			; 00000032H
  00195	75 50		 jne	 SHORT $LN32@Trace
  00197	80 7e 03 78	 cmp	 BYTE PTR [esi+3], 120	; 00000078H
  0019b	75 4a		 jne	 SHORT $LN32@Trace

; 244  :       //
; 245  :       // %d1x format
; 246  :       //
; 247  :       arg = va_arg(argptr, UINT32);

  0019d	83 45 fc 04	 add	 DWORD PTR tv516[ebp], 4
  001a1	83 c7 04	 add	 edi, 4
  001a4	83 65 f0 00	 and	 DWORD PTR _arg$[ebp+4], 0

; 248  :       pThis = pNext + 3;

  001a8	83 c6 04	 add	 esi, 4
  001ab	89 7d f8	 mov	 DWORD PTR tv517[ebp], edi

; 249  :       for (i = 0; i < 32; i++) {

  001ae	33 db		 xor	 ebx, ebx
  001b0	89 75 08	 mov	 DWORD PTR _Fmt$[ebp], esi
  001b3	8b 07		 mov	 eax, DWORD PTR [edi]
  001b5	8d 7d 88	 lea	 edi, DWORD PTR _val$[ebp]
  001b8	89 45 f4	 mov	 DWORD PTR _arg$2$[ebp], eax
  001bb	8b f0		 mov	 esi, eax
$LL13@Trace:

; 250  :         NumToStr8(val + i * 3, *((UINT8 *) arg + i));

  001bd	0f b6 04 1e	 movzx	 eax, BYTE PTR [esi+ebx]
  001c1	50		 push	 eax
  001c2	57		 push	 edi
  001c3	e8 00 00 00 00	 call	 _NumToStr8

; 251  :         *(val + i * 3 - 1) = 0x20;

  001c8	c6 47 ff 20	 mov	 BYTE PTR [edi-1], 32	; 00000020H
  001cc	43		 inc	 ebx
  001cd	59		 pop	 ecx
  001ce	83 c7 03	 add	 edi, 3
  001d1	59		 pop	 ecx
  001d2	83 fb 20	 cmp	 ebx, 32			; 00000020H
  001d5	72 e6		 jb	 SHORT $LL13@Trace

; 252  :       }
; 253  :       //
; 254  :       // Enter LF after 20th char to start from new line.
; 255  :       //
; 256  :       *(val + 59) = 0xA;

  001d7	8b 75 08	 mov	 esi, DWORD PTR _Fmt$[ebp]
  001da	8b 7d f8	 mov	 edi, DWORD PTR tv517[ebp]
  001dd	c6 45 c3 0a	 mov	 BYTE PTR _val$[ebp+59], 10 ; 0000000aH

; 257  :       *(val + 96) = 0;

  001e1	c6 45 e8 00	 mov	 BYTE PTR _val$[ebp+96], 0

; 258  :       TraceWriteString(val, 0);

  001e5	eb 0e		 jmp	 SHORT $LN59@Trace
$LN32@Trace:

; 259  :     } else if ((pNext[0] == 's')) {

  001e7	3c 73		 cmp	 al, 115			; 00000073H
  001e9	75 2a		 jne	 SHORT $LN58@Trace

; 260  :       //
; 261  :       // %s format
; 262  :       //
; 263  :       arg = va_arg(argptr, UINT32);

  001eb	83 c7 04	 add	 edi, 4
$LN62@Trace:
  001ee	83 45 fc 04	 add	 DWORD PTR tv516[ebp], 4

; 264  :       pThis = pNext + 1;

  001f2	83 c6 02	 add	 esi, 2
$LN59@Trace:

; 265  :       TraceWriteString(val, 0);

  001f5	6a 00		 push	 0
  001f7	8d 45 88	 lea	 eax, DWORD PTR _val$[ebp]
  001fa	50		 push	 eax
$LN60@Trace:
  001fb	e8 00 00 00 00	 call	 _TraceWriteString
  00200	59		 pop	 ecx
  00201	59		 pop	 ecx

; 266  :     } else {
; 267  :       //
; 268  :       // Unrecognized
; 269  :       //
; 270  :       return;
; 271  :     }
; 272  :   }

  00202	e9 21 fe ff ff	 jmp	 $LL2@Trace
$LN43@Trace:

; 167  :       pThis[i] = 0;

  00207	c6 04 33 00	 mov	 BYTE PTR [ebx+esi], 0
$LN42@Trace:

; 157  :       TraceWriteString(pThis, 0);

  0020b	6a 00		 push	 0
  0020d	56		 push	 esi
  0020e	e8 00 00 00 00	 call	 _TraceWriteString
  00213	59		 pop	 ecx
  00214	59		 pop	 ecx
$LN58@Trace:
  00215	5b		 pop	 ebx
  00216	5f		 pop	 edi
  00217	5e		 pop	 esi
$LN34@Trace:

; 273  : }

  00218	8b e5		 mov	 esp, ebp
  0021a	5d		 pop	 ebp
  0021b	c3		 ret	 0
___Trace ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\trace\trace.c
;	COMDAT _NumToStr8
_TEXT	SEGMENT
_p$ = 8							; size = 4
_n$ = 12						; size = 1
_NumToStr8 PROC						; COMDAT

; 51   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 52   :   UINT32 i;
; 53   : 
; 54   :   for (i = 0; i < 2; i++) {

  00003	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  00006	33 c9		 xor	 ecx, ecx
$LL4@NumToStr8:

; 55   :     __asm {
; 56   :       rol n, 4;

  00008	c0 45 0c 04	 rol	 BYTE PTR _n$[ebp], 4

; 57   :     };
; 58   :     p[i] = nib[n & 0xF];

  0000c	0f b6 45 0c	 movzx	 eax, BYTE PTR _n$[ebp]
  00010	83 e0 0f	 and	 eax, 15			; 0000000fH
  00013	8a 80 00 00 00
	00		 mov	 al, BYTE PTR _nib[eax]
  00019	88 04 11	 mov	 BYTE PTR [ecx+edx], al
  0001c	41		 inc	 ecx
  0001d	83 f9 02	 cmp	 ecx, 2
  00020	72 e6		 jb	 SHORT $LL4@NumToStr8

; 59   :   }
; 60   :   p[i] = 0;

  00022	c6 04 11 00	 mov	 BYTE PTR [ecx+edx], 0

; 61   : }

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
_NumToStr8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\trace\trace.c
;	COMDAT _PchUartSerialOut
_TEXT	SEGMENT
_str$ = 8						; size = 4
_len$ = 12						; size = 4
_PchUartSerialOut PROC					; COMDAT

; 385  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 386  :   while (*str) {

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  00006	80 39 00	 cmp	 BYTE PTR [ecx], 0
  00009	74 22		 je	 SHORT $LN3@PchUartSer

; 387  :     while (0 == (ReadMmioByte(UART2_BAR + 4 * LINE_STATUS) & TRANS_HOLDING_REG_EMPTY)) {

  0000b	56		 push	 esi
  0000c	be 14 60 03 fe	 mov	 esi, -33333228		; fe036014H

; 392  :     }
; 393  :     WriteMmioByte(UART2_BAR + 4 * TRANSMIT_HOLDING, *str++);

  00011	8d 56 ec	 lea	 edx, DWORD PTR [esi-20]
$LL4@PchUartSer:

; 387  :     while (0 == (ReadMmioByte(UART2_BAR + 4 * LINE_STATUS) & TRANS_HOLDING_REG_EMPTY)) {

  00014	8a 06		 mov	 al, BYTE PTR [esi]
  00016	a8 20		 test	 al, 32			; 00000020H
  00018	74 fa		 je	 SHORT $LL4@PchUartSer

; 388  :       ;
; 389  :     }
; 390  :     if ((*str) == 0xa) {

  0001a	80 39 0a	 cmp	 BYTE PTR [ecx], 10	; 0000000aH
  0001d	75 03		 jne	 SHORT $LN6@PchUartSer

; 391  :       WriteMmioByte(UART2_BAR + 4 * TRANSMIT_HOLDING, 0xd);

  0001f	c6 02 0d	 mov	 BYTE PTR [edx], 13	; 0000000dH
$LN6@PchUartSer:

; 392  :     }
; 393  :     WriteMmioByte(UART2_BAR + 4 * TRANSMIT_HOLDING, *str++);

  00022	8a 01		 mov	 al, BYTE PTR [ecx]
  00024	41		 inc	 ecx
  00025	88 02		 mov	 BYTE PTR [edx], al
  00027	80 39 00	 cmp	 BYTE PTR [ecx], 0
  0002a	75 e8		 jne	 SHORT $LL4@PchUartSer
  0002c	5e		 pop	 esi
$LN3@PchUartSer:

; 394  :   }
; 395  : }

  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
_PchUartSerialOut ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\trace\trace.c
;	COMDAT _NumToStr
_TEXT	SEGMENT
_p$ = 8							; size = 4
_w$ = 12						; size = 4
_n$ = 16						; size = 8
_NumToStr PROC						; COMDAT

; 79   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 80   :   UINT32 i;
; 81   : 
; 82   :   for (i = 0; i < w; i++) {

  00004	8b 75 0c	 mov	 esi, DWORD PTR _w$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 20		 je	 SHORT $LN3@NumToStr
  0000b	53		 push	 ebx
  0000c	57		 push	 edi
  0000d	8b 7d 08	 mov	 edi, DWORD PTR _p$[ebp]
  00010	8d 5c 35 0f	 lea	 ebx, DWORD PTR _n$[ebp+esi-1]
$LL4@NumToStr:

; 83   :     NumToStr8(p + i * 2, *(((UINT8 *) &n) + w - i - 1));

  00014	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  00017	50		 push	 eax
  00018	57		 push	 edi
  00019	e8 00 00 00 00	 call	 _NumToStr8
  0001e	59		 pop	 ecx
  0001f	4b		 dec	 ebx
  00020	83 c7 02	 add	 edi, 2
  00023	59		 pop	 ecx
  00024	83 ee 01	 sub	 esi, 1
  00027	75 eb		 jne	 SHORT $LL4@NumToStr
  00029	5f		 pop	 edi
  0002a	5b		 pop	 ebx
$LN3@NumToStr:
  0002b	5e		 pop	 esi

; 84   :   }
; 85   : }

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
_NumToStr ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\trace\trace.c
;	COMDAT _HexDump
_TEXT	SEGMENT
_buffer$ = 8						; size = 4
_buffer_size$ = 12					; size = 4
_HexDump PROC						; COMDAT

; 412  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 413  :   if ((buffer == NULL) || (buffer_size == 0)) {

  00004	8b 75 08	 mov	 esi, DWORD PTR _buffer$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 52		 je	 SHORT $LN6@HexDump
  0000b	57		 push	 edi
  0000c	8b 7d 0c	 mov	 edi, DWORD PTR _buffer_size$[ebp]
  0000f	85 ff		 test	 edi, edi
  00011	74 49		 je	 SHORT $LN13@HexDump

; 414  :     return;
; 415  :   }
; 416  : 
; 417  :   UINT8 *ptr = (UINT8 *)buffer;
; 418  : 
; 419  :   for (UINT32 i = 0; i < buffer_size; i++) {

  00013	53		 push	 ebx
  00014	33 db		 xor	 ebx, ebx
  00016	85 ff		 test	 edi, edi
  00018	74 36		 je	 SHORT $LN3@HexDump
$LL4@HexDump:

; 420  :     if (!(i % 16)) {

  0001a	f6 c3 0f	 test	 bl, 15			; 0000000fH
  0001d	75 1b		 jne	 SHORT $LN7@HexDump

; 421  :       TRACE("|\n"); // Can't do this in one line due to bug in trace function

  0001f	68 00 00 00 00	 push	 OFFSET ??_C@_02KHLKFPFD@?$HM?6?$AA@IMHBAIGO@
  00024	e8 00 00 00 00	 call	 _Trace

; 422  :       TRACE(" %lx | ", &ptr[i]);

  00029	8d 04 33	 lea	 eax, DWORD PTR [ebx+esi]
  0002c	50		 push	 eax
  0002d	68 00 00 00 00	 push	 OFFSET ??_C@_07CAOHCKHM@?5?$CFlx?5?$HM?5?$AA@IMHBAIGO@
  00032	e8 00 00 00 00	 call	 _Trace
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN7@HexDump:

; 423  :     }
; 424  :     TRACE("%hx ", ptr[i]);

  0003a	0f b6 04 33	 movzx	 eax, BYTE PTR [ebx+esi]
  0003e	50		 push	 eax
  0003f	68 00 00 00 00	 push	 OFFSET ??_C@_04BAIGKDA@?$CFhx?5?$AA@IMHBAIGO@
  00044	e8 00 00 00 00	 call	 _Trace
  00049	43		 inc	 ebx
  0004a	59		 pop	 ecx
  0004b	59		 pop	 ecx
  0004c	3b df		 cmp	 ebx, edi
  0004e	72 ca		 jb	 SHORT $LL4@HexDump
$LN3@HexDump:

; 425  :   }
; 426  :   TRACE("\n");

  00050	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6?$AA@IMHBAIGO@
  00055	e8 00 00 00 00	 call	 _Trace
  0005a	59		 pop	 ecx
  0005b	5b		 pop	 ebx
$LN13@HexDump:
  0005c	5f		 pop	 edi
$LN6@HexDump:
  0005d	5e		 pop	 esi

; 427  : }

  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
_HexDump ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\trace\trace.c
;	COMDAT __Trace
_TEXT	SEGMENT
_Format$ = 8						; size = 4
__Trace	PROC						; COMDAT

; 294  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 295  :   va_list Marker;
; 296  : 
; 297  :   va_start(Marker, Format);
; 298  :   __Trace(Format, Marker);

  00003	8d 45 0c	 lea	 eax, DWORD PTR _Format$[ebp+4]
  00006	50		 push	 eax
  00007	ff 75 08	 push	 DWORD PTR _Format$[ebp]
  0000a	e8 00 00 00 00	 call	 ___Trace
  0000f	59		 pop	 ecx
  00010	59		 pop	 ecx

; 299  :   va_end(Marker);
; 300  : }

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
__Trace	ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\trace\trace.c
;	COMDAT _TraceValue
_TEXT	SEGMENT
_code$ = 8						; size = 8
_width$ = 16						; size = 4
_TraceValue PROC					; COMDAT

; 367  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 368  :   switch (width) {

  00003	8b 45 10	 mov	 eax, DWORD PTR _width$[ebp]
  00006	83 f8 08	 cmp	 eax, 8
  00009	74 36		 je	 SHORT $LN4@TraceValue
  0000b	83 f8 10	 cmp	 eax, 16			; 00000010H
  0000e	74 24		 je	 SHORT $LN5@TraceValue
  00010	83 f8 20	 cmp	 eax, 32			; 00000020H
  00013	74 12		 je	 SHORT $LN6@TraceValue
  00015	83 f8 40	 cmp	 eax, 64			; 00000040H
  00018	75 3a		 jne	 SHORT $LN2@TraceValue

; 378  :   case 64:
; 379  :     Trace("CODE = %llx\n", code);

  0001a	ff 75 0c	 push	 DWORD PTR _code$[ebp+4]
  0001d	ff 75 08	 push	 DWORD PTR _code$[ebp]
  00020	68 00 00 00 00	 push	 OFFSET ??_C@_0N@CFODKAJD@CODE?5?$DN?5?$CFllx?6?$AA@IMHBAIGO@
  00025	eb 25		 jmp	 SHORT $LN9@TraceValue
$LN6@TraceValue:

; 375  :   case 32:
; 376  :     Trace("CODE = %lx\n", code);

  00027	ff 75 0c	 push	 DWORD PTR _code$[ebp+4]
  0002a	ff 75 08	 push	 DWORD PTR _code$[ebp]
  0002d	68 00 00 00 00	 push	 OFFSET ??_C@_0M@GKIBMKHE@CODE?5?$DN?5?$CFlx?6?$AA@IMHBAIGO@

; 377  :     break;

  00032	eb 18		 jmp	 SHORT $LN9@TraceValue
$LN5@TraceValue:

; 371  :     break;
; 372  :   case 16:
; 373  :     Trace("CODE = %x\n", code);

  00034	ff 75 0c	 push	 DWORD PTR _code$[ebp+4]
  00037	ff 75 08	 push	 DWORD PTR _code$[ebp]
  0003a	68 00 00 00 00	 push	 OFFSET ??_C@_0L@NHBJHPNH@CODE?5?$DN?5?$CFx?6?$AA@IMHBAIGO@

; 374  :     break;

  0003f	eb 0b		 jmp	 SHORT $LN9@TraceValue
$LN4@TraceValue:

; 369  :   case 8:
; 370  :     Trace("CODE = %hx\n", code);

  00041	ff 75 0c	 push	 DWORD PTR _code$[ebp+4]
  00044	ff 75 08	 push	 DWORD PTR _code$[ebp]
  00047	68 00 00 00 00	 push	 OFFSET ??_C@_0M@OFODFNCD@CODE?5?$DN?5?$CFhx?6?$AA@IMHBAIGO@
$LN9@TraceValue:
  0004c	e8 00 00 00 00	 call	 _Trace
  00051	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@TraceValue:

; 380  :     break;
; 381  :   }
; 382  : }

  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
_TraceValue ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\trace\trace.c
;	COMDAT _TraceProgress
_TEXT	SEGMENT
_code$ = 8						; size = 4
_TraceProgress PROC					; COMDAT

; 350  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 351  :   Trace("ACM PROGRESS MARK = %hx\n", code);

  00003	ff 75 08	 push	 DWORD PTR _code$[ebp]
  00006	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@BAFGNCAE@ACM?5PROGRESS?5MARK?5?$DN?5?$CFhx?6?$AA@IMHBAIGO@
  0000b	e8 00 00 00 00	 call	 _Trace
  00010	59		 pop	 ecx
  00011	59		 pop	 ecx

; 352  : }

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
_TraceProgress ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\trace\trace.c
;	COMDAT _Trace
_TEXT	SEGMENT
_Format$ = 8						; size = 4
_Trace	PROC						; COMDAT

; 319  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 320  :   va_list Marker;
; 321  :   PTR_FUNC_NO_ARG pFunc = (PTR_FUNC_NO_ARG)traceRoutines.preTrace;

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR _traceRoutines

; 322  : 
; 323  :   // If ACM has a pre-trace routine, call it.
; 324  :   if (pFunc) {

  00008	85 c0		 test	 eax, eax
  0000a	74 02		 je	 SHORT $LN2@Trace

; 325  :     (*pFunc)();

  0000c	ff d0		 call	 eax
$LN2@Trace:

; 326  :   }
; 327  :   va_start(Marker, Format);
; 328  :   __Trace(Format, Marker);

  0000e	8d 45 0c	 lea	 eax, DWORD PTR _Format$[ebp+4]
  00011	50		 push	 eax
  00012	ff 75 08	 push	 DWORD PTR _Format$[ebp]
  00015	e8 00 00 00 00	 call	 ___Trace

; 329  :   // If ACM has a post-trace routine, call it
; 330  :   pFunc = (PTR_FUNC_NO_ARG)traceRoutines.postTrace;

  0001a	a1 04 00 00 00	 mov	 eax, DWORD PTR _traceRoutines+4
  0001f	59		 pop	 ecx
  00020	59		 pop	 ecx

; 331  :   if (pFunc) {

  00021	85 c0		 test	 eax, eax
  00023	74 03		 je	 SHORT $LN3@Trace

; 333  :   }
; 334  :   va_end(Marker);
; 335  : }

  00025	5d		 pop	 ebp

; 332  :     (*pFunc)();

  00026	ff e0		 jmp	 eax
$LN3@Trace:

; 333  :   }
; 334  :   va_end(Marker);
; 335  : }

  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
_Trace	ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\trace\trace.c
;	COMDAT _TraceWriteString
_TEXT	SEGMENT
_str$ = 8						; size = 4
_len$ = 12						; size = 4
_TraceWriteString PROC					; COMDAT

; 101  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 102  :   TRACE_WRITE_STRING pFunc = (TRACE_WRITE_STRING)traceRoutines.writeString;

  00003	a1 08 00 00 00	 mov	 eax, DWORD PTR _traceRoutines+8

; 103  : 
; 104  :   if (pFunc) {

  00008	85 c0		 test	 eax, eax
  0000a	74 03		 je	 SHORT $LN2@TraceWrite

; 106  :   }
; 107  : }

  0000c	5d		 pop	 ebp

; 105  :     (*pFunc)(str, len);

  0000d	ff e0		 jmp	 eax
$LN2@TraceWrite:

; 106  :   }
; 107  : }

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
_TraceWriteString ENDP
_TEXT	ENDS
END

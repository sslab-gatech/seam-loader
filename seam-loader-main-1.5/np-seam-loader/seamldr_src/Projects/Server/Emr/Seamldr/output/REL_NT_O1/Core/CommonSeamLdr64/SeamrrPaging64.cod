; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24245.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	MapPage
PUBLIC	InitPseamldrPtCtx
EXTRN	SeamldrData:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$MapPage DD imagerel $LN17
	DD	imagerel $LN17+329
	DD	imagerel $unwind$MapPage
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$MapPage DD 0a1701H
	DD	067417H
	DD	056417H
	DD	045417H
	DD	033417H
	DD	0e015f017H
xdata	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\commonseamldr64\seamrrpaging64.c
;	COMDAT InitPseamldrPtCtx
_TEXT	SEGMENT
SeamrrPtCtx$ = 8
SeamRrVa$ = 16
SeamRrBase$ = 24
SeamRrSize$ = 32
PSeamldrRangeBase$ = 40
PagingStructSize$ = 48
InitPseamldrPtCtx PROC					; COMDAT

; 26   :     (void)SeamRrSize;
; 27   :     COMSERIALOUT("InitSeamrrPtCtx\n");
; 28   :     PRINT_HEX_VAL("SeamRrBase: 0x", SeamRrBase);
; 29   :     PRINT_HEX_VAL("SeamRrSize: 0x", SeamRrSize);
; 30   :         
; 31   :     SeamrrPtCtx->PtBaseAddrLa = SeamRrVa + (PSeamldrRangeBase - SeamRrBase) + _8KB;    

  00000	49 2b d0	 sub	 rdx, r8

; 32   :     SeamrrPtCtx->PtBaseAddrPa = SeamRrBase + (PSeamldrRangeBase - SeamRrBase) + _8KB;
; 33   :     
; 34   :     SeamrrPtCtx->PtAllocatorPa = SeamrrPtCtx->PtBaseAddrPa + _4KB;
; 35   :     SeamrrPtCtx->NumPageLevels = 4;

  00003	48 c7 41 18 04
	00 00 00	 mov	 QWORD PTR [rcx+24], 4
  0000b	4c 8b 44 24 28	 mov	 r8, QWORD PTR PSeamldrRangeBase$[rsp]

; 36   : 
; 37   :     SeamrrPtCtx->VPDelta = SeamRrVa - SeamRrBase;

  00010	48 89 51 20	 mov	 QWORD PTR [rcx+32], rdx
  00014	49 8d 80 00 20
	00 00		 lea	 rax, QWORD PTR [r8+8192]
  0001b	48 03 c2	 add	 rax, rdx
  0001e	48 89 01	 mov	 QWORD PTR [rcx], rax
  00021	49 8d 80 00 20
	00 00		 lea	 rax, QWORD PTR [r8+8192]
  00028	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
  0002c	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  00032	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 38   : 
; 39   :     SeamrrPtCtx->PagingStructSize = PagingStructSize;

  00036	48 8b 44 24 30	 mov	 rax, QWORD PTR PagingStructSize$[rsp]
  0003b	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 40   : 
; 41   :     PRINT_HEX_VAL("SeamrrPtCtx->PtBaseAddrLa: 0x", SeamrrPtCtx->PtBaseAddrLa);
; 42   :     PRINT_HEX_VAL("SeamrrPtCtx->PtBaseAddrPa: 0x", SeamrrPtCtx->PtBaseAddrPa);
; 43   :     PRINT_HEX_VAL("SeamrrPtCtx->PtAllocatorPa: 0x", SeamrrPtCtx->PtAllocatorPa);
; 44   :     PRINT_HEX_VAL("SeamrrPtCtx->PagingStructSize: 0x", SeamrrPtCtx->PagingStructSize);
; 45   :     PRINT_HEX_VAL("SeamrrPtCtx->VPDelta: 0x", SeamrrPtCtx->VPDelta);
; 46   :     return SeamrrPtCtx;

  0003f	48 8b c1	 mov	 rax, rcx

; 47   : }

  00042	c3		 ret	 0
InitPseamldrPtCtx ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\commonseamldr64\seamrrpaging64.c
;	COMDAT MapPage
_TEXT	SEGMENT
SeamrrPtCtx$ = 24
LinearAddr$ = 32
PhysAddr$ = 40
Attr$ = 48
PageMappingSize$ = 56
IsKeyHoleMapping$ = 64
MapPage	PROC						; COMDAT

; 49   : UINT64* MapPage(SEAMRR_PT_CTX* SeamrrPtCtx, UINT64 LinearAddr, UINT64 PhysAddr, UINT64 Attr, PAGE_SIZE PageMappingSize, BOOL IsKeyHoleMapping) {

$LN17:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000f	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  00013	41 56		 push	 r14
  00015	41 57		 push	 r15

; 50   :     UINT32 PtIdx, Idx;
; 51   :     UINT64 *PxeLinear;
; 52   :     UINT64 *PxePhysical = NULL;
; 53   :     UINT64 CurNumPageLevels = SeamrrPtCtx->NumPageLevels;

  00017	48 8b 41 18	 mov	 rax, QWORD PTR [rcx+24]
  0001b	45 33 db	 xor	 r11d, r11d

; 54   :     UINT32 PtShiftBits = 12;
; 55   : 
; 56   :     if (PageMappingSize == PAGE_2M) {

  0001e	83 7c 24 38 01	 cmp	 DWORD PTR PageMappingSize$[rsp], 1
  00023	49 8b f9	 mov	 rdi, r9
  00026	49 8b f0	 mov	 rsi, r8
  00029	48 8b da	 mov	 rbx, rdx
  0002c	4c 8b d1	 mov	 r10, rcx
  0002f	45 8d 73 0c	 lea	 r14d, QWORD PTR [r11+12]
  00033	75 0c		 jne	 SHORT $LN5@MapPage

; 57   :         CurNumPageLevels--;

  00035	48 ff c8	 dec	 rax

; 58   :         PtShiftBits = 21;

  00038	45 8d 73 15	 lea	 r14d, QWORD PTR [r11+21]

; 59   :         Attr |= IA32_PG_PS;

  0003c	48 0f ba ef 07	 bts	 rdi, 7
$LN5@MapPage:

; 60   :     }
; 61   : 
; 62   : //    PRINT_HEX_VAL("Mapping PA ", PhysAddr);
; 63   : //    PRINT_HEX_VAL("To LA ", LinearAddr);
; 64   :     PxeLinear = (UINT64 *)SeamrrPtCtx->PtBaseAddrLa;

  00041	4c 8b 01	 mov	 r8, QWORD PTR [rcx]

; 65   :     // walk and fill if needed non leaf levels
; 66   :     for (Idx = 0; Idx < CurNumPageLevels - 1; Idx++) {

  00044	4c 8d 78 ff	 lea	 r15, QWORD PTR [rax-1]
  00048	45 33 c9	 xor	 r9d, r9d
  0004b	4d 85 ff	 test	 r15, r15
  0004e	0f 84 c2 00 00
	00		 je	 $LN15@MapPage
$LL4@MapPage:

; 67   :         PtIdx = (LinearAddr >> ((SeamrrPtCtx->NumPageLevels - 1) * 9 - Idx * 9 + 12)) & 0x1ff;

  00054	41 8a 52 18	 mov	 dl, BYTE PTR [r10+24]
  00058	43 8d 0c c9	 lea	 ecx, DWORD PTR [r9+r9*8]
  0005c	80 c2 ff	 add	 dl, 255			; 000000ffH
  0005f	8a c2		 mov	 al, dl
  00061	c0 e0 03	 shl	 al, 3
  00064	02 d0		 add	 dl, al
  00066	2a d1		 sub	 dl, cl
  00068	8d 4a 0c	 lea	 ecx, DWORD PTR [rdx+12]
  0006b	48 8b d3	 mov	 rdx, rbx
  0006e	48 d3 ea	 shr	 rdx, cl
  00071	81 e2 ff 01 00
	00		 and	 edx, 511		; 000001ffH

; 68   :         // check if PT exists
; 69   :         if (PxeLinear[PtIdx] == 0) {

  00077	8b ea		 mov	 ebp, edx
  00079	49 83 3c d0 00	 cmp	 QWORD PTR [r8+rdx*8], 0
  0007e	75 6e		 jne	 SHORT $LN6@MapPage

; 70   :             // if the allocator reached the data region - error
; 71   :             if (SeamrrPtCtx->PtAllocatorPa >= SeamldrData.SeamrrBase + SeamldrData.SeamrrSize -

  00080	48 8b 05 88 01
	00 00		 mov	 rax, QWORD PTR SeamldrData+392
  00087	48 8b 0d 40 00
	00 00		 mov	 rcx, QWORD PTR SeamldrData+64
  0008e	49 8b 52 10	 mov	 rdx, QWORD PTR [r10+16]
  00092	48 2b 48 10	 sub	 rcx, QWORD PTR [rax+16]
  00096	48 2b 48 08	 sub	 rcx, QWORD PTR [rax+8]
  0009a	48 2b 08	 sub	 rcx, QWORD PTR [rax]
  0009d	48 8b 05 38 00
	00 00		 mov	 rax, QWORD PTR SeamldrData+56
  000a4	48 05 00 e0 ff
	ff		 add	 rax, -8192		; ffffffffffffe000H
  000aa	48 03 c8	 add	 rcx, rax
  000ad	48 3b d1	 cmp	 rdx, rcx
  000b0	0f 83 8f 00 00
	00		 jae	 $LN11@MapPage

; 75   :             }
; 76   :             PxeLinear[PtIdx] = SeamrrPtCtx->PtAllocatorPa | IA32_PG_P | IA32_PG_RW | IA32_PG_A | IA32_PG_U;

  000b6	48 83 ca 27	 or	 rdx, 39			; 00000027H

; 77   :             // non leaf PDE mapping keyhole pages
; 78   :             if (IsKeyHoleMapping && (2 == SeamrrPtCtx->NumPageLevels - Idx)) {

  000ba	80 7c 24 40 00	 cmp	 BYTE PTR IsKeyHoleMapping$[rsp], 0
  000bf	49 89 14 e8	 mov	 QWORD PTR [r8+rbp*8], rdx
  000c3	74 21		 je	 SHORT $LN8@MapPage
  000c5	49 8b 4a 18	 mov	 rcx, QWORD PTR [r10+24]
  000c9	41 8b c1	 mov	 eax, r9d
  000cc	48 2b c8	 sub	 rcx, rax
  000cf	48 83 f9 02	 cmp	 rcx, 2
  000d3	75 11		 jne	 SHORT $LN8@MapPage

; 79   :                 PxeLinear[PtIdx] |= IA32_PG_NX;

  000d5	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  000df	48 0b d0	 or	 rdx, rax
  000e2	49 89 14 e8	 mov	 QWORD PTR [r8+rbp*8], rdx
$LN8@MapPage:

; 80   :             }
; 81   :             SeamrrPtCtx->PtAllocatorPa += SEAMRR_PAGE_SIZE;

  000e6	49 81 42 10 00
	10 00 00	 add	 QWORD PTR [r10+16], 4096 ; 00001000H
$LN6@MapPage:

; 82   :         }
; 83   :         
; 84   :         PxePhysical = (UINT64 *)(PxeLinear[PtIdx] & SeamldrData.PhysAddrMask & (~(SEAMRR_PAGE_SIZE - 1)));

  000ee	4c 8b 1d 18 00
	00 00		 mov	 r11, QWORD PTR SeamldrData+24
  000f5	41 ff c1	 inc	 r9d
  000f8	4d 23 1c e8	 and	 r11, QWORD PTR [r8+rbp*8]

; 85   :         PxeLinear = (UINT64 *)((INT64)PxePhysical + SeamrrPtCtx->VPDelta);        // read pxe from virtual address

  000fc	4d 8b 42 20	 mov	 r8, QWORD PTR [r10+32]
  00100	49 81 e3 00 f0
	ff ff		 and	 r11, -4096		; fffffffffffff000H
  00107	4d 03 c3	 add	 r8, r11
  0010a	41 8b c1	 mov	 eax, r9d
  0010d	49 3b c7	 cmp	 rax, r15
  00110	0f 82 3e ff ff
	ff		 jb	 $LL4@MapPage
$LN15@MapPage:

; 86   :     }
; 87   :     // map leaf level
; 88   :     PtIdx = (LinearAddr >> PtShiftBits) & 0x1ff;
; 89   :     PxeLinear[PtIdx] = PhysAddr | Attr;

  00116	48 0b f7	 or	 rsi, rdi
  00119	41 8b ce	 mov	 ecx, r14d
  0011c	48 d3 eb	 shr	 rbx, cl

; 90   :     // return PT used for mapping
; 91   :     return PxePhysical;

  0011f	49 8b c3	 mov	 rax, r11
  00122	81 e3 ff 01 00
	00		 and	 ebx, 511		; 000001ffH
  00128	49 89 34 d8	 mov	 QWORD PTR [r8+rbx*8], rsi
$LN1@MapPage:

; 92   : }

  0012c	48 8b 5c 24 18	 mov	 rbx, QWORD PTR [rsp+24]
  00131	48 8b 6c 24 20	 mov	 rbp, QWORD PTR [rsp+32]
  00136	48 8b 74 24 28	 mov	 rsi, QWORD PTR [rsp+40]
  0013b	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
  00140	41 5f		 pop	 r15
  00142	41 5e		 pop	 r14
  00144	c3		 ret	 0
$LN11@MapPage:

; 72   :                 (C_P_SYS_INFO_TABLE_SIZE + SeamldrData.PSeamldrConsts->CCodeRgnSize + SeamldrData.PSeamldrConsts->CDataStackSize + P_SEAMLDR_SHADOW_STACK_SIZE + 
; 73   :                     SeamldrData.PSeamldrConsts->CDataRgnSize)) {
; 74   :                 return NULL;

  00145	33 c0		 xor	 eax, eax
  00147	eb e3		 jmp	 SHORT $LN1@MapPage
MapPage	ENDP
_TEXT	ENDS
END

; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24245.0 

	TITLE	D:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\Core\Common\CopyDataX.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_copyMemory
PUBLIC	_copyDataChkBoundsWithFunc
PUBLIC	??_C@_0DL@HBBLPBDE@Safe?5copy?5operation?3?5Stack?5targe@IMHBAIGO@ ;  ?? ::IMHBAIGO::`string'
EXTRN	_Trace:PROC
EXTRN	___ErrorHandler:PROC
EXTRN	_perform_ebp_checks:PROC
EXTRN	_ErrCtx:BYTE
;	COMDAT ??_C@_0DL@HBBLPBDE@Safe?5copy?5operation?3?5Stack?5targe@IMHBAIGO@
EDATA32	SEGMENT
??_C@_0DL@HBBLPBDE@Safe?5copy?5operation?3?5Stack?5targe@IMHBAIGO@ DB 'Sa'
	DB	'fe copy operation: Stack target, stack frame error -%c.', 0aH
	DB	00H						;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\common\copydatax.c
;	COMDAT _coreCopyMemory
_TEXT	SEGMENT
_to$ = 8						; size = 4
_fr$ = 12						; size = 4
_len$ = 16						; size = 4
_coreCopyMemory PROC					; COMDAT

; 35   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 55 10	 mov	 edx, DWORD PTR _len$[ebp]
  00006	56		 push	 esi

; 36   :   char *d = to;

  00007	8b 75 08	 mov	 esi, DWORD PTR _to$[ebp]
  0000a	57		 push	 edi

; 37   :   char *s = (char *) fr;

  0000b	8b 7d 0c	 mov	 edi, DWORD PTR _fr$[ebp]
  0000e	83 fa 04	 cmp	 edx, 4

; 38   : 
; 39   :   while (len / 4) {

  00011	72 17		 jb	 SHORT $LN8@coreCopyMe

; 36   :   char *d = to;

  00013	8b ca		 mov	 ecx, edx
  00015	c1 e9 02	 shr	 ecx, 2
$LL2@coreCopyMe:

; 40   :     *(UINT32 *) d = *(UINT32 *) s;

  00018	8b 07		 mov	 eax, DWORD PTR [edi]

; 41   :     d += 4;
; 42   :     s += 4;
; 43   :     len -= 4;

  0001a	83 ea 04	 sub	 edx, 4
  0001d	89 06		 mov	 DWORD PTR [esi], eax
  0001f	83 c7 04	 add	 edi, 4
  00022	83 c6 04	 add	 esi, 4
  00025	83 e9 01	 sub	 ecx, 1
  00028	75 ee		 jne	 SHORT $LL2@coreCopyMe
$LN8@coreCopyMe:

; 44   :   }
; 45   : 
; 46   :   while (len--) {

  0002a	85 d2		 test	 edx, edx
  0002c	74 0d		 je	 SHORT $LN10@coreCopyMe
  0002e	2b fe		 sub	 edi, esi
$LL4@coreCopyMe:

; 47   :     *d++ = *s++;

  00030	8a 0c 37	 mov	 cl, BYTE PTR [edi+esi]
  00033	88 0e		 mov	 BYTE PTR [esi], cl
  00035	46		 inc	 esi
  00036	83 ea 01	 sub	 edx, 1
  00039	75 f5		 jne	 SHORT $LL4@coreCopyMe
$LN10@coreCopyMe:

; 48   :   }
; 49   :   return to;

  0003b	8b 45 08	 mov	 eax, DWORD PTR _to$[ebp]
  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi

; 50   : }

  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
_coreCopyMemory ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\common\copydatax.c
;	COMDAT _copyDataChkBoundsWithFunc
_TEXT	SEGMENT
__to$ = 8						; size = 4
__fr$ = 12						; size = 4
_len$ = 16						; size = 4
_maxBound$ = 20						; size = 4
_kind$ = 24						; size = 4
_pFunc$ = 28						; size = 4
_copyDataChkBoundsWithFunc PROC				; COMDAT

; 117  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 118  :   UINT32 maxlen;
; 119  :   UINT8 *to = (UINT8 *)_to;
; 120  :   UINT8 *fr = (UINT8 *)_fr;
; 121  : 
; 122  :   if (kind == MAX_ADDR_BOUND) {

  00003	83 7d 18 ff	 cmp	 DWORD PTR _kind$[ebp], -1
  00007	56		 push	 esi
  00008	8b 75 10	 mov	 esi, DWORD PTR _len$[ebp]
  0000b	75 12		 jne	 SHORT $LN2@copyDataCh

; 123  :     //
; 124  :     // Destination must be less then bound address
; 125  :     //
; 126  :     if ((UINT32) to > maxBound) {

  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __to$[ebp]
  00010	8b 45 14	 mov	 eax, DWORD PTR _maxBound$[ebp]
  00013	3b c8		 cmp	 ecx, eax
  00015	76 04		 jbe	 SHORT $LN4@copyDataCh
$LN14@copyDataCh:

; 127  :       return 0;

  00017	33 c0		 xor	 eax, eax
  00019	eb 44		 jmp	 SHORT $LN1@copyDataCh
$LN4@copyDataCh:

; 128  :     }
; 129  :     //
; 130  :     // maximum len to copy is difference between max address and
; 131  :     // destination.
; 132  :     //
; 133  :     maxlen = maxBound - (UINT32) to;

  0001b	2b c1		 sub	 eax, ecx

; 134  :   } else {

  0001d	eb 0c		 jmp	 SHORT $LN3@copyDataCh
$LN2@copyDataCh:

; 135  :     if (len > maxBound) {

  0001f	3b 75 14	 cmp	 esi, DWORD PTR _maxBound$[ebp]
  00022	77 f3		 ja	 SHORT $LN14@copyDataCh

; 136  :       return 0;
; 137  :     }
; 138  :     //
; 139  :     // If len is set as bound, we cannot wrap around.
; 140  :     //
; 141  :     maxlen = 0xFFFFFFFF - (UINT32) to;

  00024	8b 4d 08	 mov	 ecx, DWORD PTR __to$[ebp]
  00027	8b c1		 mov	 eax, ecx
  00029	f7 d0		 not	 eax
$LN3@copyDataCh:

; 142  :   }
; 143  : 
; 144  :   //
; 145  :   // abort if over length.
; 146  :   //
; 147  :   if (len > maxlen) {

  0002b	3b f0		 cmp	 esi, eax
  0002d	77 e8		 ja	 SHORT $LN14@copyDataCh

; 148  :     return 0;
; 149  :   }
; 150  : 
; 151  :   //
; 152  :   // cannot wrap around from pointer too.
; 153  :   //
; 154  :   maxlen = 0xFFFFFFFF - (UINT32) fr;

  0002f	8b 55 0c	 mov	 edx, DWORD PTR __fr$[ebp]
  00032	8b c2		 mov	 eax, edx
  00034	f7 d0		 not	 eax

; 155  : 
; 156  :   if (len > maxlen) {

  00036	3b f0		 cmp	 esi, eax
  00038	77 dd		 ja	 SHORT $LN14@copyDataCh

; 157  :     return 0;
; 158  :   }
; 159  : 
; 160  :   //
; 161  :   // Cannot overlap to and fr buffers.
; 162  :   //
; 163  :   if (((fr < to) && ((fr + len) > to)) ||
; 164  :       ((to < fr) && ((to + len) > fr)) ||

  0003a	3b ca		 cmp	 ecx, edx
  0003c	76 09		 jbe	 SHORT $LN13@copyDataCh
  0003e	8d 04 32	 lea	 eax, DWORD PTR [edx+esi]
  00041	3b c1		 cmp	 eax, ecx
  00043	77 d2		 ja	 SHORT $LN14@copyDataCh
  00045	3b ca		 cmp	 ecx, edx
$LN13@copyDataCh:
  00047	73 07		 jae	 SHORT $LN11@copyDataCh
  00049	8d 04 31	 lea	 eax, DWORD PTR [ecx+esi]
  0004c	3b c2		 cmp	 eax, edx
  0004e	77 c7		 ja	 SHORT $LN14@copyDataCh
$LN11@copyDataCh:
  00050	3b d1		 cmp	 edx, ecx
  00052	74 c3		 je	 SHORT $LN14@copyDataCh

; 165  :       (fr == to)) {
; 166  :     // if (((fr + len) > to) || ((to + len) > fr))
; 167  :     return 0;
; 168  :   }
; 169  : 
; 170  :   (*pFunc)(to, fr, len);

  00054	56		 push	 esi
  00055	52		 push	 edx
  00056	51		 push	 ecx
  00057	ff 55 1c	 call	 DWORD PTR _pFunc$[ebp]
  0005a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 171  :   return len;

  0005d	8b c6		 mov	 eax, esi
$LN1@copyDataCh:
  0005f	5e		 pop	 esi

; 172  : }

  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
_copyDataChkBoundsWithFunc ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\common\copydatax.c
;	COMDAT _copyMemory
_TEXT	SEGMENT
_to$ = 8						; size = 4
_fr$ = 12						; size = 4
_len$ = 16						; size = 4
_copyMemory PROC					; COMDAT

; 69   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 70   :   INT32 Ret;
; 71   : 
; 72   :   Ret = HOOK(perform_ebp_checks((UINT32)to, (UINT32)len));

  00004	ff 75 10	 push	 DWORD PTR _len$[ebp]
  00007	ff 75 08	 push	 DWORD PTR _to$[ebp]
  0000a	e8 00 00 00 00	 call	 _perform_ebp_checks
  0000f	59		 pop	 ecx
  00010	59		 pop	 ecx
  00011	8b f0		 mov	 esi, eax

; 73   : 
; 74   :   switch (Ret) {

  00013	8b ce		 mov	 ecx, esi
  00015	83 e9 00	 sub	 ecx, 0
  00018	74 26		 je	 SHORT $LN5@copyMemory
  0001a	83 e9 01	 sub	 ecx, 1
  0001d	74 21		 je	 SHORT $LN5@copyMemory

; 75   :   case  STACK_TARGET:
; 76   :     break;
; 77   :   case  NOT_STACK_TARGET:
; 78   :     break;
; 79   :   default:
; 80   :     TRACE("Safe copy operation: Stack target, stack frame error -%c.\n", MAX_DWORD - Ret + 1);

  0001f	8b ce		 mov	 ecx, esi
  00021	f7 d9		 neg	 ecx
  00023	51		 push	 ecx
  00024	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@HBBLPBDE@Safe?5copy?5operation?3?5Stack?5targe@IMHBAIGO@
  00029	e8 00 00 00 00	 call	 _Trace

; 81   :     ERROR_HANDLER_FULL(CLASS_MISC_CONFIG, ERR_STACK_FRAME, Ret);

  0002e	6a 0b		 push	 11			; 0000000bH
  00030	6a 08		 push	 8
  00032	89 35 08 00 00
	00		 mov	 DWORD PTR _ErrCtx+8, esi
  00038	e8 00 00 00 00	 call	 ___ErrorHandler
  0003d	83 c4 10	 add	 esp, 16			; 00000010H
$LN5@copyMemory:
  00040	5e		 pop	 esi

; 85   : }

  00041	5d		 pop	 ebp

; 82   :   }
; 83   : 
; 84   :   return coreCopyMemory(to, fr, len);

  00042	e9 00 00 00 00	 jmp	 _coreCopyMemory
_copyMemory ENDP
_TEXT	ENDS
END

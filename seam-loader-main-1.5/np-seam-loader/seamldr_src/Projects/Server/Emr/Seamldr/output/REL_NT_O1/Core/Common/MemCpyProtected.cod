; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24245.0 

	TITLE	D:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\Core\Common\MemCpyProtected.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_get_esp
PUBLIC	_perform_ebp_checks
EXTRN	_CodeSegmentStart:DWORD
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\common\memcpyprotected.c
;	COMDAT _is_addr_in_stack
_TEXT	SEGMENT
_addr$ = 8						; size = 4
_is_addr_in_stack PROC					; COMDAT

; 106  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 107  :   if ((addr < get_stack_base()) && (addr >= get_esp())) {

  00003	e8 00 00 00 00	 call	 _get_stack_base
  00008	39 45 08	 cmp	 DWORD PTR _addr$[ebp], eax
  0000b	73 0f		 jae	 SHORT $LN2@is_addr_in
  0000d	e8 00 00 00 00	 call	 _get_esp
  00012	39 45 08	 cmp	 DWORD PTR _addr$[ebp], eax
  00015	72 05		 jb	 SHORT $LN2@is_addr_in

; 108  :     return IN_STACK;

  00017	33 c0		 xor	 eax, eax
  00019	40		 inc	 eax

; 111  :   }
; 112  : }

  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
$LN2@is_addr_in:

; 109  :   } else {
; 110  :     return OUT_OF_STACK;

  0001c	83 c8 ff	 or	 eax, -1

; 111  :   }
; 112  : }

  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
_is_addr_in_stack ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\common\memcpyprotected.c
;	COMDAT _get_previous_ebp
_TEXT	SEGMENT
_ebp$ = 8						; size = 4
_get_previous_ebp PROC					; COMDAT

; 89   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 90   :   return *((UINT32 *)ebp);

  00003	8b 45 08	 mov	 eax, DWORD PTR _ebp$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]

; 91   : }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
_get_previous_ebp ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\common\memcpyprotected.c
;	COMDAT _get_ebp
_TEXT	SEGMENT
_get_ebp PROC						; COMDAT

; 70   :   __asm {
; 71   :     mov eax, ebp

  00000	8b c5		 mov	 eax, ebp

; 72   :         ret

  00002	c3		 ret	 0
_get_ebp ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\common\memcpyprotected.c
;	COMDAT _get_stack_base
_TEXT	SEGMENT
_get_stack_base PROC					; COMDAT

; 33   :   return CodeSegmentStart - MCP_STACK_GAP;

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _CodeSegmentStart
  00005	83 c0 f0	 add	 eax, -16		; fffffff0H

; 34   : }

  00008	c3		 ret	 0
_get_stack_base ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\common\memcpyprotected.c
;	COMDAT _perform_ebp_checks
_TEXT	SEGMENT
_dest$ = 8						; size = 4
_size$ = 12						; size = 4
_perform_ebp_checks PROC				; COMDAT

; 128  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 129  :   UINT32 ebp, previous_ebp;
; 130  : 
; 131  :   if (is_addr_in_stack(dest) == OUT_OF_STACK) {

  00004	8b 75 08	 mov	 esi, DWORD PTR _dest$[ebp]
  00007	56		 push	 esi
  00008	e8 00 00 00 00	 call	 _is_addr_in_stack
  0000d	59		 pop	 ecx
  0000e	83 f8 ff	 cmp	 eax, -1
  00011	75 04		 jne	 SHORT $LN4@perform_eb

; 132  :     return NOT_STACK_TARGET;

  00013	33 c0		 xor	 eax, eax
  00015	eb 40		 jmp	 SHORT $LN1@perform_eb
$LN4@perform_eb:
  00017	57		 push	 edi

; 133  :   }
; 134  : 
; 135  :   ebp = get_ebp();

  00018	e8 00 00 00 00	 call	 _get_ebp
  0001d	8b f8		 mov	 edi, eax

; 136  :   if (is_addr_in_stack(ebp) == OUT_OF_STACK) {

  0001f	57		 push	 edi
  00020	e8 00 00 00 00	 call	 _is_addr_in_stack
  00025	59		 pop	 ecx
  00026	83 f8 ff	 cmp	 eax, -1
  00029	75 04		 jne	 SHORT $LN13@perform_eb

; 137  :     return ERR(1);

  0002b	0b c0		 or	 eax, eax
  0002d	eb 27		 jmp	 SHORT $LN19@perform_eb
$LN13@perform_eb:
  0002f	53		 push	 ebx

; 138  :   }
; 139  : 
; 140  :   while (1) {
; 141  :     previous_ebp = get_previous_ebp(ebp);

  00030	57		 push	 edi

; 142  : 
; 143  :     //
; 144  :     // This is break of infinite loop.
; 145  :     // If the following check does not bring IN_STACK indicator, we either reached top of stack or stack is corrupted.
; 146  :     //
; 147  :     if (is_addr_in_stack(previous_ebp) != IN_STACK) {

  00031	eb 0b		 jmp	 SHORT $LN22@perform_eb
$LL2@perform_eb:

; 149  :     }
; 150  : 
; 151  :     if ((dest >= ebp) && (dest < previous_ebp)) {

  00033	3b f7		 cmp	 esi, edi
  00035	72 04		 jb	 SHORT $LN7@perform_eb
  00037	3b f3		 cmp	 esi, ebx
  00039	72 1f		 jb	 SHORT $LN15@perform_eb
$LN7@perform_eb:

; 152  :       break; // Found EBPs around dest
; 153  :     }
; 154  : 
; 155  :     ebp = previous_ebp;

  0003b	8b fb		 mov	 edi, ebx
  0003d	53		 push	 ebx
$LN22@perform_eb:

; 138  :   }
; 139  : 
; 140  :   while (1) {
; 141  :     previous_ebp = get_previous_ebp(ebp);

  0003e	e8 00 00 00 00	 call	 _get_previous_ebp
  00043	8b d8		 mov	 ebx, eax

; 142  : 
; 143  :     //
; 144  :     // This is break of infinite loop.
; 145  :     // If the following check does not bring IN_STACK indicator, we either reached top of stack or stack is corrupted.
; 146  :     //
; 147  :     if (is_addr_in_stack(previous_ebp) != IN_STACK) {

  00045	53		 push	 ebx
  00046	e8 00 00 00 00	 call	 _is_addr_in_stack
  0004b	59		 pop	 ecx
  0004c	59		 pop	 ecx
  0004d	83 f8 01	 cmp	 eax, 1
  00050	74 e1		 je	 SHORT $LL2@perform_eb

; 148  :       return ERR(2);

  00052	6a fe		 push	 -2			; fffffffeH
$LN23@perform_eb:
  00054	58		 pop	 eax
$LN20@perform_eb:
  00055	5b		 pop	 ebx
$LN19@perform_eb:
  00056	5f		 pop	 edi
$LN1@perform_eb:
  00057	5e		 pop	 esi

; 182  : }

  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
$LN15@perform_eb:

; 156  :   }
; 157  : 
; 158  :   //
; 159  :   // Changed aproach to break when stack reaches base. For testing environment this might cause infinite loop
; 160  :   // but we do not have broken EBP chaine in this test environment.
; 161  :   //
; 162  : 
; 163  :   //
; 164  :   // Check for integer overflow before expressions are used in stack corruption detection
; 165  :   //
; 166  :   if ((ebp + sizeof(STACK_METADATA)) <= ebp) {

  0005a	8d 4f 08	 lea	 ecx, DWORD PTR [edi+8]
  0005d	3b cf		 cmp	 ecx, edi
  0005f	77 04		 ja	 SHORT $LN8@perform_eb

; 167  :     return ERR(3); // Integer overflow detected

  00061	6a fd		 push	 -3			; fffffffdH
  00063	eb ef		 jmp	 SHORT $LN23@perform_eb
$LN8@perform_eb:

; 168  :   }
; 169  : 
; 170  :   if ((dest + size) < dest) {

  00065	8b 45 0c	 mov	 eax, DWORD PTR _size$[ebp]
  00068	03 c6		 add	 eax, esi
  0006a	3b c6		 cmp	 eax, esi
  0006c	73 04		 jae	 SHORT $LN9@perform_eb

; 171  :     return ERR(4); // Integer overflow detected

  0006e	6a fc		 push	 -4			; fffffffcH
  00070	eb e2		 jmp	 SHORT $LN23@perform_eb
$LN9@perform_eb:

; 172  :   }
; 173  : 
; 174  :   //
; 175  :   // Stack corruption detection
; 176  :   //
; 177  :   if ((dest >= (ebp + sizeof(STACK_METADATA))) && ((dest + size) <= previous_ebp)) {

  00072	3b f1		 cmp	 esi, ecx
  00074	72 09		 jb	 SHORT $LN10@perform_eb
  00076	3b c3		 cmp	 eax, ebx
  00078	77 05		 ja	 SHORT $LN10@perform_eb

; 178  :     return STACK_TARGET; // Copy is safe

  0007a	33 c0		 xor	 eax, eax
  0007c	40		 inc	 eax
  0007d	eb d6		 jmp	 SHORT $LN20@perform_eb
$LN10@perform_eb:

; 179  :   }
; 180  : 
; 181  :   return ERR(5);

  0007f	6a fb		 push	 -5			; fffffffbH
  00081	eb d1		 jmp	 SHORT $LN23@perform_eb
_perform_ebp_checks ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\common\memcpyprotected.c
;	COMDAT _get_esp
_TEXT	SEGMENT
_get_esp PROC						; COMDAT

; 50   :   __asm {
; 51   :     mov eax, esp

  00000	8b c4		 mov	 eax, esp

; 52   :         ret

  00002	c3		 ret	 0
_get_esp ENDP
_TEXT	ENDS
END

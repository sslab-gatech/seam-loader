; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24245.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	BitScanForward64
PUBLIC	BitScanReverse64
PUBLIC	BitScanForward64AndReset
PUBLIC	BitScanReverse64AndReset
PUBLIC	BitScanForwardAndReset
PUBLIC	BitScanReverseAndReset
;	COMDAT pdata
pdata	SEGMENT
$pdata$BitScanForward64AndReset DD imagerel $LN7
	DD	imagerel $LN7+54
	DD	imagerel $unwind$BitScanForward64AndReset
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$BitScanReverse64AndReset DD imagerel $LN7
	DD	imagerel $LN7+54
	DD	imagerel $unwind$BitScanReverse64AndReset
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$BitScanReverse64AndReset DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$BitScanForward64AndReset DD 020601H
	DD	030023206H
xdata	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\accessors64\bitscan64.c
;	COMDAT BitScanReverseAndReset
_TEXT	SEGMENT
pIndex$ = 8
pVal$ = 16
BitScanReverseAndReset PROC				; COMDAT

; 198  : 
; 199  :   if (0== _BitScanReverse (pIndex, *pVal))

  00000	0f bd 02	 bsr	 eax, DWORD PTR [rdx]
  00003	89 01		 mov	 DWORD PTR [rcx], eax
  00005	75 03		 jne	 SHORT $LN2@BitScanRev

; 200  : 	  return 0;

  00007	33 c0		 xor	 eax, eax

; 203  : }

  00009	c3		 ret	 0
$LN2@BitScanRev:

; 201  :   _bittestandreset (pVal, *pIndex);

  0000a	0f b3 02	 btr	 DWORD PTR [rdx], eax

; 202  :   return 1;

  0000d	b8 01 00 00 00	 mov	 eax, 1

; 203  : }

  00012	c3		 ret	 0
BitScanReverseAndReset ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\accessors64\bitscan64.c
;	COMDAT BitScanForwardAndReset
_TEXT	SEGMENT
pIndex$ = 8
pVal$ = 16
BitScanForwardAndReset PROC				; COMDAT

; 173  : 
; 174  :   if (0 == _BitScanForward (pIndex, *pVal))

  00000	0f bc 02	 bsf	 eax, DWORD PTR [rdx]
  00003	89 01		 mov	 DWORD PTR [rcx], eax
  00005	75 03		 jne	 SHORT $LN2@BitScanFor

; 175  : 	  return 0;

  00007	33 c0		 xor	 eax, eax

; 178  : }

  00009	c3		 ret	 0
$LN2@BitScanFor:

; 176  :   _bittestandreset (pVal, *pIndex);

  0000a	0f b3 02	 btr	 DWORD PTR [rdx], eax

; 177  :   return 1;

  0000d	b8 01 00 00 00	 mov	 eax, 1

; 178  : }

  00012	c3		 ret	 0
BitScanForwardAndReset ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\accessors64\bitscan64.c
;	COMDAT BitScanReverse64AndReset
_TEXT	SEGMENT
pIndex$ = 48
pVal$ = 56
BitScanReverse64AndReset PROC				; COMDAT

; 135  : {

$LN7:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 136  : 
; 137  :   UINT32 *pHighVal;
; 138  : 
; 139  :   if (*pVal == 0)

  00006	48 83 3a 00	 cmp	 QWORD PTR [rdx], 0
  0000a	48 8b d9	 mov	 rbx, rcx
  0000d	75 04		 jne	 SHORT $LN2@BitScanRev

; 140  :     return 0;

  0000f	33 c0		 xor	 eax, eax
  00011	eb 1d		 jmp	 SHORT $LN1@BitScanRev
$LN2@BitScanRev:

; 141  : 
; 142  :   if ((UINT32) (*pVal & 0xFFFFFFFF) != 0) {

  00013	83 3a 00	 cmp	 DWORD PTR [rdx], 0
  00016	74 07		 je	 SHORT $LN3@BitScanRev

; 143  :     BitScanReverseAndReset (pIndex,(UINT32 *) pVal);

  00018	e8 00 00 00 00	 call	 BitScanReverseAndReset

; 144  :   } else {

  0001d	eb 0c		 jmp	 SHORT $LN4@BitScanRev
$LN3@BitScanRev:

; 145  :     pHighVal = (UINT32 *)pVal + 1;

  0001f	48 83 c2 04	 add	 rdx, 4

; 146  : 
; 147  :     BitScanReverseAndReset (pIndex, pHighVal);

  00023	e8 00 00 00 00	 call	 BitScanReverseAndReset

; 148  : 
; 149  :     *pIndex += 32;

  00028	83 03 20	 add	 DWORD PTR [rbx], 32	; 00000020H
$LN4@BitScanRev:

; 150  :   }
; 151  :   return 1;

  0002b	b8 01 00 00 00	 mov	 eax, 1
$LN1@BitScanRev:

; 152  : }

  00030	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00034	5b		 pop	 rbx
  00035	c3		 ret	 0
BitScanReverse64AndReset ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\accessors64\bitscan64.c
;	COMDAT BitScanForward64AndReset
_TEXT	SEGMENT
pIndex$ = 48
pVal$ = 56
BitScanForward64AndReset PROC				; COMDAT

; 67   : {

$LN7:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 68   : 
; 69   :   UINT32 *pHighVal;
; 70   : 
; 71   :   if (*pVal == 0)

  00006	48 83 3a 00	 cmp	 QWORD PTR [rdx], 0
  0000a	48 8b d9	 mov	 rbx, rcx
  0000d	75 04		 jne	 SHORT $LN2@BitScanFor

; 72   :     return 0;

  0000f	33 c0		 xor	 eax, eax
  00011	eb 1d		 jmp	 SHORT $LN1@BitScanFor
$LN2@BitScanFor:

; 73   : 
; 74   :   if ((UINT32) (*pVal & 0xFFFFFFFF) != 0) {

  00013	83 3a 00	 cmp	 DWORD PTR [rdx], 0
  00016	74 07		 je	 SHORT $LN3@BitScanFor

; 75   :     BitScanForwardAndReset (pIndex,(UINT32 *) pVal);

  00018	e8 00 00 00 00	 call	 BitScanForwardAndReset

; 76   :   } else {

  0001d	eb 0c		 jmp	 SHORT $LN4@BitScanFor
$LN3@BitScanFor:

; 77   :     pHighVal = (UINT32 *)pVal + 1;

  0001f	48 83 c2 04	 add	 rdx, 4

; 78   : 
; 79   :     BitScanForwardAndReset (pIndex, pHighVal);

  00023	e8 00 00 00 00	 call	 BitScanForwardAndReset

; 80   : 
; 81   :     *pIndex += 32;

  00028	83 03 20	 add	 DWORD PTR [rbx], 32	; 00000020H
$LN4@BitScanFor:

; 82   :   }
; 83   :   return 1;

  0002b	b8 01 00 00 00	 mov	 eax, 1
$LN1@BitScanFor:

; 84   : }

  00030	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00034	5b		 pop	 rbx
  00035	c3		 ret	 0
BitScanForward64AndReset ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\accessors64\bitscan64.c
;	COMDAT BitScanReverse64
_TEXT	SEGMENT
index$ = 8
val$ = 16
BitScanReverse64 PROC					; COMDAT

; 104  :   UINT32 Reg;
; 105  : 
; 106  :   if (val == 0)

  00000	48 85 d2	 test	 rdx, rdx
  00003	75 03		 jne	 SHORT $LN2@BitScanRev

; 107  :     return 0;

  00005	33 c0		 xor	 eax, eax

; 116  : }

  00007	c3		 ret	 0
$LN2@BitScanRev:

; 108  : 
; 109  :   if ((Reg = highdword(val)) != 0) {

  00008	48 8b c2	 mov	 rax, rdx
  0000b	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  0000f	85 c0		 test	 eax, eax
  00011	74 0a		 je	 SHORT $LN3@BitScanRev

; 110  :     _BitScanReverse (index, Reg);

  00013	0f bd c0	 bsr	 eax, eax
  00016	89 01		 mov	 DWORD PTR [rcx], eax

; 111  :     *index += 32;

  00018	83 01 20	 add	 DWORD PTR [rcx], 32	; 00000020H
  0001b	eb 09		 jmp	 SHORT $LN5@BitScanRev
$LN3@BitScanRev:

; 112  :   } else if ((UINT32) val != 0) {

  0001d	85 d2		 test	 edx, edx
  0001f	74 05		 je	 SHORT $LN5@BitScanRev

; 113  :     _BitScanReverse (index,(UINT32) val);

  00021	0f bd c2	 bsr	 eax, edx
  00024	89 01		 mov	 DWORD PTR [rcx], eax
$LN5@BitScanRev:

; 114  :   }
; 115  :   return 1;

  00026	b8 01 00 00 00	 mov	 eax, 1

; 116  : }

  0002b	c3		 ret	 0
BitScanReverse64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\accessors64\bitscan64.c
;	COMDAT BitScanForward64
_TEXT	SEGMENT
index$ = 8
val$ = 16
BitScanForward64 PROC					; COMDAT

; 36   :   UINT32 Reg;
; 37   : 
; 38   :   if (val == 0)

  00000	48 85 d2	 test	 rdx, rdx
  00003	75 03		 jne	 SHORT $LN2@BitScanFor

; 39   :     return 0;

  00005	33 c0		 xor	 eax, eax

; 48   : }

  00007	c3		 ret	 0
$LN2@BitScanFor:

; 40   : 
; 41   :   if ((UINT32) (val & 0xFFFFFFFF) != 0) {

  00008	85 d2		 test	 edx, edx
  0000a	74 07		 je	 SHORT $LN3@BitScanFor

; 42   :     _BitScanForward (index,(UINT32) val);

  0000c	0f bc c2	 bsf	 eax, edx
  0000f	89 01		 mov	 DWORD PTR [rcx], eax
  00011	eb 10		 jmp	 SHORT $LN5@BitScanFor
$LN3@BitScanFor:

; 43   :   } else if ((Reg = highdword(val)) != 0) {

  00013	48 c1 ea 20	 shr	 rdx, 32			; 00000020H
  00017	85 d2		 test	 edx, edx
  00019	74 08		 je	 SHORT $LN5@BitScanFor

; 44   :     _BitScanForward (index, Reg);

  0001b	0f bc c2	 bsf	 eax, edx
  0001e	89 01		 mov	 DWORD PTR [rcx], eax

; 45   :     *index += 32;

  00020	83 01 20	 add	 DWORD PTR [rcx], 32	; 00000020H
$LN5@BitScanFor:

; 46   :   }
; 47   :   return 1;

  00023	b8 01 00 00 00	 mov	 eax, 1

; 48   : }

  00028	c3		 ret	 0
BitScanForward64 ENDP
_TEXT	ENDS
END

; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24245.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	Target64
EXTRN	_ud2:PROC
EXTRN	PauseCpu:PROC
EXTRN	MapPhysicalRange:PROC
EXTRN	RemoveLinearMapping:PROC
EXTRN	__security_init_cookie:PROC
EXTRN	SeamldrAcm:PROC
EXTRN	GdtBasePtr:BYTE
EXTRN	TempGdt:BYTE
EDATA32	SEGMENT
STSRegister DB	01H DUP (?)
EDATA32	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CloseTPMLocality DD imagerel CloseTPMLocality
	DD	imagerel CloseTPMLocality+171
	DD	imagerel $unwind$CloseTPMLocality
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ReopenTPMLocality DD imagerel ReopenTPMLocality
	DD	imagerel ReopenTPMLocality+133
	DD	imagerel $unwind$ReopenTPMLocality
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$Target64 DD imagerel $LN5
	DD	imagerel $LN5+237
	DD	imagerel $unwind$Target64
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Target64 DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ReopenTPMLocality DD 040a01H
	DD	08340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CloseTPMLocality DD 040a01H
	DD	08340aH
	DD	07006520aH
xdata	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\projects\server\emr\seamldr\seamldr64.c
;	COMDAT Target64
_TEXT	SEGMENT
pCom64$ = 48
Target64 PROC						; COMDAT

; 96   : {

$LN5:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b d9	 mov	 rbx, rcx

; 97   :     UINT64 canonicity_mask = 0;
; 98   :     __security_init_cookie();

  0000d	e8 00 00 00 00	 call	 __security_init_cookie

; 99   :     pCom64->NewIDTR.Limit = pCom64->OriginalIDTRLimit;

  00012	0f b7 43 40	 movzx	 eax, WORD PTR [rbx+64]

; 100  :     pCom64->NewIDTR.Base = pCom64->OriginalR12;
; 101  :     *(UINT64 *)(pCom64->OriginalGdtr + 2) = pCom64->OriginalR9;
; 102  :     pCom64->ResumeRip   = pCom64->OriginalR10;
; 103  :     pCom64->OriginalCR3 = pCom64->OriginalR11;
; 104  : 
; 105  :     PT_CTX* PtCtx = (PT_CTX*)pCom64->PtCtxPtr;

  00016	48 8b 7b 5e	 mov	 rdi, QWORD PTR [rbx+94]
  0001a	66 89 43 42	 mov	 WORD PTR [rbx+66], ax

; 106  : 
; 107  :     CloseTPMLocality(PtCtx);

  0001e	48 8b cf	 mov	 rcx, rdi
  00021	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00025	48 89 43 44	 mov	 QWORD PTR [rbx+68], rax
  00029	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  0002d	48 89 43 4e	 mov	 QWORD PTR [rbx+78], rax
  00031	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  00035	48 89 43 56	 mov	 QWORD PTR [rbx+86], rax
  00039	48 8b 43 18	 mov	 rax, QWORD PTR [rbx+24]
  0003d	48 89 43 28	 mov	 QWORD PTR [rbx+40], rax
  00041	e8 00 00 00 00	 call	 CloseTPMLocality

; 108  :     canonicity_mask = ((pCom64->OriginalCR4 & CR4_LA57) != 0) ? CANONICITY_MASK_5LP : CANONICITY_MASK_4LP;

  00046	8b 43 30	 mov	 eax, DWORD PTR [rbx+48]
  00049	25 00 10 00 00	 and	 eax, 4096		; 00001000H
  0004e	f7 d8		 neg	 eax
  00050	48 b8 00 00 00
	00 00 80 00 ff	 mov	 rax, -71916856549572608	; ff00800000000000H
  0005a	48 1b d2	 sbb	 rdx, rdx
  0005d	48 23 d0	 and	 rdx, rax
  00060	48 b8 00 00 00
	00 00 80 ff ff	 mov	 rax, -140737488355328	; ffff800000000000H
  0006a	48 03 d0	 add	 rdx, rax

; 109  :     if (((pCom64->ResumeRip & canonicity_mask) != 0) && ((pCom64->ResumeRip & canonicity_mask) != canonicity_mask)) {

  0006d	48 8b c2	 mov	 rax, rdx
  00070	48 23 43 56	 and	 rax, QWORD PTR [rbx+86]
  00074	74 0a		 je	 SHORT $LN2@Target64
  00076	48 3b c2	 cmp	 rax, rdx
  00079	74 05		 je	 SHORT $LN2@Target64

; 110  :         _ud2();

  0007b	e8 00 00 00 00	 call	 _ud2
$LN2@Target64:

; 111  :     }
; 112  :         
; 113  :     SeamldrAcm(pCom64, PtCtx);

  00080	48 8b d7	 mov	 rdx, rdi
  00083	48 8b cb	 mov	 rcx, rbx
  00086	e8 00 00 00 00	 call	 SeamldrAcm

; 114  :     ReopenTPMLocality(PtCtx);    

  0008b	48 8b cf	 mov	 rcx, rdi
  0008e	e8 00 00 00 00	 call	 ReopenTPMLocality

; 115  :     *(UINT16*)pCom64->NewGdtr = 0xFFF;
; 116  :     *(UINT64*)(pCom64->NewGdtr + 2) = (UINT64)TempGdt;

  00093	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:TempGdt
  0009a	b8 ff 0f 00 00	 mov	 eax, 4095		; 00000fffH
  0009f	66 89 83 8a 00
	00 00		 mov	 WORD PTR [rbx+138], ax

; 117  :     *(UINT64*)(TempGdt + pCom64->OriginalES) = GdtBasePtr.AcmDataDescriptor.Raw;

  000a6	0f b7 43 34	 movzx	 eax, WORD PTR [rbx+52]
  000aa	48 89 93 8c 00
	00 00		 mov	 QWORD PTR [rbx+140], rdx
  000b1	48 8b 0d 10 00
	00 00		 mov	 rcx, QWORD PTR GdtBasePtr+16
  000b8	48 89 0c 10	 mov	 QWORD PTR [rax+rdx], rcx

; 118  :     *(UINT64*)(TempGdt + pCom64->OriginalFS) = GdtBasePtr.AcmDataDescriptor.Raw;

  000bc	0f b7 43 36	 movzx	 eax, WORD PTR [rbx+54]
  000c0	48 89 0c 10	 mov	 QWORD PTR [rax+rdx], rcx

; 119  :     *(UINT64*)(TempGdt + pCom64->OriginalGS) = GdtBasePtr.AcmDataDescriptor.Raw;

  000c4	0f b7 43 38	 movzx	 eax, WORD PTR [rbx+56]
  000c8	48 89 0c 10	 mov	 QWORD PTR [rax+rdx], rcx

; 120  :     *(UINT64*)(TempGdt + pCom64->OriginalSS) = GdtBasePtr.AcmDataDescriptor.Raw;

  000cc	0f b7 43 3a	 movzx	 eax, WORD PTR [rbx+58]
  000d0	48 89 0c 10	 mov	 QWORD PTR [rax+rdx], rcx

; 121  :     *(UINT64*)(TempGdt + pCom64->OriginalECX) = GdtBasePtr.AcmCode64Descriptor.Raw;

  000d4	8b 4b 3c	 mov	 ecx, DWORD PTR [rbx+60]
  000d7	48 8b 05 18 00
	00 00		 mov	 rax, QWORD PTR GdtBasePtr+24

; 122  : }

  000de	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000e3	48 89 04 11	 mov	 QWORD PTR [rcx+rdx], rax
  000e7	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000eb	5f		 pop	 rdi
  000ec	c3		 ret	 0
Target64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\projects\server\emr\seamldr\seamldr64.c
;	COMDAT ReopenTPMLocality
_TEXT	SEGMENT
PtCtx$ = 64
ReadByte$ = 72
ReopenTPMLocality PROC					; COMDAT

; 69   : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 70   :     // Map the LT_PRV MMIO page as a single 4KB page with UC memtype
; 71   :     // This is the first mapping the we do, so it should always succeed with enough page table entries left
; 72   :     volatile TXT* TXTPrivateBase = (volatile TXT*)MapPhysicalRange(PtCtx, LT_PRV_BASE, sizeof(TXT), PAGE_WRITABLE, PAGE_4K, PAGE_UC_MEMTYPE);

  0000a	83 64 24 28 00	 and	 DWORD PTR [rsp+40], 0
  0000f	ba 00 00 d2 fe	 mov	 edx, -19791872		; fed20000H
  00014	83 64 24 20 00	 and	 DWORD PTR [rsp+32], 0
  00019	41 b9 01 00 00
	00		 mov	 r9d, 1
  0001f	41 b8 f8 0d 00
	00		 mov	 r8d, 3576		; 00000df8H
  00025	48 8b f9	 mov	 rdi, rcx
  00028	e8 00 00 00 00	 call	 MapPhysicalRange
  0002d	48 8b d8	 mov	 rbx, rax

; 73   :     volatile UINT8 ReadByte;
; 74   : 
; 75   :     if ((UINT64)TXTPrivateBase == (UINT64)BAD_MAPPING) {

  00030	48 83 f8 ff	 cmp	 rax, -1
  00034	75 05		 jne	 SHORT $LN5@ReopenTPML

; 76   :         _ud2();

  00036	e8 00 00 00 00	 call	 _ud2
$LN5@ReopenTPML:

; 77   :     }
; 78   :     // If the value read has bit 0 set to 1 (i.e.LT.STS[0] == 1) then re-open the TXT private space and the TPM locality 2. 
; 79   :     if ((STSRegister & 0x1) != 0) {

  0003b	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR STSRegister
  00041	f6 c1 01	 test	 cl, 1
  00044	74 34		 je	 SHORT $LN6@ReopenTPML

; 80   :         // The post - SENTER state can be determined by reading 1 - byte at LT.STS register at MMIO address 0xFED20000. 
; 81   : 
; 82   :         // If the value read has bit 0 set to 1 (i.e.LT.STS[0] == 1) then re-open locality 2 for the MLE
; 83   :         // Note that access to MMIO registers must be done as UC accesses.
; 84   : 
; 85   :         *((UINT8*)(&TXTPrivateBase->LT_CMD_OPEN_LOCALITY2)) = 0x0;

  00046	c6 83 90 03 00
	00 00		 mov	 BYTE PTR [rbx+912], 0
$LL4@ReopenTPML:

; 86   :         do {
; 87   :             ReadByte = *((UINT8*)(&TXTPrivateBase->LT_CMD_OPEN_LOCALITY2));

  0004d	8a 83 90 03 00
	00		 mov	 al, BYTE PTR [rbx+912]
  00053	88 44 24 48	 mov	 BYTE PTR ReadByte$[rsp], al

; 88   :             PauseCpu();

  00057	e8 00 00 00 00	 call	 PauseCpu

; 89   :         } while ((ReadByte != 0) && (ReadByte != 0xFF));

  0005c	8a 44 24 48	 mov	 al, BYTE PTR ReadByte$[rsp]
  00060	84 c0		 test	 al, al
  00062	74 08		 je	 SHORT $LN7@ReopenTPML
  00064	8a 44 24 48	 mov	 al, BYTE PTR ReadByte$[rsp]
  00068	3c ff		 cmp	 al, 255			; 000000ffH
  0006a	75 e1		 jne	 SHORT $LL4@ReopenTPML
$LN7@ReopenTPML:

; 90   : 
; 91   :         RemoveLinearMapping(PtCtx, (UINT64)TXTPrivateBase, FALSE);

  0006c	45 33 c0	 xor	 r8d, r8d
  0006f	48 8b d3	 mov	 rdx, rbx
  00072	48 8b cf	 mov	 rcx, rdi
  00075	e8 00 00 00 00	 call	 RemoveLinearMapping
$LN6@ReopenTPML:

; 92   :     }
; 93   : }

  0007a	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0007f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00083	5f		 pop	 rdi
  00084	c3		 ret	 0
ReopenTPMLocality ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\projects\server\emr\seamldr\seamldr64.c
;	COMDAT CloseTPMLocality
_TEXT	SEGMENT
PtCtx$ = 64
ReadByte$ = 72
CloseTPMLocality PROC					; COMDAT

; 29   : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 30   :     // Map the LT_PRV MMIO page as a single 4KB page with UC memtype
; 31   :     // This is the first mapping the we do, so it should always succeed with enough page table entries left
; 32   :     volatile TXT* TXTPrivateBase = (volatile TXT*)MapPhysicalRange(PtCtx, LT_PRV_BASE, sizeof(TXT), PAGE_WRITABLE, PAGE_4K, PAGE_UC_MEMTYPE);

  0000a	83 64 24 28 00	 and	 DWORD PTR [rsp+40], 0
  0000f	ba 00 00 d2 fe	 mov	 edx, -19791872		; fed20000H
  00014	83 64 24 20 00	 and	 DWORD PTR [rsp+32], 0
  00019	41 b9 01 00 00
	00		 mov	 r9d, 1
  0001f	41 b8 f8 0d 00
	00		 mov	 r8d, 3576		; 00000df8H
  00025	48 8b f9	 mov	 rdi, rcx
  00028	e8 00 00 00 00	 call	 MapPhysicalRange
  0002d	48 8b d8	 mov	 rbx, rax

; 33   :     volatile UINT8 ReadByte;
; 34   : 
; 35   :     if ((UINT64)TXTPrivateBase == (UINT64)BAD_MAPPING) {

  00030	48 83 f8 ff	 cmp	 rax, -1
  00034	75 05		 jne	 SHORT $LN8@CloseTPMLo

; 36   :         _ud2();

  00036	e8 00 00 00 00	 call	 _ud2
$LN8@CloseTPMLo:

; 37   :     }
; 38   : 
; 39   :     // Note that access to MMIO registers must be done as UC accesses.
; 40   : 
; 41   :     // To close locality 3 do a
; 42   :     // 1 - byte write of 0x0 to MMIO address 0xFED203A8 (CMD.CLOSE.LOCALITY3) and then do a 1 - byte read to the same address.
; 43   :     *((UINT8*)(&TXTPrivateBase->LT_CMD_CLOSE_LOCALITY3)) = 0x0;

  0003b	c6 83 a8 03 00
	00 00		 mov	 BYTE PTR [rbx+936], 0
$LL4@CloseTPMLo:

; 44   :     do {
; 45   :         ReadByte = *((UINT8*)(&TXTPrivateBase->LT_CMD_CLOSE_LOCALITY3));

  00042	8a 8b a8 03 00
	00		 mov	 cl, BYTE PTR [rbx+936]
  00048	88 4c 24 48	 mov	 BYTE PTR ReadByte$[rsp], cl

; 46   :         PauseCpu();

  0004c	e8 00 00 00 00	 call	 PauseCpu

; 47   :     } while ((ReadByte != 0) && (ReadByte != 0xFF));

  00051	8a 44 24 48	 mov	 al, BYTE PTR ReadByte$[rsp]
  00055	84 c0		 test	 al, al
  00057	74 08		 je	 SHORT $LN9@CloseTPMLo
  00059	8a 44 24 48	 mov	 al, BYTE PTR ReadByte$[rsp]
  0005d	3c ff		 cmp	 al, 255			; 000000ffH
  0005f	75 e1		 jne	 SHORT $LL4@CloseTPMLo
$LN9@CloseTPMLo:

; 48   : 
; 49   :     // The TXT private space and TPM locality 2 must be closed only if the platform is not post - SENTER.
; 50   :     // The post - SENTER state can be determined by reading 1 - byte at LT.STS register at MMIO address 0xFED20000. 
; 51   :     STSRegister = *((UINT8*)(&TXTPrivateBase->LT_STS));

  00061	8a 03		 mov	 al, BYTE PTR [rbx]
  00063	88 05 00 00 00
	00		 mov	 BYTE PTR STSRegister, al

; 52   : 
; 53   :     // If the value read has bit 0 set to 1 (i.e.LT.STS[0] == 1) then do not close the TXT private space or the TPM locality 2. 
; 54   :     if ((STSRegister & 0x1) == 0) {

  00069	8a 05 00 00 00
	00		 mov	 al, BYTE PTR STSRegister
  0006f	a8 01		 test	 al, 1
  00071	75 20		 jne	 SHORT $LN6@CloseTPMLo

; 55   :         // To close TXT private space do a 1 - byte write of 0x0 to MMIO address 0xFED20048 (CMD.CLOSE - PRIVATE) and then do a 1 - byte read to the same address.
; 56   :         *((UINT8*)(&TXTPrivateBase->LT_CMD_CLOSE_PRIVATE)) = 0x0;

  00073	c6 43 48 00	 mov	 BYTE PTR [rbx+72], 0
$LL7@CloseTPMLo:

; 57   :         do {
; 58   :             ReadByte = *((UINT8*)(&TXTPrivateBase->LT_CMD_CLOSE_PRIVATE));

  00077	8a 43 48	 mov	 al, BYTE PTR [rbx+72]
  0007a	88 44 24 48	 mov	 BYTE PTR ReadByte$[rsp], al

; 59   :             PauseCpu();

  0007e	e8 00 00 00 00	 call	 PauseCpu

; 60   :         } while ((ReadByte != 0) && (ReadByte != 0xFF));

  00083	8a 44 24 48	 mov	 al, BYTE PTR ReadByte$[rsp]
  00087	84 c0		 test	 al, al
  00089	74 08		 je	 SHORT $LN6@CloseTPMLo
  0008b	8a 44 24 48	 mov	 al, BYTE PTR ReadByte$[rsp]
  0008f	3c ff		 cmp	 al, 255			; 000000ffH
  00091	75 e4		 jne	 SHORT $LL7@CloseTPMLo
$LN6@CloseTPMLo:

; 61   : 
; 62   :         // 1308911717 - Closing LT private closes locality 2 as well, so closing locality 2 explicitly is redundant
; 63   :     }
; 64   : 
; 65   :     RemoveLinearMapping(PtCtx, (UINT64)TXTPrivateBase, FALSE);

  00093	45 33 c0	 xor	 r8d, r8d
  00096	48 8b d3	 mov	 rdx, rbx
  00099	48 8b cf	 mov	 rcx, rdi

; 66   : }

  0009c	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000a1	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000a5	5f		 pop	 rdi

; 61   : 
; 62   :         // 1308911717 - Closing LT private closes locality 2 as well, so closing locality 2 explicitly is redundant
; 63   :     }
; 64   : 
; 65   :     RemoveLinearMapping(PtCtx, (UINT64)TXTPrivateBase, FALSE);

  000a6	e9 00 00 00 00	 jmp	 RemoveLinearMapping
CloseTPMLocality ENDP
_TEXT	ENDS
END

; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24245.0 

	TITLE	D:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\Core\Common\AcmErr.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_ErrCtx
PUBLIC	_AcmErrorHandlerPtr
EDATA32	SEGMENT
_ErrCtx	DB	0cH DUP (?)
_AcmErrorHandlerPtr DD 01H DUP (?)
EDATA32	ENDS
PUBLIC	_CoreAcmErrorHandler
PUBLIC	_ProgressMark
PUBLIC	_LtReset
PUBLIC	___ErrorHandler
PUBLIC	_INTErrorHandler
EXTRN	_WaitFixedTime:PROC
EXTRN	_ChipsetAcmType:DWORD
EXTRN	_TxtErrorRegister:DWORD
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\common\acmerr.c
;	COMDAT _INTErrorHandler
_TEXT	SEGMENT
_INTErrorHandler PROC					; COMDAT

; 214  :   __ErrorHandler(CLASS_MISC_CONFIG, ERR_INTERRUPT);

  00000	6a 01		 push	 1
  00002	6a 08		 push	 8
  00004	e8 00 00 00 00	 call	 ___ErrorHandler
  00009	59		 pop	 ecx
  0000a	59		 pop	 ecx
_INTErrorHandler ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\common\acmerr.c
;	COMDAT ___ErrorHandler
_TEXT	SEGMENT
_ClassCode$ = 8						; size = 4
_ErrorCode$ = 12					; size = 4
___ErrorHandler PROC					; COMDAT

; 235  : #ifndef NO_CORE_ERRORHANDLE
; 236  : 
; 237  :   (*AcmErrorHandlerPtr)(ClassCode, ErrorCode);

  00000	ff 25 00 00 00
	00		 jmp	 DWORD PTR _AcmErrorHandlerPtr
___ErrorHandler ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\common\acmerr.c
;	COMDAT _LtReset
_TEXT	SEGMENT
_LtReset PROC						; COMDAT

; 133  :   //
; 134  :   // change to prevent multiple back-to-back LtReset. CSME cannot handle
; 135  :   //
; 136  :   WritePrivateDword(LT_CMD_SYS_RESET, 0);
; 137  : 
; 138  :   Wait100ms();

  00000	6a 64		 push	 100			; 00000064H
  00002	c7 05 38 00 d2
	fe 00 00 00 00	 mov	 DWORD PTR ds:-19791816, 0
  0000c	e8 00 00 00 00	 call	 _WaitFixedTime
  00011	59		 pop	 ecx
$DeadLoop$6:

; 139  : 
; 140  :   //
; 141  :   // Removed - don't use MMIO based reset in ACM - it can be easily
; 142  :   // trapped.
; 143  :   //
; 144  :   // Sighting #3864605 Start
; 145  : DeadLoop:
; 146  :   __halt();

  00012	f4		 hlt

; 147  :   goto  DeadLoop;

  00013	eb fd		 jmp	 SHORT $DeadLoop$6
_LtReset ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\common\acmerr.c
;	COMDAT _ProgressMark
_TEXT	SEGMENT
_code$ = 8						; size = 1
_ProgressMark PROC					; COMDAT

; 166  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 167  :   UINT32 CrashCode;
; 168  : 
; 169  :   if ((*(volatile CRASH_REGISTER *)TxtErrorRegister).Class != CLASS_ACM_PROGRESS) {

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR _TxtErrorRegister
  00008	8b 00		 mov	 eax, DWORD PTR [eax]
  0000a	a9 f0 03 00 00	 test	 eax, 1008		; 000003f0H
  0000f	75 25		 jne	 SHORT $LN1@ProgressMa

; 170  :     return;
; 171  :   }
; 172  : 
; 173  :   //
; 174  :   // Initialize all fields of image of crash register.
; 175  :   //
; 176  :   //CrashCode = CRASH_CODE_VALID +
; 177  :   //                   CRASH_CODE_SW_GENERATED +
; 178  :   //                   (code << 16) +
; 179  :   //                   ChipsetAcmType;
; 180  : 
; 181  :   //do not set valid bit 31 for progress mark
; 182  :   CrashCode = 0x00000000 +

  00011	0f b6 4d 08	 movzx	 ecx, BYTE PTR _code$[ebp]

; 183  :               (code << 16) +
; 184  :               ChipsetAcmType;
; 185  :   //
; 186  :   // Program crash register with progress mark value
; 187  :   //
; 188  :   *(volatile UINT32 *)TxtErrorRegister = CrashCode;

  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR _TxtErrorRegister
  0001a	c1 e1 10	 shl	 ecx, 16			; 00000010H
  0001d	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _ChipsetAcmType
  00023	89 08		 mov	 DWORD PTR [eax], ecx

; 189  : 
; 190  :   //
; 191  :   // Reset error context variable to clear stale data and get ready for
; 192  :   // next task.
; 193  :   //
; 194  :   ErrCtx.Class = ErrCtx.Major = ErrCtx.Minor = 0;

  00025	33 c0		 xor	 eax, eax
  00027	a3 08 00 00 00	 mov	 DWORD PTR _ErrCtx+8, eax
  0002c	a3 04 00 00 00	 mov	 DWORD PTR _ErrCtx+4, eax
  00031	a3 00 00 00 00	 mov	 DWORD PTR _ErrCtx, eax
$LN1@ProgressMa:

; 195  : }

  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
_ProgressMark ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\common\acmerr.c
;	COMDAT _CoreAcmErrorHandler
_TEXT	SEGMENT
_Class$ = 8						; size = 4
_Major$ = 12						; size = 4
_CoreAcmErrorHandler PROC				; COMDAT

; 91   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 92   :   CRASH_REGISTER CrashCode;
; 93   : 
; 94   :   //
; 95   :   // If any parameter is VOID - assume that it was set outside
; 96   :   // context of this handler. ErrCtx.Minor is always assumed to be
; 97   :   // set outside handler context.
; 98   :   //
; 99   :   if (Class != VOID) {

  00003	83 7d 08 ff	 cmp	 DWORD PTR _Class$[ebp], -1
  00007	a1 00 00 00 00	 mov	 eax, DWORD PTR _ErrCtx
  0000c	0f 45 45 08	 cmovne	 eax, DWORD PTR _Class$[ebp]

; 100  :     ErrCtx.Class = Class;
; 101  :   }
; 102  : 
; 103  :   if (Major != VOID) {

  00010	83 7d 0c ff	 cmp	 DWORD PTR _Major$[ebp], -1
  00014	a3 00 00 00 00	 mov	 DWORD PTR _ErrCtx, eax
  00019	a1 04 00 00 00	 mov	 eax, DWORD PTR _ErrCtx+4
  0001e	0f 45 45 0c	 cmovne	 eax, DWORD PTR _Major$[ebp]
  00022	a3 04 00 00 00	 mov	 DWORD PTR _ErrCtx+4, eax

; 104  :     ErrCtx.Major = Major;
; 105  :   }
; 106  :   //
; 107  :   // The following also initializes all other fields to 0
; 108  :   //
; 109  :   *(UINT32 *) &CrashCode = CRASH_CODE_VALID + CRASH_CODE_SW_GENERATED + ChipsetAcmType;
; 110  : 
; 111  :   CrashCode.Minor = ErrCtx.Minor;
; 112  : 
; 113  :   CrashCode.Major = ErrCtx.Major;
; 114  :   CrashCode.Class = ErrCtx.Class;
; 115  : 
; 116  :   TRACE("\nError: Class = %lx, Major = %lx, Minor = %lx\n", ErrCtx.Class, ErrCtx.Major, ErrCtx.Minor);
; 117  : }

  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
_CoreAcmErrorHandler ENDP
_TEXT	ENDS
END

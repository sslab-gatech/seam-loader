; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24210.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	MapPage
PUBLIC	InitPseamldrPtCtx
PUBLIC	??_C@_0BB@LNBLGDOE@InitSeamrrPtCtx?6?$AA@IMHBAIGO@ ;  ?? ::IMHBAIGO::`string'
PUBLIC	??_C@_0P@OJPCAKOG@SeamRrBase?3?50x?$AA@IMHBAIGO@ ;  ?? ::IMHBAIGO::`string'
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@IMHBAIGO@		;  ?? ::IMHBAIGO::`string'
PUBLIC	??_C@_0P@BEDEACLC@SeamRrSize?3?50x?$AA@IMHBAIGO@ ;  ?? ::IMHBAIGO::`string'
PUBLIC	??_C@_0BO@CLKNGODK@SeamrrPtCtx?9?$DOPtBaseAddrLa?3?50x?$AA@IMHBAIGO@ ;  ?? ::IMHBAIGO::`string'
PUBLIC	??_C@_0BO@ILNDJIIA@SeamrrPtCtx?9?$DOPtBaseAddrPa?3?50x?$AA@IMHBAIGO@ ;  ?? ::IMHBAIGO::`string'
PUBLIC	??_C@_0BP@PNNIHBNC@SeamrrPtCtx?9?$DOPtAllocatorPa?3?50x?$AA@IMHBAIGO@ ;  ?? ::IMHBAIGO::`string'
PUBLIC	??_C@_0CC@DFGILCE@SeamrrPtCtx?9?$DOPagingStructSize?3?50@IMHBAIGO@ ;  ?? ::IMHBAIGO::`string'
PUBLIC	??_C@_0BJ@DMOBKCLP@SeamrrPtCtx?9?$DOVPDelta?3?50x?$AA@IMHBAIGO@ ;  ?? ::IMHBAIGO::`string'
EXTRN	ComSerialOut:PROC
EXTRN	printHex:PROC
EXTRN	SeamldrData:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$MapPage DD imagerel $LN17
	DD	imagerel $LN17+323
	DD	imagerel $unwind$MapPage
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$InitPseamldrPtCtx DD imagerel $LN4
	DD	imagerel $LN4+349
	DD	imagerel $unwind$InitPseamldrPtCtx
pdata	ENDS
;	COMDAT ??_C@_0BJ@DMOBKCLP@SeamrrPtCtx?9?$DOVPDelta?3?50x?$AA@IMHBAIGO@
EDATA32	SEGMENT
??_C@_0BJ@DMOBKCLP@SeamrrPtCtx?9?$DOVPDelta?3?50x?$AA@IMHBAIGO@ DB 'Seamr'
	DB	'rPtCtx->VPDelta: 0x', 00H			;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT ??_C@_0CC@DFGILCE@SeamrrPtCtx?9?$DOPagingStructSize?3?50@IMHBAIGO@
EDATA32	SEGMENT
??_C@_0CC@DFGILCE@SeamrrPtCtx?9?$DOPagingStructSize?3?50@IMHBAIGO@ DB 'Se'
	DB	'amrrPtCtx->PagingStructSize: 0x', 00H	;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT ??_C@_0BP@PNNIHBNC@SeamrrPtCtx?9?$DOPtAllocatorPa?3?50x?$AA@IMHBAIGO@
EDATA32	SEGMENT
??_C@_0BP@PNNIHBNC@SeamrrPtCtx?9?$DOPtAllocatorPa?3?50x?$AA@IMHBAIGO@ DB 'S'
	DB	'eamrrPtCtx->PtAllocatorPa: 0x', 00H		;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT ??_C@_0BO@ILNDJIIA@SeamrrPtCtx?9?$DOPtBaseAddrPa?3?50x?$AA@IMHBAIGO@
EDATA32	SEGMENT
??_C@_0BO@ILNDJIIA@SeamrrPtCtx?9?$DOPtBaseAddrPa?3?50x?$AA@IMHBAIGO@ DB 'S'
	DB	'eamrrPtCtx->PtBaseAddrPa: 0x', 00H		;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT ??_C@_0BO@CLKNGODK@SeamrrPtCtx?9?$DOPtBaseAddrLa?3?50x?$AA@IMHBAIGO@
EDATA32	SEGMENT
??_C@_0BO@CLKNGODK@SeamrrPtCtx?9?$DOPtBaseAddrLa?3?50x?$AA@IMHBAIGO@ DB 'S'
	DB	'eamrrPtCtx->PtBaseAddrLa: 0x', 00H		;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT ??_C@_0P@BEDEACLC@SeamRrSize?3?50x?$AA@IMHBAIGO@
EDATA32	SEGMENT
??_C@_0P@BEDEACLC@SeamRrSize?3?50x?$AA@IMHBAIGO@ DB 'SeamRrSize: 0x', 00H ;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@IMHBAIGO@
EDATA32	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@IMHBAIGO@ DB 0aH, 00H		;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT ??_C@_0P@OJPCAKOG@SeamRrBase?3?50x?$AA@IMHBAIGO@
EDATA32	SEGMENT
??_C@_0P@OJPCAKOG@SeamRrBase?3?50x?$AA@IMHBAIGO@ DB 'SeamRrBase: 0x', 00H ;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT ??_C@_0BB@LNBLGDOE@InitSeamrrPtCtx?6?$AA@IMHBAIGO@
EDATA32	SEGMENT
??_C@_0BB@LNBLGDOE@InitSeamrrPtCtx?6?$AA@IMHBAIGO@ DB 'InitSeamrrPtCtx', 0aH
	DB	00H						;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$InitPseamldrPtCtx DD 0a1901H
	DD	097419H
	DD	086419H
	DD	075419H
	DD	063419H
	DD	0e0153219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$MapPage DD 0a1701H
	DD	067417H
	DD	056417H
	DD	045417H
	DD	033417H
	DD	0e015f017H
xdata	ENDS
; Function compile flags: /Ogsp
; File c:\users\jwhur\downloads\seam-loader\seam-loader-main-1.5\np-seam-loader\seamldr_src\core\commonseamldr64\seamrrpaging64.c
;	COMDAT InitPseamldrPtCtx
_TEXT	SEGMENT
SeamrrPtCtx$ = 48
SeamRrVa$ = 56
SeamRrBase$ = 64
SeamRrSize$ = 72
PSeamldrRangeBase$ = 80
PagingStructSize$ = 88
InitPseamldrPtCtx PROC					; COMDAT

; 25   : {

$LN4:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000f	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  00013	41 56		 push	 r14
  00015	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00019	4c 8b f1	 mov	 r14, rcx
  0001c	49 8b d9	 mov	 rbx, r9

; 26   :     (void)SeamRrSize;
; 27   :     COMSERIALOUT("InitSeamrrPtCtx\n");

  0001f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@LNBLGDOE@InitSeamrrPtCtx?6?$AA@IMHBAIGO@
  00026	49 8b f8	 mov	 rdi, r8
  00029	48 8b f2	 mov	 rsi, rdx
  0002c	e8 00 00 00 00	 call	 ComSerialOut

; 28   :     PRINT_HEX_VAL("SeamRrBase: 0x", SeamRrBase);

  00031	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@OJPCAKOG@SeamRrBase?3?50x?$AA@IMHBAIGO@
  00038	e8 00 00 00 00	 call	 ComSerialOut
  0003d	48 8b cf	 mov	 rcx, rdi
  00040	e8 00 00 00 00	 call	 printHex
  00045	48 8d 2d 00 00
	00 00		 lea	 rbp, OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@IMHBAIGO@
  0004c	48 8b cd	 mov	 rcx, rbp
  0004f	e8 00 00 00 00	 call	 ComSerialOut

; 29   :     PRINT_HEX_VAL("SeamRrSize: 0x", SeamRrSize);

  00054	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@BEDEACLC@SeamRrSize?3?50x?$AA@IMHBAIGO@
  0005b	e8 00 00 00 00	 call	 ComSerialOut
  00060	48 8b cb	 mov	 rcx, rbx
  00063	e8 00 00 00 00	 call	 printHex
  00068	48 8b cd	 mov	 rcx, rbp
  0006b	e8 00 00 00 00	 call	 ComSerialOut

; 30   :         
; 31   :     SeamrrPtCtx->PtBaseAddrLa = SeamRrVa + (PSeamldrRangeBase - SeamRrBase) + _8KB;    

  00070	48 8b 4c 24 50	 mov	 rcx, QWORD PTR PSeamldrRangeBase$[rsp]
  00075	48 2b f7	 sub	 rsi, rdi

; 32   :     SeamrrPtCtx->PtBaseAddrPa = SeamRrBase + (PSeamldrRangeBase - SeamRrBase) + _8KB;
; 33   :     
; 34   :     SeamrrPtCtx->PtAllocatorPa = SeamrrPtCtx->PtBaseAddrPa + _4KB;
; 35   :     SeamrrPtCtx->NumPageLevels = 4;

  00078	49 c7 46 18 04
	00 00 00	 mov	 QWORD PTR [r14+24], 4

; 36   : 
; 37   :     SeamrrPtCtx->VPDelta = SeamRrVa - SeamRrBase;

  00080	49 89 76 20	 mov	 QWORD PTR [r14+32], rsi
  00084	48 8d 81 00 20
	00 00		 lea	 rax, QWORD PTR [rcx+8192]
  0008b	48 03 c6	 add	 rax, rsi
  0008e	49 89 06	 mov	 QWORD PTR [r14], rax
  00091	48 8d 81 00 20
	00 00		 lea	 rax, QWORD PTR [rcx+8192]
  00098	49 89 46 08	 mov	 QWORD PTR [r14+8], rax

; 38   : 
; 39   :     SeamrrPtCtx->PagingStructSize = PagingStructSize;
; 40   : 
; 41   :     PRINT_HEX_VAL("SeamrrPtCtx->PtBaseAddrLa: 0x", SeamrrPtCtx->PtBaseAddrLa);

  0009c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BO@CLKNGODK@SeamrrPtCtx?9?$DOPtBaseAddrLa?3?50x?$AA@IMHBAIGO@
  000a3	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  000a9	49 89 46 10	 mov	 QWORD PTR [r14+16], rax
  000ad	48 8b 44 24 58	 mov	 rax, QWORD PTR PagingStructSize$[rsp]
  000b2	49 89 46 28	 mov	 QWORD PTR [r14+40], rax
  000b6	e8 00 00 00 00	 call	 ComSerialOut
  000bb	49 8b 0e	 mov	 rcx, QWORD PTR [r14]
  000be	e8 00 00 00 00	 call	 printHex
  000c3	48 8b cd	 mov	 rcx, rbp
  000c6	e8 00 00 00 00	 call	 ComSerialOut

; 42   :     PRINT_HEX_VAL("SeamrrPtCtx->PtBaseAddrPa: 0x", SeamrrPtCtx->PtBaseAddrPa);

  000cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BO@ILNDJIIA@SeamrrPtCtx?9?$DOPtBaseAddrPa?3?50x?$AA@IMHBAIGO@
  000d2	e8 00 00 00 00	 call	 ComSerialOut
  000d7	49 8b 4e 08	 mov	 rcx, QWORD PTR [r14+8]
  000db	e8 00 00 00 00	 call	 printHex
  000e0	48 8b cd	 mov	 rcx, rbp
  000e3	e8 00 00 00 00	 call	 ComSerialOut

; 43   :     PRINT_HEX_VAL("SeamrrPtCtx->PtAllocatorPa: 0x", SeamrrPtCtx->PtAllocatorPa);

  000e8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BP@PNNIHBNC@SeamrrPtCtx?9?$DOPtAllocatorPa?3?50x?$AA@IMHBAIGO@
  000ef	e8 00 00 00 00	 call	 ComSerialOut
  000f4	49 8b 4e 10	 mov	 rcx, QWORD PTR [r14+16]
  000f8	e8 00 00 00 00	 call	 printHex
  000fd	48 8b cd	 mov	 rcx, rbp
  00100	e8 00 00 00 00	 call	 ComSerialOut

; 44   :     PRINT_HEX_VAL("SeamrrPtCtx->PagingStructSize: 0x", SeamrrPtCtx->PagingStructSize);

  00105	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CC@DFGILCE@SeamrrPtCtx?9?$DOPagingStructSize?3?50@IMHBAIGO@
  0010c	e8 00 00 00 00	 call	 ComSerialOut
  00111	49 8b 4e 28	 mov	 rcx, QWORD PTR [r14+40]
  00115	e8 00 00 00 00	 call	 printHex
  0011a	48 8b cd	 mov	 rcx, rbp
  0011d	e8 00 00 00 00	 call	 ComSerialOut

; 45   :     PRINT_HEX_VAL("SeamrrPtCtx->VPDelta: 0x", SeamrrPtCtx->VPDelta);

  00122	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BJ@DMOBKCLP@SeamrrPtCtx?9?$DOVPDelta?3?50x?$AA@IMHBAIGO@
  00129	e8 00 00 00 00	 call	 ComSerialOut
  0012e	49 8b 4e 20	 mov	 rcx, QWORD PTR [r14+32]
  00132	e8 00 00 00 00	 call	 printHex
  00137	48 8b cd	 mov	 rcx, rbp
  0013a	e8 00 00 00 00	 call	 ComSerialOut

; 46   :     return SeamrrPtCtx;
; 47   : }

  0013f	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00144	49 8b c6	 mov	 rax, r14
  00147	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  0014c	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00151	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  00156	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0015a	41 5e		 pop	 r14
  0015c	c3		 ret	 0
InitPseamldrPtCtx ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File c:\users\jwhur\downloads\seam-loader\seam-loader-main-1.5\np-seam-loader\seamldr_src\core\commonseamldr64\seamrrpaging64.c
;	COMDAT MapPage
_TEXT	SEGMENT
SeamrrPtCtx$ = 24
LinearAddr$ = 32
PhysAddr$ = 40
Attr$ = 48
PageMappingSize$ = 56
IsKeyHoleMapping$ = 64
MapPage	PROC						; COMDAT

; 49   : UINT64* MapPage(SEAMRR_PT_CTX* SeamrrPtCtx, UINT64 LinearAddr, UINT64 PhysAddr, UINT64 Attr, PAGE_SIZE PageMappingSize, BOOL IsKeyHoleMapping) {

$LN17:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000f	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  00013	41 56		 push	 r14
  00015	41 57		 push	 r15

; 50   :     UINT32 PtIdx, Idx;
; 51   :     UINT64 *PxeLinear;
; 52   :     UINT64 *PxePhysical = NULL;
; 53   :     UINT64 CurNumPageLevels = SeamrrPtCtx->NumPageLevels;

  00017	48 8b 41 18	 mov	 rax, QWORD PTR [rcx+24]
  0001b	4c 8b da	 mov	 r11, rdx
  0001e	33 d2		 xor	 edx, edx
  00020	49 8b d8	 mov	 rbx, r8

; 54   :     UINT32 PtShiftBits = 12;
; 55   : 
; 56   :     if (PageMappingSize == PAGE_2M) {

  00023	83 7c 24 38 01	 cmp	 DWORD PTR PageMappingSize$[rsp], 1
  00028	4c 8b d1	 mov	 r10, rcx
  0002b	8d 6a 0c	 lea	 ebp, QWORD PTR [rdx+12]
  0002e	75 0b		 jne	 SHORT $LN5@MapPage

; 57   :         CurNumPageLevels--;

  00030	48 ff c8	 dec	 rax

; 58   :         PtShiftBits = 21;

  00033	8d 6a 15	 lea	 ebp, QWORD PTR [rdx+21]

; 59   :         Attr |= IA32_PG_PS;

  00036	49 0f ba e9 07	 bts	 r9, 7
$LN5@MapPage:

; 60   :     }
; 61   : 
; 62   : //    PRINT_HEX_VAL("Mapping PA ", PhysAddr);
; 63   : //    PRINT_HEX_VAL("To LA ", LinearAddr);
; 64   :     PxeLinear = (UINT64 *)SeamrrPtCtx->PtBaseAddrLa;

  0003b	4c 8b 01	 mov	 r8, QWORD PTR [rcx]

; 65   :     // walk and fill if needed non leaf levels
; 66   :     for (Idx = 0; Idx < CurNumPageLevels - 1; Idx++) {

  0003e	4c 8d 78 ff	 lea	 r15, QWORD PTR [rax-1]
  00042	33 ff		 xor	 edi, edi
  00044	4d 85 ff	 test	 r15, r15
  00047	0f 84 c3 00 00
	00		 je	 $LN15@MapPage

; 60   :     }
; 61   : 
; 62   : //    PRINT_HEX_VAL("Mapping PA ", PhysAddr);
; 63   : //    PRINT_HEX_VAL("To LA ", LinearAddr);
; 64   :     PxeLinear = (UINT64 *)SeamrrPtCtx->PtBaseAddrLa;

  0004d	45 33 f6	 xor	 r14d, r14d
$LL4@MapPage:

; 67   :         PtIdx = (LinearAddr >> ((SeamrrPtCtx->NumPageLevels - 1) * 9 - Idx * 9 + 12)) & 0x1ff;

  00050	41 8a 4a 18	 mov	 cl, BYTE PTR [r10+24]
  00054	49 8b d3	 mov	 rdx, r11
  00057	80 c1 ff	 add	 cl, 255			; 000000ffH
  0005a	8a c1		 mov	 al, cl
  0005c	c0 e0 03	 shl	 al, 3
  0005f	02 c8		 add	 cl, al
  00061	41 2a ce	 sub	 cl, r14b
  00064	83 c1 0c	 add	 ecx, 12
  00067	48 d3 ea	 shr	 rdx, cl
  0006a	81 e2 ff 01 00
	00		 and	 edx, 511		; 000001ffH

; 68   :         // check if PT exists
; 69   :         if (PxeLinear[PtIdx] == 0) {

  00070	8b f2		 mov	 esi, edx
  00072	49 83 3c d0 00	 cmp	 QWORD PTR [r8+rdx*8], 0
  00077	75 6d		 jne	 SHORT $LN6@MapPage

; 70   :             // if the allocator reached the data region - error
; 71   :             if (SeamrrPtCtx->PtAllocatorPa >= SeamldrData.SeamrrBase + SeamldrData.SeamrrSize -

  00079	48 8b 05 88 01
	00 00		 mov	 rax, QWORD PTR SeamldrData+392
  00080	48 8b 0d 40 00
	00 00		 mov	 rcx, QWORD PTR SeamldrData+64
  00087	49 8b 52 10	 mov	 rdx, QWORD PTR [r10+16]
  0008b	48 2b 48 10	 sub	 rcx, QWORD PTR [rax+16]
  0008f	48 2b 48 08	 sub	 rcx, QWORD PTR [rax+8]
  00093	48 2b 08	 sub	 rcx, QWORD PTR [rax]
  00096	48 8b 05 38 00
	00 00		 mov	 rax, QWORD PTR SeamldrData+56
  0009d	48 05 00 e0 ff
	ff		 add	 rax, -8192		; ffffffffffffe000H
  000a3	48 03 c8	 add	 rcx, rax
  000a6	48 3b d1	 cmp	 rdx, rcx
  000a9	0f 83 90 00 00
	00		 jae	 $LN11@MapPage

; 75   :             }
; 76   :             PxeLinear[PtIdx] = SeamrrPtCtx->PtAllocatorPa | IA32_PG_P | IA32_PG_RW | IA32_PG_A | IA32_PG_U;

  000af	48 83 ca 27	 or	 rdx, 39			; 00000027H

; 77   :             // non leaf PDE mapping keyhole pages
; 78   :             if (IsKeyHoleMapping && (2 == SeamrrPtCtx->NumPageLevels - Idx)) {

  000b3	80 7c 24 40 00	 cmp	 BYTE PTR IsKeyHoleMapping$[rsp], 0
  000b8	49 89 14 f0	 mov	 QWORD PTR [r8+rsi*8], rdx
  000bc	74 20		 je	 SHORT $LN8@MapPage
  000be	49 8b 4a 18	 mov	 rcx, QWORD PTR [r10+24]
  000c2	8b c7		 mov	 eax, edi
  000c4	48 2b c8	 sub	 rcx, rax
  000c7	48 83 f9 02	 cmp	 rcx, 2
  000cb	75 11		 jne	 SHORT $LN8@MapPage

; 79   :                 PxeLinear[PtIdx] |= IA32_PG_NX;

  000cd	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  000d7	48 0b d0	 or	 rdx, rax
  000da	49 89 14 f0	 mov	 QWORD PTR [r8+rsi*8], rdx
$LN8@MapPage:

; 80   :             }
; 81   :             SeamrrPtCtx->PtAllocatorPa += SEAMRR_PAGE_SIZE;

  000de	49 81 42 10 00
	10 00 00	 add	 QWORD PTR [r10+16], 4096 ; 00001000H
$LN6@MapPage:

; 82   :         }
; 83   :         
; 84   :         PxePhysical = (UINT64 *)(PxeLinear[PtIdx] & SeamldrData.PhysAddrMask & (~(SEAMRR_PAGE_SIZE - 1)));

  000e6	48 8b 15 18 00
	00 00		 mov	 rdx, QWORD PTR SeamldrData+24
  000ed	ff c7		 inc	 edi
  000ef	49 23 14 f0	 and	 rdx, QWORD PTR [r8+rsi*8]
  000f3	41 83 c6 09	 add	 r14d, 9

; 85   :         PxeLinear = (UINT64 *)((INT64)PxePhysical + SeamrrPtCtx->VPDelta);        // read pxe from virtual address

  000f7	4d 8b 42 20	 mov	 r8, QWORD PTR [r10+32]
  000fb	48 81 e2 00 f0
	ff ff		 and	 rdx, -4096		; fffffffffffff000H
  00102	4c 03 c2	 add	 r8, rdx
  00105	8b c7		 mov	 eax, edi
  00107	49 3b c7	 cmp	 rax, r15
  0010a	0f 82 40 ff ff
	ff		 jb	 $LL4@MapPage
$LN15@MapPage:

; 86   :     }
; 87   :     // map leaf level
; 88   :     PtIdx = (LinearAddr >> PtShiftBits) & 0x1ff;
; 89   :     PxeLinear[PtIdx] = PhysAddr | Attr;

  00110	49 0b d9	 or	 rbx, r9
  00113	8b cd		 mov	 ecx, ebp
  00115	49 d3 eb	 shr	 r11, cl

; 90   :     // return PT used for mapping
; 91   :     return PxePhysical;

  00118	48 8b c2	 mov	 rax, rdx
  0011b	41 81 e3 ff 01
	00 00		 and	 r11d, 511		; 000001ffH
  00122	4b 89 1c d8	 mov	 QWORD PTR [r8+r11*8], rbx
$LN1@MapPage:

; 92   : }

  00126	48 8b 5c 24 18	 mov	 rbx, QWORD PTR [rsp+24]
  0012b	48 8b 6c 24 20	 mov	 rbp, QWORD PTR [rsp+32]
  00130	48 8b 74 24 28	 mov	 rsi, QWORD PTR [rsp+40]
  00135	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
  0013a	41 5f		 pop	 r15
  0013c	41 5e		 pop	 r14
  0013e	c3		 ret	 0
$LN11@MapPage:

; 72   :                 (C_P_SYS_INFO_TABLE_SIZE + SeamldrData.PSeamldrConsts->CCodeRgnSize + SeamldrData.PSeamldrConsts->CDataStackSize + P_SEAMLDR_SHADOW_STACK_SIZE + 
; 73   :                     SeamldrData.PSeamldrConsts->CDataRgnSize)) {
; 74   :                 return NULL;

  0013f	33 c0		 xor	 eax, eax
  00141	eb e3		 jmp	 SHORT $LN1@MapPage
MapPage	ENDP
_TEXT	ENDS
END

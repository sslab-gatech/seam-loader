; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24245.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	MapPage
PUBLIC	InitPseamldrPtCtx
PUBLIC	??_C@_0BB@LNBLGDOE@InitSeamrrPtCtx?6?$AA@IMHBAIGO@ ;  ?? ::IMHBAIGO::`string'
PUBLIC	??_C@_0P@OJPCAKOG@SeamRrBase?3?50x?$AA@IMHBAIGO@ ;  ?? ::IMHBAIGO::`string'
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@IMHBAIGO@		;  ?? ::IMHBAIGO::`string'
PUBLIC	??_C@_0P@BEDEACLC@SeamRrSize?3?50x?$AA@IMHBAIGO@ ;  ?? ::IMHBAIGO::`string'
PUBLIC	??_C@_0BO@CLKNGODK@SeamrrPtCtx?9?$DOPtBaseAddrLa?3?50x?$AA@IMHBAIGO@ ;  ?? ::IMHBAIGO::`string'
PUBLIC	??_C@_0BO@ILNDJIIA@SeamrrPtCtx?9?$DOPtBaseAddrPa?3?50x?$AA@IMHBAIGO@ ;  ?? ::IMHBAIGO::`string'
PUBLIC	??_C@_0BP@PNNIHBNC@SeamrrPtCtx?9?$DOPtAllocatorPa?3?50x?$AA@IMHBAIGO@ ;  ?? ::IMHBAIGO::`string'
PUBLIC	??_C@_0CC@DFGILCE@SeamrrPtCtx?9?$DOPagingStructSize?3?50@IMHBAIGO@ ;  ?? ::IMHBAIGO::`string'
PUBLIC	??_C@_0BJ@DMOBKCLP@SeamrrPtCtx?9?$DOVPDelta?3?50x?$AA@IMHBAIGO@ ;  ?? ::IMHBAIGO::`string'
EXTRN	ComSerialOut:PROC
EXTRN	printHex:PROC
EXTRN	SeamldrData:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$MapPage DD imagerel $LN17
	DD	imagerel $LN17+329
	DD	imagerel $unwind$MapPage
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$InitPseamldrPtCtx DD imagerel $LN4
	DD	imagerel $LN4+349
	DD	imagerel $unwind$InitPseamldrPtCtx
pdata	ENDS
;	COMDAT ??_C@_0BJ@DMOBKCLP@SeamrrPtCtx?9?$DOVPDelta?3?50x?$AA@IMHBAIGO@
EDATA32	SEGMENT
??_C@_0BJ@DMOBKCLP@SeamrrPtCtx?9?$DOVPDelta?3?50x?$AA@IMHBAIGO@ DB 'Seamr'
	DB	'rPtCtx->VPDelta: 0x', 00H			;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT ??_C@_0CC@DFGILCE@SeamrrPtCtx?9?$DOPagingStructSize?3?50@IMHBAIGO@
EDATA32	SEGMENT
??_C@_0CC@DFGILCE@SeamrrPtCtx?9?$DOPagingStructSize?3?50@IMHBAIGO@ DB 'Se'
	DB	'amrrPtCtx->PagingStructSize: 0x', 00H	;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT ??_C@_0BP@PNNIHBNC@SeamrrPtCtx?9?$DOPtAllocatorPa?3?50x?$AA@IMHBAIGO@
EDATA32	SEGMENT
??_C@_0BP@PNNIHBNC@SeamrrPtCtx?9?$DOPtAllocatorPa?3?50x?$AA@IMHBAIGO@ DB 'S'
	DB	'eamrrPtCtx->PtAllocatorPa: 0x', 00H		;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT ??_C@_0BO@ILNDJIIA@SeamrrPtCtx?9?$DOPtBaseAddrPa?3?50x?$AA@IMHBAIGO@
EDATA32	SEGMENT
??_C@_0BO@ILNDJIIA@SeamrrPtCtx?9?$DOPtBaseAddrPa?3?50x?$AA@IMHBAIGO@ DB 'S'
	DB	'eamrrPtCtx->PtBaseAddrPa: 0x', 00H		;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT ??_C@_0BO@CLKNGODK@SeamrrPtCtx?9?$DOPtBaseAddrLa?3?50x?$AA@IMHBAIGO@
EDATA32	SEGMENT
??_C@_0BO@CLKNGODK@SeamrrPtCtx?9?$DOPtBaseAddrLa?3?50x?$AA@IMHBAIGO@ DB 'S'
	DB	'eamrrPtCtx->PtBaseAddrLa: 0x', 00H		;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT ??_C@_0P@BEDEACLC@SeamRrSize?3?50x?$AA@IMHBAIGO@
EDATA32	SEGMENT
??_C@_0P@BEDEACLC@SeamRrSize?3?50x?$AA@IMHBAIGO@ DB 'SeamRrSize: 0x', 00H ;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@IMHBAIGO@
EDATA32	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@IMHBAIGO@ DB 0aH, 00H		;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT ??_C@_0P@OJPCAKOG@SeamRrBase?3?50x?$AA@IMHBAIGO@
EDATA32	SEGMENT
??_C@_0P@OJPCAKOG@SeamRrBase?3?50x?$AA@IMHBAIGO@ DB 'SeamRrBase: 0x', 00H ;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT ??_C@_0BB@LNBLGDOE@InitSeamrrPtCtx?6?$AA@IMHBAIGO@
EDATA32	SEGMENT
??_C@_0BB@LNBLGDOE@InitSeamrrPtCtx?6?$AA@IMHBAIGO@ DB 'InitSeamrrPtCtx', 0aH
	DB	00H						;  ?? ::IMHBAIGO::`string'
EDATA32	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$InitPseamldrPtCtx DD 0a1901H
	DD	097419H
	DD	086419H
	DD	075419H
	DD	063419H
	DD	0e0153219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$MapPage DD 0a1701H
	DD	067417H
	DD	056417H
	DD	045417H
	DD	033417H
	DD	0e015f017H
xdata	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\commonseamldr64\seamrrpaging64.c
;	COMDAT InitPseamldrPtCtx
_TEXT	SEGMENT
SeamrrPtCtx$ = 48
SeamRrVa$ = 56
SeamRrBase$ = 64
SeamRrSize$ = 72
PSeamldrRangeBase$ = 80
PagingStructSize$ = 88
InitPseamldrPtCtx PROC					; COMDAT

; 25   : {

$LN4:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000f	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  00013	41 56		 push	 r14
  00015	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00019	4c 8b f1	 mov	 r14, rcx
  0001c	49 8b d9	 mov	 rbx, r9

; 26   :     (void)SeamRrSize;
; 27   :     COMSERIALOUT("InitSeamrrPtCtx\n");

  0001f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@LNBLGDOE@InitSeamrrPtCtx?6?$AA@IMHBAIGO@
  00026	49 8b f8	 mov	 rdi, r8
  00029	48 8b f2	 mov	 rsi, rdx
  0002c	e8 00 00 00 00	 call	 ComSerialOut

; 28   :     PRINT_HEX_VAL("SeamRrBase: 0x", SeamRrBase);

  00031	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@OJPCAKOG@SeamRrBase?3?50x?$AA@IMHBAIGO@
  00038	e8 00 00 00 00	 call	 ComSerialOut
  0003d	48 8b cf	 mov	 rcx, rdi
  00040	e8 00 00 00 00	 call	 printHex
  00045	48 8d 2d 00 00
	00 00		 lea	 rbp, OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@IMHBAIGO@
  0004c	48 8b cd	 mov	 rcx, rbp
  0004f	e8 00 00 00 00	 call	 ComSerialOut

; 29   :     PRINT_HEX_VAL("SeamRrSize: 0x", SeamRrSize);

  00054	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@BEDEACLC@SeamRrSize?3?50x?$AA@IMHBAIGO@
  0005b	e8 00 00 00 00	 call	 ComSerialOut
  00060	48 8b cb	 mov	 rcx, rbx
  00063	e8 00 00 00 00	 call	 printHex
  00068	48 8b cd	 mov	 rcx, rbp
  0006b	e8 00 00 00 00	 call	 ComSerialOut

; 30   :         
; 31   :     SeamrrPtCtx->PtBaseAddrLa = SeamRrVa + (PSeamldrRangeBase - SeamRrBase) + _8KB;    

  00070	48 8b 4c 24 50	 mov	 rcx, QWORD PTR PSeamldrRangeBase$[rsp]
  00075	48 2b f7	 sub	 rsi, rdi

; 32   :     SeamrrPtCtx->PtBaseAddrPa = SeamRrBase + (PSeamldrRangeBase - SeamRrBase) + _8KB;
; 33   :     
; 34   :     SeamrrPtCtx->PtAllocatorPa = SeamrrPtCtx->PtBaseAddrPa + _4KB;
; 35   :     SeamrrPtCtx->NumPageLevels = 4;

  00078	49 c7 46 18 04
	00 00 00	 mov	 QWORD PTR [r14+24], 4

; 36   : 
; 37   :     SeamrrPtCtx->VPDelta = SeamRrVa - SeamRrBase;

  00080	49 89 76 20	 mov	 QWORD PTR [r14+32], rsi
  00084	48 8d 81 00 20
	00 00		 lea	 rax, QWORD PTR [rcx+8192]
  0008b	48 03 c6	 add	 rax, rsi
  0008e	49 89 06	 mov	 QWORD PTR [r14], rax
  00091	48 8d 81 00 20
	00 00		 lea	 rax, QWORD PTR [rcx+8192]
  00098	49 89 46 08	 mov	 QWORD PTR [r14+8], rax

; 38   : 
; 39   :     SeamrrPtCtx->PagingStructSize = PagingStructSize;
; 40   : 
; 41   :     PRINT_HEX_VAL("SeamrrPtCtx->PtBaseAddrLa: 0x", SeamrrPtCtx->PtBaseAddrLa);

  0009c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BO@CLKNGODK@SeamrrPtCtx?9?$DOPtBaseAddrLa?3?50x?$AA@IMHBAIGO@
  000a3	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  000a9	49 89 46 10	 mov	 QWORD PTR [r14+16], rax
  000ad	48 8b 44 24 58	 mov	 rax, QWORD PTR PagingStructSize$[rsp]
  000b2	49 89 46 28	 mov	 QWORD PTR [r14+40], rax
  000b6	e8 00 00 00 00	 call	 ComSerialOut
  000bb	49 8b 0e	 mov	 rcx, QWORD PTR [r14]
  000be	e8 00 00 00 00	 call	 printHex
  000c3	48 8b cd	 mov	 rcx, rbp
  000c6	e8 00 00 00 00	 call	 ComSerialOut

; 42   :     PRINT_HEX_VAL("SeamrrPtCtx->PtBaseAddrPa: 0x", SeamrrPtCtx->PtBaseAddrPa);

  000cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BO@ILNDJIIA@SeamrrPtCtx?9?$DOPtBaseAddrPa?3?50x?$AA@IMHBAIGO@
  000d2	e8 00 00 00 00	 call	 ComSerialOut
  000d7	49 8b 4e 08	 mov	 rcx, QWORD PTR [r14+8]
  000db	e8 00 00 00 00	 call	 printHex
  000e0	48 8b cd	 mov	 rcx, rbp
  000e3	e8 00 00 00 00	 call	 ComSerialOut

; 43   :     PRINT_HEX_VAL("SeamrrPtCtx->PtAllocatorPa: 0x", SeamrrPtCtx->PtAllocatorPa);

  000e8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BP@PNNIHBNC@SeamrrPtCtx?9?$DOPtAllocatorPa?3?50x?$AA@IMHBAIGO@
  000ef	e8 00 00 00 00	 call	 ComSerialOut
  000f4	49 8b 4e 10	 mov	 rcx, QWORD PTR [r14+16]
  000f8	e8 00 00 00 00	 call	 printHex
  000fd	48 8b cd	 mov	 rcx, rbp
  00100	e8 00 00 00 00	 call	 ComSerialOut

; 44   :     PRINT_HEX_VAL("SeamrrPtCtx->PagingStructSize: 0x", SeamrrPtCtx->PagingStructSize);

  00105	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CC@DFGILCE@SeamrrPtCtx?9?$DOPagingStructSize?3?50@IMHBAIGO@
  0010c	e8 00 00 00 00	 call	 ComSerialOut
  00111	49 8b 4e 28	 mov	 rcx, QWORD PTR [r14+40]
  00115	e8 00 00 00 00	 call	 printHex
  0011a	48 8b cd	 mov	 rcx, rbp
  0011d	e8 00 00 00 00	 call	 ComSerialOut

; 45   :     PRINT_HEX_VAL("SeamrrPtCtx->VPDelta: 0x", SeamrrPtCtx->VPDelta);

  00122	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BJ@DMOBKCLP@SeamrrPtCtx?9?$DOVPDelta?3?50x?$AA@IMHBAIGO@
  00129	e8 00 00 00 00	 call	 ComSerialOut
  0012e	49 8b 4e 20	 mov	 rcx, QWORD PTR [r14+32]
  00132	e8 00 00 00 00	 call	 printHex
  00137	48 8b cd	 mov	 rcx, rbp
  0013a	e8 00 00 00 00	 call	 ComSerialOut

; 46   :     return SeamrrPtCtx;
; 47   : }

  0013f	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00144	49 8b c6	 mov	 rax, r14
  00147	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  0014c	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00151	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  00156	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0015a	41 5e		 pop	 r14
  0015c	c3		 ret	 0
InitPseamldrPtCtx ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\work\np_seamldr\gnr\po\pr\public\firmware.security.tdx.np-seamldr\seamldr_src\core\commonseamldr64\seamrrpaging64.c
;	COMDAT MapPage
_TEXT	SEGMENT
SeamrrPtCtx$ = 24
LinearAddr$ = 32
PhysAddr$ = 40
Attr$ = 48
PageMappingSize$ = 56
IsKeyHoleMapping$ = 64
MapPage	PROC						; COMDAT

; 49   : UINT64* MapPage(SEAMRR_PT_CTX* SeamrrPtCtx, UINT64 LinearAddr, UINT64 PhysAddr, UINT64 Attr, PAGE_SIZE PageMappingSize, BOOL IsKeyHoleMapping) {

$LN17:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000f	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  00013	41 56		 push	 r14
  00015	41 57		 push	 r15

; 50   :     UINT32 PtIdx, Idx;
; 51   :     UINT64 *PxeLinear;
; 52   :     UINT64 *PxePhysical = NULL;
; 53   :     UINT64 CurNumPageLevels = SeamrrPtCtx->NumPageLevels;

  00017	48 8b 41 18	 mov	 rax, QWORD PTR [rcx+24]
  0001b	45 33 db	 xor	 r11d, r11d

; 54   :     UINT32 PtShiftBits = 12;
; 55   : 
; 56   :     if (PageMappingSize == PAGE_2M) {

  0001e	83 7c 24 38 01	 cmp	 DWORD PTR PageMappingSize$[rsp], 1
  00023	49 8b f9	 mov	 rdi, r9
  00026	49 8b f0	 mov	 rsi, r8
  00029	48 8b da	 mov	 rbx, rdx
  0002c	4c 8b d1	 mov	 r10, rcx
  0002f	45 8d 73 0c	 lea	 r14d, QWORD PTR [r11+12]
  00033	75 0c		 jne	 SHORT $LN5@MapPage

; 57   :         CurNumPageLevels--;

  00035	48 ff c8	 dec	 rax

; 58   :         PtShiftBits = 21;

  00038	45 8d 73 15	 lea	 r14d, QWORD PTR [r11+21]

; 59   :         Attr |= IA32_PG_PS;

  0003c	48 0f ba ef 07	 bts	 rdi, 7
$LN5@MapPage:

; 60   :     }
; 61   : 
; 62   : //    PRINT_HEX_VAL("Mapping PA ", PhysAddr);
; 63   : //    PRINT_HEX_VAL("To LA ", LinearAddr);
; 64   :     PxeLinear = (UINT64 *)SeamrrPtCtx->PtBaseAddrLa;

  00041	4c 8b 01	 mov	 r8, QWORD PTR [rcx]

; 65   :     // walk and fill if needed non leaf levels
; 66   :     for (Idx = 0; Idx < CurNumPageLevels - 1; Idx++) {

  00044	4c 8d 78 ff	 lea	 r15, QWORD PTR [rax-1]
  00048	45 33 c9	 xor	 r9d, r9d
  0004b	4d 85 ff	 test	 r15, r15
  0004e	0f 84 c2 00 00
	00		 je	 $LN15@MapPage
$LL4@MapPage:

; 67   :         PtIdx = (LinearAddr >> ((SeamrrPtCtx->NumPageLevels - 1) * 9 - Idx * 9 + 12)) & 0x1ff;

  00054	41 8a 52 18	 mov	 dl, BYTE PTR [r10+24]
  00058	43 8d 0c c9	 lea	 ecx, DWORD PTR [r9+r9*8]
  0005c	80 c2 ff	 add	 dl, 255			; 000000ffH
  0005f	8a c2		 mov	 al, dl
  00061	c0 e0 03	 shl	 al, 3
  00064	02 d0		 add	 dl, al
  00066	2a d1		 sub	 dl, cl
  00068	8d 4a 0c	 lea	 ecx, DWORD PTR [rdx+12]
  0006b	48 8b d3	 mov	 rdx, rbx
  0006e	48 d3 ea	 shr	 rdx, cl
  00071	81 e2 ff 01 00
	00		 and	 edx, 511		; 000001ffH

; 68   :         // check if PT exists
; 69   :         if (PxeLinear[PtIdx] == 0) {

  00077	8b ea		 mov	 ebp, edx
  00079	49 83 3c d0 00	 cmp	 QWORD PTR [r8+rdx*8], 0
  0007e	75 6e		 jne	 SHORT $LN6@MapPage

; 70   :             // if the allocator reached the data region - error
; 71   :             if (SeamrrPtCtx->PtAllocatorPa >= SeamldrData.SeamrrBase + SeamldrData.SeamrrSize -

  00080	48 8b 05 88 01
	00 00		 mov	 rax, QWORD PTR SeamldrData+392
  00087	48 8b 0d 40 00
	00 00		 mov	 rcx, QWORD PTR SeamldrData+64
  0008e	49 8b 52 10	 mov	 rdx, QWORD PTR [r10+16]
  00092	48 2b 48 10	 sub	 rcx, QWORD PTR [rax+16]
  00096	48 2b 48 08	 sub	 rcx, QWORD PTR [rax+8]
  0009a	48 2b 08	 sub	 rcx, QWORD PTR [rax]
  0009d	48 8b 05 38 00
	00 00		 mov	 rax, QWORD PTR SeamldrData+56
  000a4	48 05 00 e0 ff
	ff		 add	 rax, -8192		; ffffffffffffe000H
  000aa	48 03 c8	 add	 rcx, rax
  000ad	48 3b d1	 cmp	 rdx, rcx
  000b0	0f 83 8f 00 00
	00		 jae	 $LN11@MapPage

; 75   :             }
; 76   :             PxeLinear[PtIdx] = SeamrrPtCtx->PtAllocatorPa | IA32_PG_P | IA32_PG_RW | IA32_PG_A | IA32_PG_U;

  000b6	48 83 ca 27	 or	 rdx, 39			; 00000027H

; 77   :             // non leaf PDE mapping keyhole pages
; 78   :             if (IsKeyHoleMapping && (2 == SeamrrPtCtx->NumPageLevels - Idx)) {

  000ba	80 7c 24 40 00	 cmp	 BYTE PTR IsKeyHoleMapping$[rsp], 0
  000bf	49 89 14 e8	 mov	 QWORD PTR [r8+rbp*8], rdx
  000c3	74 21		 je	 SHORT $LN8@MapPage
  000c5	49 8b 4a 18	 mov	 rcx, QWORD PTR [r10+24]
  000c9	41 8b c1	 mov	 eax, r9d
  000cc	48 2b c8	 sub	 rcx, rax
  000cf	48 83 f9 02	 cmp	 rcx, 2
  000d3	75 11		 jne	 SHORT $LN8@MapPage

; 79   :                 PxeLinear[PtIdx] |= IA32_PG_NX;

  000d5	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  000df	48 0b d0	 or	 rdx, rax
  000e2	49 89 14 e8	 mov	 QWORD PTR [r8+rbp*8], rdx
$LN8@MapPage:

; 80   :             }
; 81   :             SeamrrPtCtx->PtAllocatorPa += SEAMRR_PAGE_SIZE;

  000e6	49 81 42 10 00
	10 00 00	 add	 QWORD PTR [r10+16], 4096 ; 00001000H
$LN6@MapPage:

; 82   :         }
; 83   :         
; 84   :         PxePhysical = (UINT64 *)(PxeLinear[PtIdx] & SeamldrData.PhysAddrMask & (~(SEAMRR_PAGE_SIZE - 1)));

  000ee	4c 8b 1d 18 00
	00 00		 mov	 r11, QWORD PTR SeamldrData+24
  000f5	41 ff c1	 inc	 r9d
  000f8	4d 23 1c e8	 and	 r11, QWORD PTR [r8+rbp*8]

; 85   :         PxeLinear = (UINT64 *)((INT64)PxePhysical + SeamrrPtCtx->VPDelta);        // read pxe from virtual address

  000fc	4d 8b 42 20	 mov	 r8, QWORD PTR [r10+32]
  00100	49 81 e3 00 f0
	ff ff		 and	 r11, -4096		; fffffffffffff000H
  00107	4d 03 c3	 add	 r8, r11
  0010a	41 8b c1	 mov	 eax, r9d
  0010d	49 3b c7	 cmp	 rax, r15
  00110	0f 82 3e ff ff
	ff		 jb	 $LL4@MapPage
$LN15@MapPage:

; 86   :     }
; 87   :     // map leaf level
; 88   :     PtIdx = (LinearAddr >> PtShiftBits) & 0x1ff;
; 89   :     PxeLinear[PtIdx] = PhysAddr | Attr;

  00116	48 0b f7	 or	 rsi, rdi
  00119	41 8b ce	 mov	 ecx, r14d
  0011c	48 d3 eb	 shr	 rbx, cl

; 90   :     // return PT used for mapping
; 91   :     return PxePhysical;

  0011f	49 8b c3	 mov	 rax, r11
  00122	81 e3 ff 01 00
	00		 and	 ebx, 511		; 000001ffH
  00128	49 89 34 d8	 mov	 QWORD PTR [r8+rbx*8], rsi
$LN1@MapPage:

; 92   : }

  0012c	48 8b 5c 24 18	 mov	 rbx, QWORD PTR [rsp+24]
  00131	48 8b 6c 24 20	 mov	 rbp, QWORD PTR [rsp+32]
  00136	48 8b 74 24 28	 mov	 rsi, QWORD PTR [rsp+40]
  0013b	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
  00140	41 5f		 pop	 r15
  00142	41 5e		 pop	 r14
  00144	c3		 ret	 0
$LN11@MapPage:

; 72   :                 (C_P_SYS_INFO_TABLE_SIZE + SeamldrData.PSeamldrConsts->CCodeRgnSize + SeamldrData.PSeamldrConsts->CDataStackSize + P_SEAMLDR_SHADOW_STACK_SIZE + 
; 73   :                     SeamldrData.PSeamldrConsts->CDataRgnSize)) {
; 74   :                 return NULL;

  00145	33 c0		 xor	 eax, eax
  00147	eb e3		 jmp	 SHORT $LN1@MapPage
MapPage	ENDP
_TEXT	ENDS
END
